* TEST:
  - playerState:
    - loads breadsCrumbs
    - loads filter
    - fetches refs.
    - filters refs.
  - dive:
    - sets breadCrumbs.
      - saves.
    - sets filter.
      - saves.
    - fetches refs.
    - filters refs.

* a Refs object loads some refs async.
  - when loaded, a filter can be applied.
  - while loading, the filter may already change.
  - the filter awaits the Ref list to be loaded.
    > the filter returns a promise.
    > Since the Refs object may load immediately, an initial filter should be given at construction time.

* When a Ref is  clicked,, dive into it:
   - setup new breadcrumbs (see below).
   - show results based on breadCrumbs.
     > this implies that the active filter is part of the breadcrumbs.
       > but it should not be shown.
     > OR: the active filter is not part of the breadcrumbs.
       > saved separately?
       > filtering always takes 2 filters: the active filter and the last breadcrumb filter.
       > the last breadCrumb pre-fetches a Refs object.
         > filter is applied to this Refs object.

 When app is loaded
   - load the breadCrumbs and current filter.
     - todo: rename to currentBrowsingFilter.
   - fetch the Refs object based on the last breadcrumb.
     > if no last breadcrumb, fetch all refs.

* Refs: how to load from fetch?
  > controller fetches...
  > sets refs in model.
  > model notifies listeners?
    > who applies the filter?

* Filter breadcrumbs.
  - if the last breadcrumb is a uri, fetch it.
  - if the last breadcrumb is a filter
    - check if there's a previous breadcrumb.
      - if yes, fetch it and store the refs.
        > in the model?
      - if no, use all refs.
  > the Refs only works if the refs are loaded!
    > perhaps create a Refs object after loading the refs
      > then put that refs in the mocel as currentRefs, with the uri that was used to load them. (could be empty).
      > yeah...seems like a good idea.
      > but always keep an allRefs object around.


* BreadCrumbs:
  > when starting, there are no breadcrumbs.
  > where do we store the current filter?
  > or is the last breadCrumb not displayed?
  > or do we have an active filter that is NOT part of the breadcrumbs?
    > when does it become a breadcrumb?
      > when the user drills down.


* show an info button next to filter buttons.
  > show info block with a "remove info button" button. When pressing, inform user this can be changed in settings.

* click on search line: drill down:
  > e.g artist > album.
  - save current filter to breadcrumb stack.
  - set filter to

* Show tracklist in timeline.

* Browse scenario:
  - search artist.
  - click artist.
    > save filter as breadcrumb: "sdf" > Artist_name
      > clicking breadcrumb "sdf" resets the filter.
      > clicking the Artist_name...self evident.
    > change filter to show only albums of this artist.
    > user filters for "sdfsdf" (and sets some other toggles perhaps).
      > set breadcrumb to "sdf" > Artist_name > "sdfsdf"
    - click album.
      > set breadcrumb to
          "sdf" > Artist_name >  --> don't show the '>' if splitting over multiple lines.
          "sdfsdf" > Album_name
        > if the text filter is empty, show "all".
      > change filter to show only tracks of this album.

* Browse hiararchy and thus, default toggles:
  - artists > albums
  - albums > tracks
  - playlists > tracks
  - genres > albums
    > albums likely have one genre.

* Separate model view controller.
  > model:
    - store data
    - inform listeners
      > ideally, the listeners should only update the view, not the model (via the controller).
        > if extra data needs to be loaded, don't do it in response to a listener on the model.
        > I think this will prevent dead loops of data updates.
    - provide defaults
  > view: display data.
  > controller:
    - interact with model and view
    - retrieve and persist data.
    - TODO: no getXXX functions!
      > ambiguous name!
        > get where?
          > make proxies.
      > never get data directly from backend.
        > always get from model.
        > convert get methods to fetch methods that DON'T return data directly.
      > except getXXXCached()

* In main view:
  > apply the browse filter.
    > in the model, create a filtered Ref list.

* In the model:
  > create a Ref object for every track, album, artist,...
  > create a filtered Ref list.
    > with listeners.


* At startup (or at browse open), build a list of all Ref objects.
  > that's just the name and the uri.
  > that's purely based on mopidy-local !
  > streams are nog local but just a uri in a playlist.
  > what do we need for search?
    > just the name and uri should do...

Build indexedDb
===============
* Tracks are the lowest level.
  > contain link to the album uri, if any.
* Albums contain tracks.
  > possibly of multiple artists.
* Artists 'contain'
  - albums
  - tracks
  - genres?
* Genres contain
  - albums
  - tracks

* data sources:
  - local files : //local:
  - files : //file:
  - urls for streams. : //http, etc...

* commands for database:
  - browse
    > find directory structure
    > for every backend root
  - search
    > where `field` contains...
      > e.g. `artist` = ['ikke', 'gij']
      > special field `any` to search all fields.
  - distinct: DO NOT USE
  > Iris uses this url to get all artists:
    : local:directory?type=artist&role=albumartist
      > after removing the role, all the artists are shown.


* Prepare list of items to browse.
  > From what sources?
    > Mopidy has:
      - history
      - library: backends
      - playlists
      -
    > Local files: this is a http protocol?
      > any source or protocol!
    > Other extensions?
      > Url protocols?
        > unlikely: too technical. Perhaps configure in settings.

Browse
======
- a search field
  > pre-filled with last search.
- search results
- filter buttons:
  > a row of buttons for each of the following:
    - albums: square with disc sticking out?
    - artists: torso silhouette?
    - tracks: lines?
    - streams/radio: radio icon or antenna? (wifi logo-like)
    - files: file icon
    - playlists: stacked page of lines > tracks icon, but stacked.
    - history: history icon: curled up lines.
    - radio: radio icon?
    - genre: veritas or flower icon.
      > a circle, a square and a triangle?
      > Arrows pointing in different directions?
        > different shapes?

* have image view and a list view.
  > have a wall-of-albums,
    > perhaps even random?
    > perhaps 3 views: list, album (/w title) and wall?
* image views are configurable
  > number of columns.
  > spacing configurable?
* buttons to filter search results for albums, artists and tracks.
* when on a track, allow to browse upward into album, artist, playlists.

Browse: user behaviour:
  > cursor immediately in search field,, which is the header field?
    > could give conflict with error messages.
  > last search is prefilled.
  > submit search per key-stroke.
    > if not fast enough: local cache.
  > how to go back?
    > the browse icon changes in a mini album.

 Buttons (ellipsis), double click, long click
 =============================================
 * These can be set via settings.
   > default is buttons=visible.
* Single click is selection by default.
* Double click is play.
* Long click is same as button.

Queue
======
When queue goes to the next track, these events occur:
  - volume_changed
  - track_playback_ended -> time_positin, tl_Track
  - playback_state_changed -> playing
  - track_playback_started -> TlTrack


* Iris player seems to have a way to get all the tracks really fast.
  > but cannot add radio strams (with names) to playlists.
  > also only possible to add a track to a list via the "now playing" screen.


* Track line: ellipsis button:
  - Play
  - Details
    > shows artist, album and tracklists this track belongs to.

* Webcomponent with template: https://css-tricks.com/web-components-are-easier-than-you-think/

* Implement start screen.
  > if no current track:
    > get history.
      > if none: (probably!)
        > show Browser in that case.
      > if found, display it, positioned at last track.
  > if current track:
    > it will probably be shown automatically, but also start playing automatically...which may not be a bad thing...

* when a new track is played (default click on play button), these commands are sent:
  - play is stopped. (needed? or automatically done when clearinngg the tracklist?)
  - the tracklist is cleared.
  - new track is added to the tracklist
  - tracklist filter is cleared.
  >> event:tracklistchanged is sent.
  > that's it!
    > query:
      - tracklist
      - current track (TLtrack

Layout
=========

Start screen always last track/stream.
  > what if there is no last track?
  > A user will want to select something to play.
    > Goto Search and show history, if present.
  > All lists will highlight the active (if any) track/album,...
When playing a track of an album, artist, playlist:
  > user shoud be able to go to the list.
  > if the window is long (or wide) enough, show the list, centered around the active track.
  > user can hide this list to have a cleaner view.
    > need a button to show the list.
      > icon? a hamburger with 4 lines and a brighter line in the middle?

 When a track is playing, a mini-player should be displayed at the bottom (or top?).
 Volume, plus a mute button should always be visible.
 Playback options should be under a menu, as they are not often used.

Per track or list:
   > highlight the active one.
   > a play button to immediately start playing.
   > a menu for all the other actions.

Search button is entrypoint to all lists of tracks
  - history (this one on top or even expanded, if present)
  - streams
  - files
  - albums
  - artists

Have a stream title history as well. Per radio station?
Stream title history has max of 100 items?

* On stream start, and extension start: clear history or at least write a dummy history block:
      ---
      Starting stream xxx
      ---
  > not needed on extension start, if on stream start creates a separator.

* Replace Home pane with last played..
  > perhaps merge this pane with Now Playing?
* get rid of jQuery
* flex or grid?
* setVolume(): use a curved function for better low volume control.
  > User option?
  > For both input and output in range [0..100]:
    > Quadratic: (x*x)/100
    > Cubic: (x*x*x)/10000


* "Streams" are mopidy playlists.
  > has 2 fields: name and uri
  > if uri starts with file: or http:, a different backend is triggered.


  Track info for streams or files
  ---------------------------------
  Streams
  -------
  {
    "tl_track": {
      "__model__": "TlTrack",
      "tlid": 1,
      "track": {
        "__model__": "Track",
        "uri": "http://icecast.vrtcdn.be/klara-high.mp3",
        "name": "VRT Klara"
      }
    },
    "event": "track_playback_started"
  }

  Files
  -----
  {
    "tl_track": {
      "__model__": "TlTrack",
      "tlid": 2,
      "track": {
        "__model__": "Track",
        "uri": "file:///media/DATA1/Music/Air/Moon%20Safari/01%20La%20Femme%20d%27Argent.wma",
        "name": "La Femme d'Argent",
        "artists": [
          {
            "__model__": "Artist",
            "name": "Air"
          }
        ],
        "album": {
          "__model__": "Album",
          "name": "Moon Safari",
          "date": "1998"
        },
        "track_no": 1,
        "date": "1998",
        "length": 429986,
        "bitrate": 128639
      }
    },
    "event": "track_playback_started"
  }
