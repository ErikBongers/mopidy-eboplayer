{"version":3,"file":"bundle.js","names":["state","state: State","NoStreamTitles: StreamTitles","AlbumNone: AlbumDataNone","state","getState","array: any[]","model: FileTrackModel","getState","state","historyObject: Object","refs: SearchResult[]","getState","streamTitles: StreamTitles","state","albumModel: AlbumModel","radioStreams: models.Ref<RadioUri>[]","getState","task: () => void","text","fetches: Promise<string>[]","getState","allLookups: Promise<void>[]","tr","getState","position: string","button: string","imageUrl: string","getState","btn: EboButton","eventName: EboplayerEvents","connectOptions: Options","state"],"sources":["../typescript/eventEmitter.ts","../typescript/jsonRpcController.ts","../js/mopidy.ts","../typescript/timer.ts","../typescript/synced_timer.ts","../typescript/playerState.ts","../typescript/util/idStack.ts","../typescript/breadCrumb.ts","../typescript/modelTypes.ts","../typescript/events.ts","../typescript/model.ts","../typescript/views/dataRequester.ts","../typescript/views/view.ts","../typescript/views/headerView.ts","../typescript/functionsvars.ts","../typescript/library.ts","../typescript/commands.ts","../typescript/global.ts","../typescript/proxies/mopidyProxy.ts","../typescript/proxies/localStorageProxy.ts","../typescript/refs.ts","../typescript/proxies/webProxy.ts","../typescript/controller.ts","../typescript/views/buttonBarView.ts","../typescript/Batching.ts","../typescript/components/EboComponent.ts","../typescript/components/eboProgressBar.ts","../typescript/views/timelineView.ts","../typescript/components/eboBigTrackComp.ts","../typescript/views/componentViewAdapter.ts","../typescript/views/bigTrackViewCurrentOrSelectedAdapter.ts","../typescript/components/eboAlbumTracksComp.ts","../typescript/views/mainView.ts","../typescript/components/eboBrowseComp.ts","../typescript/MouseTimer.ts","../typescript/components/eboButton.ts","../typescript/components/eboBigAlbumComp.ts","../typescript/components/eboButtonBarComp.ts","../typescript/components/eboMenuButton.ts","../typescript/components/eboListButtonBar.ts","../typescript/gui.ts"],"sourcesContent":["//todo: use this one instead?\r\n// https://javascript.plainenglish.io/building-a-simple-event-emitter-in-javascript-f82f68c214ad\r\nexport class EventEmitter {\r\n    listeners = [];\r\n    supervisors = [];\r\n\r\n    emit(eventName: string, ...data) {\r\n        this.listeners.filter(({name}) => name === eventName)\r\n            .forEach(({callback}) => {\r\n                setTimeout(() => callback.call(this, ...data), 0);\r\n            });\r\n        this.supervisors.forEach(callback => {\r\n            setTimeout(() => callback.call(this, ...data), 0);\r\n        });\r\n    }\r\n\r\n    on(name: string | Function, callback?: any) { //todo: make callback type more specific?\r\n        if (typeof name === 'string' && typeof callback === 'function') {\r\n            this.listeners.push({name, callback});\r\n            return;\r\n        }\r\n        if (typeof name === 'function') {\r\n            this.supervisors.push(name);\r\n        }\r\n    }\r\n\r\n    off(eventName: string, callback: any) {\r\n        this.removeListener(eventName, callback);\r\n    }\r\n\r\n    destroy() {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    removeAllListeners(eventName?: string) {\r\n        if (!eventName) {\r\n            this.listeners.length = 0;\r\n            return;\r\n        }\r\n        this.listeners = this.listeners.filter(listener => !(listener.name === eventName));\r\n    }\r\n\r\n    removeListener(eventName: string, callback: any) {\r\n        this.listeners = this.listeners.filter(listener =>\r\n            !(listener.name === eventName &&\r\n                listener.callback === callback)\r\n        );\r\n    }\r\n}","import {EventEmitter} from \"./eventEmitter\";\r\n\r\nfunction snakeToCamel(name: string) {\r\n    return name.replace(/(_[a-z])/g, (match) =>\r\n        match.toUpperCase().replace(\"_\", \"\")\r\n    );\r\n}\r\n\r\nexport class JsonRpcController extends EventEmitter {\r\n    private readonly _pendingRequests: {}; //this initialization gets stripped by rolldown!\r\n    private _webSocket: WebSocket;\r\n    private _backoffDelay: number; //todo: rename to currentDelay\r\n    private readonly webSocketUrl: string;\r\n    private backoffDelayMin: number;\r\n    private backoffDelayMax: number;\r\n\r\n    constructor(webSocketUrl: string, backoffDelayMin: number, backoffDelayMax: number) {\r\n        super();\r\n        this.webSocketUrl = webSocketUrl;\r\n        this._pendingRequests = {};\r\n        this._webSocket = null;\r\n        this._backoffDelay = backoffDelayMin;\r\n        this.backoffDelayMin = backoffDelayMin;\r\n        this.backoffDelayMax = backoffDelayMax;\r\n        this.hookUpEvents();\r\n        //this.connect(); //todo: connect AFTER construction!  > To allow for other events to hook up.\r\n    }\r\n\r\n    private hookUpEvents() {\r\n        this.on(\"websocket:close\", this.onWebSocketClose);\r\n        this.on(\"websocket:error\", this.handleWebSocketError);\r\n        this.on(\"websocket:incomingMessage\", this.handleMessage);\r\n    }\r\n\r\n    connect() {\r\n        if (this._webSocket) {\r\n            if (this._webSocket.readyState === WebSocket.OPEN) {\r\n                return;\r\n            }\r\n            this._webSocket.close();\r\n        }\r\n\r\n        this._webSocket = new WebSocket(this.webSocketUrl);\r\n\r\n        this._webSocket.onclose = (close) => {\r\n            this.emit(\"websocket:close\", close);\r\n        };\r\n        this._webSocket.onerror = (error) => {\r\n            this.emit(\"websocket:error\", error);\r\n        };\r\n        this._webSocket.onopen = () => {\r\n            this.emit(\"websocket:open\");\r\n            this._backoffDelay = this.backoffDelayMin;\r\n\r\n        };\r\n        this._webSocket.onmessage = (message) => {\r\n            this.emit(\"websocket:incomingMessage\", message);\r\n        };\r\n    }\r\n\r\n    private onWebSocketClose(closeEvent: any) {\r\n        Object.keys(this._pendingRequests).forEach((requestId) => {\r\n            const {reject} = this._pendingRequests[requestId];\r\n            delete this._pendingRequests[requestId];\r\n            const error = new ConnectionError(\"WebSocket closed\");\r\n            error.closeEvent = closeEvent;\r\n            reject(error);\r\n        });\r\n        this._reconnect();\r\n    }\r\n\r\n    close() {\r\n        this.eventOff(\"state:offline\", this._reconnect);\r\n        if (this._webSocket) {\r\n            this._webSocket.close();\r\n        }\r\n    }\r\n\r\n    eventOff(eventName?: string, callback?: any) {\r\n        if (!eventName) {\r\n            this.removeAllListeners();\r\n            return;\r\n        }\r\n        if (!callback) {\r\n            this.removeAllListeners(eventName);\r\n            return;\r\n        }\r\n        this.removeListener(eventName, callback);\r\n    }\r\n\r\n    private handleWebSocketError(error: any) {\r\n        console.warn(\"WebSocket error:\", error.stack || error);\r\n    }\r\n\r\n    send(message: Object) {\r\n        switch (this._webSocket.readyState) {\r\n            case WebSocket.CONNECTING:\r\n                return Promise.reject(\r\n                    new ConnectionError(\"WebSocket is still connecting\")\r\n                );\r\n            case WebSocket.CLOSING:\r\n                return Promise.reject(\r\n                    new ConnectionError(\"WebSocket is closing\")\r\n                );\r\n            case WebSocket.CLOSED:\r\n                return Promise.reject(\r\n                    new ConnectionError(\"WebSocket is closed\")\r\n                );\r\n            default:\r\n                return new Promise((resolve, reject) => {\r\n                    const jsonRpcMessage = {\r\n                        ...message,\r\n                        jsonrpc: \"2.0\",\r\n                        id: this._nextRequestId(),\r\n                    };\r\n                    this._pendingRequests[jsonRpcMessage.id] = {resolve, reject};\r\n                    this._webSocket.send(JSON.stringify(jsonRpcMessage));\r\n                    this.emit(\"websocket:outgoingMessage\", jsonRpcMessage);\r\n                });\r\n        }\r\n    }\r\n\r\n    private handleMessage(message) {\r\n        try {\r\n            const data = JSON.parse(message.data);\r\n            if (Object.hasOwnProperty.call(data, \"id\")) {\r\n                this.handleRpcResponse(data);\r\n            } else if (Object.hasOwnProperty.call(data, \"event\")) {\r\n                this.handleEvent(data);\r\n            } else {\r\n                console.warn(\r\n                    `Unknown message type received. Message was: ${message.data}`\r\n                );\r\n            }\r\n        } catch (error) {\r\n            if (error instanceof SyntaxError) {\r\n                console.warn(\r\n                    `WebSocket message parsing failed. Message was: ${message.data}`\r\n                );\r\n            } else {\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleRpcResponse(responseMessage) {\r\n        if (\r\n            !Object.hasOwnProperty.call(this._pendingRequests, responseMessage.id)\r\n        ) {\r\n            console.warn(\r\n                \"Unexpected response received. Message was:\",\r\n                responseMessage\r\n            );\r\n            return;\r\n        }\r\n        const {resolve, reject} = this._pendingRequests[responseMessage.id];\r\n        delete this._pendingRequests[responseMessage.id];\r\n        if (Object.hasOwnProperty.call(responseMessage, \"result\")) {\r\n            resolve(responseMessage.result);\r\n        } else if (Object.hasOwnProperty.call(responseMessage, \"error\")) {\r\n            const error = new ServerError(responseMessage.error.message);\r\n            error.code = responseMessage.error.code;\r\n            error.data = responseMessage.error.data;\r\n            reject(error);\r\n            console.warn(\"Server returned error:\", responseMessage.error);\r\n        } else {\r\n            const error = new OtherError(\"Response without 'result' or 'error' received\");\r\n            error.data = {response: responseMessage};\r\n            reject(error);\r\n            console.warn(\r\n                \"Response without 'result' or 'error' received. Message was:\",\r\n                responseMessage\r\n            );\r\n        }\r\n    }\r\n\r\n    private handleEvent(eventMessage) {\r\n        const data = {...eventMessage};\r\n        delete data.event;\r\n        const eventName = `event:${snakeToCamel(eventMessage.event)}`;\r\n        this.emit(\"event\", [eventName, data]);\r\n        this.emit(eventName, data);\r\n    }\r\n\r\n    static idCounter = -1;\r\n\r\n    _nextRequestId() {\r\n        return ++JsonRpcController.idCounter;\r\n    }\r\n\r\n    _reconnect() {\r\n        // We asynchronously process the reconnect because we don't want to start\r\n        // emitting \"reconnectionPending\" events before we've finished handling the\r\n        // \"state:offline\" event, which would lead to emitting the events to\r\n        // listeners in the wrong order.\r\n        setTimeout(() => {\r\n            this.emit(\"state\", [\r\n                \"reconnectionPending\",\r\n                { timeToAttempt: this._backoffDelay}\r\n            ]);\r\n            this.emit(\"reconnectionPending\", {\r\n                timeToAttempt: this._backoffDelay,\r\n            });\r\n            setTimeout(() => {\r\n                this.emit(\"state\", \"reconnecting\");\r\n                this.emit(\"reconnecting\");\r\n                this.connect();\r\n            }, this._backoffDelay);\r\n            this._backoffDelay *= 2;\r\n            if (this._backoffDelay > this.backoffDelayMax) {\r\n                this._backoffDelay = this.backoffDelayMax;\r\n            }\r\n        }, 0);\r\n    }\r\n}\r\n\r\nclass ConnectionError extends Error {\r\n    closeEvent?: any;\r\n\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"ConnectionError\";\r\n    }\r\n}\r\n\r\nclass ServerError extends Error {\r\n    code: any;\r\n    data: any;\r\n\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"ServerError\";\r\n    }\r\n}\r\n\r\nclass OtherError extends Error {\r\n    data: any;\r\n\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"OtherError\";\r\n    }\r\n}","// Type definitions for js v1.2.0, Mopidy v3.0.2 WebSocket API\r\n\r\nimport {JsonRpcController} from \"../typescript/jsonRpcController\";\r\nimport MopidyEventName = core.MopidyEventName;\r\nimport {AlbumUri, AllUris} from \"../typescript/modelTypes\";\r\n\r\nexport interface Options {\r\n    /**\r\n     * URL used when creating new WebSocket objects.\r\n     *\r\n     * In a browser environment, it defaults to\r\n     * ws://${document.location.host}/mopidy/ws. If the current page is served\r\n     * over HTTPS, it defaults to using wss:// instead of ws://.\r\n     *\r\n     * In a non-browser environment, where document.location isn't available, it\r\n     * defaults to ws://localhost/mopidy/ws.\r\n     */\r\n    webSocketUrl: string;\r\n    /**\r\n     * Whether or not to connect to the WebSocket on instance creation. Defaults\r\n     * to true.\r\n     */\r\n    autoConnect?: boolean;\r\n    /**\r\n     * The minimum number of milliseconds to wait after a connection error before\r\n     * we try to reconnect. For every failed attempt, the backoff delay is doubled\r\n     * until it reaches backoffDelayMax. Defaults to 1000.\r\n     */\r\n    backoffDelayMin?: number;\r\n    /**\r\n     * The maximum number of milliseconds to wait after a connection error before\r\n     * we try to reconnect. Defaults to 64000.\r\n     */\r\n    backoffDelayMax?: number;\r\n    /**\r\n     * If set, this object will be used to log errors from Mopidy.js. This is\r\n     * mostly useful for testing Mopidy.js. Defaults to console.\r\n     */\r\n}\r\n\r\ntype URI = string;\r\n\r\nnamespace models {\r\n    export type ModelType = \"album\" | \"artist\" | \"directory\" | \"playlist\" | \"track\";\r\n\r\n    export class TlTrack {\r\n        readonly tlid: number;\r\n        readonly track: Track;\r\n    }\r\n    export class Track {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly artists: Artist[];\r\n        readonly album: Album;\r\n        readonly composers: Artist[];\r\n        readonly performers: Artist[];\r\n        readonly genre: string;\r\n        readonly track_no: number;\r\n        readonly disc_no: number;\r\n        readonly date: string;\r\n        readonly length: number;\r\n        readonly bitrate: string;\r\n        readonly comment: string;\r\n        readonly musicbrainz_id: string;\r\n        readonly last_modified: number;\r\n    }\r\n    export class SearchResult {\r\n        readonly uri: URI;\r\n        readonly tracks: Track[];\r\n        readonly artists: Artist[];\r\n        readonly albums: Album[];\r\n    }\r\n\r\n    export class Artist {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly sortname: string;\r\n        readonly musicbrainz_id: string;\r\n    }\r\n\r\n    export class Album {\r\n        readonly uri: AlbumUri;\r\n        readonly name: string;\r\n        readonly artists: Artist[];\r\n        readonly num_tracks: number;\r\n        readonly num_discs: number;\r\n        readonly date: string;\r\n        readonly musicbrainz_id: string;\r\n    }\r\n\r\n    export class Image {\r\n        readonly uri: URI;\r\n        readonly width: number;\r\n        readonly height: number;\r\n    }\r\n\r\n    export class Playlist {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly tracks: Track[];\r\n        readonly last_modified: number;\r\n        readonly length: number;\r\n    }\r\n\r\n    export class Ref<T extends AllUris> {\r\n        readonly uri: T;\r\n        name?: string;\r\n        readonly type: ModelType;\r\n    }\r\n}\r\nexport default models\r\n\r\nexport namespace core {\r\n    export type PlaybackState = \"playing\" | \"paused\" | \"stopped\";\r\n    export type QueryField =\r\n        | \"uri\"\r\n        | \"track_name\"\r\n        | \"album\"\r\n        | \"artist\"\r\n        | \"albumartist\"\r\n        | \"composer\"\r\n        | \"performer\"\r\n        | \"track_no\"\r\n        | \"genre\"\r\n        | \"date\"\r\n        | \"comment\"\r\n        | \"any\";\r\n    export type Query = { [key in QueryField]?: string[] };\r\n\r\n    export type MopidyEventName =\r\n        | \"event:trackPlaybackStarted\"\r\n        | \"event:trackPlaybackEnded\"\r\n        | \"event:trackPlaybackResumed\"\r\n        | \"state:online\"\r\n        | \"state:offline\"\r\n        | \"event:optionsChanged\"\r\n        | \"event:playlistChanged\"\r\n        | \"event:playlistDeleted\"\r\n        | \"event:volumeChanged\"\r\n        | \"event:muteChanged\"\r\n        | \"event:streamTitleChanged\"\r\n        | \"event:playbackStateChanged\"\r\n        | \"event:optionsValidationError\"\r\n        | \"event:tracklistChanged\"\r\n        | \"event:seeked\"\r\n        | \"event:playlistsLoaded\"\r\n        ;\r\n\r\n}\r\n\r\nexport class Mopidy {\r\n    _options: Options;\r\n    private rpcController: JsonRpcController;\r\n    constructor(options: Options) {\r\n        const defaultOptions = {\r\n            backoffDelayMin: 1000,\r\n                backoffDelayMax: 64000,\r\n            autoConnect: true,\r\n            webSocketUrl: ''\r\n        };\r\n        this._options = this._configure({...defaultOptions, ...options});\r\n        this.rpcController = new JsonRpcController(this._options.webSocketUrl, this._options.backoffDelayMin, this._options.backoffDelayMax);\r\n        this._delegateEvents();\r\n        if (this._options.autoConnect) {\r\n            this.connect();\r\n        }\r\n    }\r\n\r\n    connect() {\r\n        this.rpcController.connect();\r\n    }\r\n\r\n    on(name: MopidyEventName | Function, callback?: any) {\r\n        this.rpcController?.on(name, callback);\r\n    }\r\n\r\n    private _configure(options: Options) {\r\n        if(options.webSocketUrl)\r\n            return options;\r\n\r\n        let protocol =\r\n            typeof document !== \"undefined\" && document.location.protocol === \"https:\"\r\n                ? \"wss://\"\r\n                : \"ws://\";\r\n        let currentHost =\r\n            (typeof document !== \"undefined\" && document.location.host) ||\r\n            \"localhost\";\r\n        options.webSocketUrl = `${protocol}${currentHost}/mopidy/ws`;\r\n        return options;\r\n    }\r\n\r\n  _delegateEvents() {\r\n    this.rpcController.on(\"websocket:close\", (closeEvent: any) => this.onWebSocketClose(closeEvent));\r\n    this.rpcController.on(\"websocket:open\", () => this._onWebsocketOpen());\r\n  }\r\n\r\n  onWebSocketClose(closeEvent) {\r\n    this.rpcController.emit(\"state\", \"state:offline\");\r\n    this.rpcController.emit(\"state:offline\");\r\n  }\r\n\r\n  close() {\r\n    if (this.rpcController) {\r\n      this.rpcController.close();\r\n    }\r\n  }\r\n\r\n  send(message: Object) {\r\n      return this.rpcController?.send(message);\r\n  }\r\n\r\n  _onWebsocketOpen() {\r\n    this.rpcController.emit(\"state\", \"state:online\");\r\n    this.rpcController.emit(\"state:online\");\r\n  }\r\n}\r\n\r\n","// Helper function to provide a reference time in milliseconds.\r\nlet now = /* Sinon does not currently support faking `window.performance`\r\n             (see https://github.com/sinonjs/sinon/issues/803).\r\n             Changing this to only rely on `new Date().getTime()\r\n             in the interim in order to allow testing of the\r\n             progress timer from MMW.\r\n\r\n             typeof window.performance !== 'undefined' &&\r\n             typeof window.performance.now !== 'undefined' &&\r\n             window.performance.now.bind(window.performance) || Date.now ||*/\r\n    function () {\r\n        return new Date().getTime();\r\n    };\r\n\r\ninterface TimerOptions {\r\n    // Your callback for updating UI state, required.\r\n    callback: (position:number, duration: number) => void,\r\n    // Target frame rate when using legacy setTimeout fallback, default: 30.\r\n    fallbackTargetFrameRate: number,\r\n    // Force legacy setTimeout fallback for testing, default: false.\r\n    disableRequestAnimationFrame: boolean\r\n}\r\n\r\ntype TimerCallback = (position:number, duration:number)=> void;\r\n\r\n// Creates a new timer object, works with both 'new ProgressTimer(options)'\r\n// and just 'ProgressTimer(options). Optionally the timer can also be\r\n// called with only the callback instead of options.\r\nexport class ProgressTimer {\r\n    callback: TimerCallback;\r\n    // Target frame rate when using legacy setTimeout fallback, default: 30.\r\n    fallbackTargetFrameRate = 30;\r\n    // Force legacy setTimeout fallback for testing, default: false.\r\n    disableRequestAnimationFrame = false;\r\n\r\n    _updateId = null;\r\n    _state = null;  // Gets initialized by the set() call.\r\n    private readonly _schedule: (timestamp: number) => number;\r\n    private readonly _cancel: any;\r\n\r\n    constructor(options: TimerOptions | TimerCallback) {\r\n        if (typeof options === 'function') {\r\n            this.callback = options;\r\n        } else {\r\n            this.callback = options.callback;\r\n            this.fallbackTargetFrameRate = options.fallbackTargetFrameRate;\r\n            this.disableRequestAnimationFrame = options.disableRequestAnimationFrame;\r\n        }\r\n\r\n        this._updateId = null;\r\n        this._state = null;  // Gets initialized by the set() call.\r\n\r\n        let frameDuration = 1000 / this.fallbackTargetFrameRate;\r\n\r\n        let useFallback = (\r\n            typeof window.requestAnimationFrame === 'undefined' ||\r\n            typeof window.cancelAnimationFrame === 'undefined' ||\r\n            options['disableRequestAnimationFrame'] || false);\r\n\r\n        // Make sure this works in _update.\r\n        let update = this._update.bind(this);\r\n\r\n        if (useFallback) {\r\n            this._schedule = function (timestamp: number) {\r\n                let timeout = Math.max(timestamp + frameDuration - now(), 0);\r\n                return window.setTimeout(update, Math.floor(timeout));\r\n            };\r\n            this._cancel = window.clearTimeout.bind(window);\r\n        } else {\r\n            this._schedule = window.requestAnimationFrame.bind(window, update);\r\n            this._cancel = window.cancelAnimationFrame.bind(window);\r\n        }\r\n\r\n        this.reset(); // Reuse reset code to ensure we start in the same state.\r\n    }\r\n\r\n// If called with one argument the previous duration is preserved. Note\r\n// that the position can be changed while the timer is running.\r\n    set(position: number, duration: number = undefined) {\r\n        if (!duration) {\r\n            // Fallback to previous duration, whatever that was.\r\n            duration = this._state.duration;\r\n        }\r\n\r\n        // Round down and make sure zero and null are treated as inf.\r\n        duration = Math.floor(Math.max(\r\n            duration === null ? Infinity : duration || Infinity, 0));\r\n\r\n        // Make sure '0 <= position <= duration' always holds.\r\n        position = Math.floor(Math.min(Math.max(position || 0, 0), duration));\r\n\r\n        this._state = {\r\n            initialTimestamp: null,\r\n            initialPosition: position,\r\n            position: position,\r\n            duration: duration\r\n        };\r\n\r\n        // Update right away if we don't have anything running.\r\n        if (this._updateId === null) {\r\n            // TODO: Consider wrapping this in a try/catch?\r\n            this.callback(position, duration);\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Start the timer if it is not already running.\r\n    start() {\r\n        if (this._updateId === null) {\r\n            this._updateId = this._schedule(0);\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Cancel the timer if it us currently tracking progress.\r\n    stop() {\r\n        if (this._updateId !== null) {\r\n            this._cancel(this._updateId);\r\n\r\n            // Ensure we correctly reset the initial position and timestamp.\r\n            this.set(this._state.position, this._state.duration);\r\n            this._updateId = null;  // Last step to avoid callback in set()\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Marks the timer as stopped, sets position to zero and duration to inf.\r\n    reset() {\r\n        return this.stop().set(0, Infinity);\r\n    };\r\n\r\n// Calls the user callback with the current position/duration and then\r\n// schedules the next update run via _schedule if we haven't finished.\r\n    _update(timestamp: number) {\r\n        let state = this._state;  // We refer a lot to state, this is shorter.\r\n\r\n        // Make sure setTimeout has a timestamp and store first reference time.\r\n        timestamp = timestamp || now();\r\n        state.initialTimestamp = state.initialTimestamp || timestamp;\r\n\r\n        // Recalculate position according to start location and reference.\r\n        state.position = (\r\n            state.initialPosition + timestamp - state.initialTimestamp);\r\n\r\n        // Ensure callback gets an integer and that 'position <= duration'.\r\n        let userPosisition = Math.min(\r\n            Math.floor(state.position), state.duration);\r\n\r\n        // TODO: Consider wrapping this in a try/catch?\r\n        this.callback(userPosisition, state.duration);\r\n        // Workaround for https://github.com/adamcik/media-progress-timer/issues/3\r\n        // Mopidy <= 1.1.2 does not always return the correct track position as\r\n        // track changes are being done, which can cause the timer to die unexpectedly.\r\n        //if (state.position < state.duration) {\r\n        this._updateId = this._schedule(timestamp);  // Schedule update.\r\n        //} else {\r\n        //    this._updateId = null;  // Unset since we didn't reschedule.\r\n        //}\r\n    }\r\n}\r\n","import {ProgressTimer} from \"./timer\";\r\nimport {Mopidy} from \"../js/mopidy\";\r\n\r\nfunction delay_exponential (base: number | 'rand', growthFactor: number, attempts: number) {\r\n    /* Calculate number of beats between syncs based on exponential function.\r\n    The format is::\r\n\r\n        base * growthFactor ^ (attempts - 1)\r\n\r\n    If ``base`` is set to 'rand' then a random number between\r\n    0 and 1 will be used as the base.\r\n    Base must be greater than 0.\r\n    */\r\n    if (base === 'rand') {\r\n        base = Math.random()\r\n    }\r\n    // console.log(base + ' * (Math.pow(' + growthFactor + ', (' + attempts + ' - 1)) = ' + base * (Math.pow(growthFactor, (attempts - 1))))\r\n    return base * (Math.pow(growthFactor, (attempts - 1)))\r\n}\r\n\r\nenum SYNC_STATE {\r\n    NOT_SYNCED=0,\r\n    SYNCING= 1,\r\n    SYNCED= 2\r\n}\r\n\r\nexport class SyncedProgressTimer {\r\n    _maxAttempts: number;\r\n    _mopidy: Mopidy;\r\n    syncState = SYNC_STATE.NOT_SYNCED;\r\n    _isSyncScheduled = false;\r\n    _scheduleID = null;\r\n    _syncAttemptsRemaining: number ;\r\n    _previousSyncPosition = null;\r\n    _duration = null;\r\n    _isConnected = false;\r\n    positionNode: Text;\r\n    durationNode: Text;\r\n    private _progressTimer: ProgressTimer;\r\n\r\n    constructor(maxAttempts: number, mopidy: Mopidy) {\r\n        this._maxAttempts = maxAttempts;\r\n        this._mopidy = mopidy;\r\n        this._syncAttemptsRemaining = this._maxAttempts;\r\n\r\n        this.positionNode = document.createTextNode('');\r\n        this.durationNode = document.createTextNode('');\r\n        //todo\r\n        // $('#songelapsed').empty().append(this.positionNode)\r\n        // $('#songlength').empty().append(this.durationNode)\r\n\r\n        this._progressTimer = new ProgressTimer( (position: number, duration: number) => {\r\n            this.timerCallback(position, duration);\r\n            }\r\n        );\r\n\r\n        //todo\r\n        // this._mopidy.on('state:online', $.proxy(function () { this._isConnected = true }), this)\r\n        // this._mopidy.on('state:offline', $.proxy(function () { this._isConnected = false }), this)\r\n    }\r\n\r\n\r\n    static format(milliseconds: number) {\r\n        if (milliseconds === Infinity) {\r\n            return '';\r\n        } else if (milliseconds === 0) {\r\n            return '0:00';\r\n        }\r\n\r\n        let seconds = Math.floor(milliseconds / 1000);\r\n        const minutes = Math.floor(seconds / 60);\r\n        seconds = seconds % 60;\r\n\r\n        let secondString = seconds < 10 ? '0' + seconds : seconds.toString();\r\n        return minutes + ':' + secondString;\r\n    }\r\n\r\n    timerCallback(position: number, duration: number) {\r\n        this._update(position);\r\n        if (this._isSyncScheduled && this._isConnected) {\r\n            this._doSync(position, duration)\r\n        }\r\n    }\r\n\r\n    _update(position: number) {\r\n        switch (this.syncState) {\r\n            case SYNC_STATE.NOT_SYNCED:\r\n                // Waiting for Mopidy to provide a target position.\r\n                this.positionNode.nodeValue = '(wait)'\r\n                break\r\n            case SYNC_STATE.SYNCING:\r\n                // Busy seeking to new target position.\r\n                this.positionNode.nodeValue = '(sync)'\r\n                break\r\n            case SYNC_STATE.SYNCED:\r\n                this._previousSyncPosition = position\r\n                this.positionNode.nodeValue = SyncedProgressTimer.format(position)\r\n                //todo: document.getElementById('trackslider').val(position).slider('refresh')\r\n                break\r\n        }\r\n    }\r\n\r\n    _scheduleSync(milliseconds: number) {\r\n        // Use an anonymous callback to set a boolean value, which should be faster to\r\n        // check in the timeout callback than doing another function call.\r\n        clearTimeout(this._scheduleID)\r\n        this._isSyncScheduled = false\r\n        if (milliseconds >= 0) {\r\n            this._scheduleID = setTimeout(() => {\r\n                this._isSyncScheduled = true;\r\n            }, milliseconds);\r\n        }\r\n    }\r\n\r\n    _doSync(position: number, duration: number) {\r\n        // let ready = !(duration === Infinity && position === 0);  // Timer has been properly initialized.\r\n        // if (!ready) {\r\n        //     // Don't try to sync if progress timer has not been initialized yet.\r\n        //     return;\r\n        // }\r\n        //\r\n        // this._scheduleSync(-1); // Ensure that only one sync process is active at a time.\r\n        //\r\n        // let _this = this;\r\n        // _this.commands.core.playback.getTimePosition().then(function (targetPosition: number) {\r\n        //     if (_this.syncState === SYNC_STATE.NOT_SYNCED) {\r\n        //         _this.syncState = SYNC_STATE.SYNCING;\r\n        //     }\r\n        //     if (Math.abs(targetPosition - position) <= 500) {\r\n        //         // Less than 500ms == in sync.\r\n        //         _this._syncAttemptsRemaining = Math.max(_this._syncAttemptsRemaining - 1, 0);\r\n        //         if (_this._syncAttemptsRemaining < _this._maxAttempts - 1 && _this._previousSyncPosition !== targetPosition) {\r\n        //             // Need at least two consecutive syncs to know that Mopidy\r\n        //             // is progressing playback and we are in sync.\r\n        //             _this.syncState = SYNC_STATE.SYNCED;\r\n        //         }\r\n        //         _this._previousSyncPosition = targetPosition;\r\n        //         // Step back exponentially while increasing number of callbacks.\r\n        //         _this._scheduleSync(delay_exponential(0.25, 2, _this._maxAttempts - _this._syncAttemptsRemaining) * 1000);\r\n        //     } else {\r\n        //         // Drift is too large, re-sync with Mopidy.\r\n        //         _this.syncState = SYNC_STATE.SYNCING;\r\n        //         _this._syncAttemptsRemaining = _this._maxAttempts;\r\n        //         _this._previousSyncPosition = null;\r\n        //         _this._scheduleSync(1000);\r\n        //         _this._progressTimer.set(targetPosition);\r\n        //     }\r\n        // });\r\n    }\r\n\r\n    set(position: number, duration: number = undefined) {\r\n        this.syncState = SYNC_STATE.NOT_SYNCED;\r\n        this._syncAttemptsRemaining = this._maxAttempts;\r\n        // Workaround for https://github.com/adamcik/media-progress-timer/issues/3\r\n        // This causes the timer to die unexpectedly if the position exceeds\r\n        // the duration slightly.\r\n        if (this._duration && this._duration < position) {\r\n            position = this._duration - 1\r\n        }\r\n        if (arguments.length === 1) {\r\n            this._progressTimer.set(position)\r\n        } else {\r\n            this._duration = duration\r\n            this._progressTimer.set(position, duration)\r\n            this.durationNode.nodeValue = SyncedProgressTimer.format(duration)\r\n        }\r\n\r\n        this.updatePosition(position);\r\n        //todo document.getElementById('trackslider').val(position).slider('refresh')\r\n\r\n        return this\r\n    }\r\n\r\n    start() {\r\n        this.syncState = SYNC_STATE.NOT_SYNCED\r\n        this._scheduleSync(0)\r\n        this._progressTimer.start()\r\n        return this\r\n    }\r\n\r\n    stop() {\r\n        this._progressTimer.stop()\r\n        this._scheduleSync(-1)\r\n        if (this.syncState !== SYNC_STATE.SYNCED && this._previousSyncPosition) {\r\n            // Timer was busy trying to sync when it was stopped, fallback to displaying the last synced position on screen.\r\n            this.positionNode.nodeValue = SyncedProgressTimer.format(this._previousSyncPosition)\r\n        }\r\n        return this\r\n    }\r\n\r\n    reset() {\r\n        this.stop()\r\n        this.set(0, Infinity)\r\n\r\n        return this\r\n    }\r\n\r\n    updatePosition(position: number) {\r\n        if (!(this._duration === Infinity && position === 0)) {\r\n            this.positionNode.nodeValue = SyncedProgressTimer.format(position)\r\n        } else {\r\n            this.positionNode.nodeValue = ''\r\n        }\r\n    }\r\n}","import models, {Mopidy} from \"../js/mopidy\";\r\nimport {SyncedProgressTimer} from \"./synced_timer\";\r\nimport {ViewModel} from \"./model\";\r\nimport {EboPlayerDataType, View} from \"./views/view\";\r\nimport {Controller} from \"./controller\";\r\n\r\nimport {DeepReadonly} from \"./modelTypes\";\r\n\r\nexport class State {\r\n    mopidy: Mopidy;\r\n    syncedProgressTimer: SyncedProgressTimer;\r\n\r\n    // values for controls\r\n    play: boolean = false;\r\n    random: boolean = false;\r\n    repeat: boolean = false;\r\n    consume: boolean = false;\r\n    single: boolean = false;\r\n    mute: boolean = false;\r\n    positionChanging: boolean = false;\r\n    popupData = {};  // TODO: Refactor into one shared cache,\r\n    songlength: number = 0;\r\n\r\n    streamUris = {}; //TODO: EBO added this to make gui.ts compile.\r\n\r\n    // array of cached playlists (not only user-playlists, also search, artist, album-playlists)\r\n    playlists = {};  // TODO: Refactor into one shared cache,\r\n    customTracklists =  [];  // TODO: Refactor into one shared cache,\r\n\r\n    private readonly model: ViewModel;\r\n    private readonly controller: Controller;\r\n\r\n    constructor(mopidy: Mopidy, syncedProgressTimer: SyncedProgressTimer, model: ViewModel, controller: Controller) {\r\n        this.mopidy = mopidy;\r\n        this.syncedProgressTimer = syncedProgressTimer;\r\n        this.model = model;\r\n        this.controller = controller;\r\n    }\r\n    views: View[] = [];\r\n    getModel = (): DeepReadonly<ViewModel> => this.model;\r\n    getController = () => this.controller;\r\n\r\n    addViews(...views:View[]) {\r\n        this.views.push(...views);\r\n        views.forEach(v => v.bindRecursive());\r\n    }\r\n\r\n    async getRequiredData()  {\r\n        let requiredData = new Set<EboPlayerDataType>();\r\n        this.views.forEach(v => {\r\n            v.getRequiredDataTypesRecursive().forEach((dataType: EboPlayerDataType) => requiredData.add(dataType));\r\n        });\r\n        this.controller.getRequiredDataTypesRecursive().forEach((dataType => requiredData.add(dataType)));\r\n\r\n        for (const dataType of requiredData) {\r\n            await this.controller.mopidyProxy.fetchRequiredData(dataType);\r\n            await this.controller.webProxy.fetchRequiredData(dataType);\r\n        }\r\n\r\n        await this.controller.fetchAllAlbums();\r\n        this.controller.localStorageProxy.loadCurrentBrowseFilter();\r\n        this.controller.localStorageProxy.loadBrowseFiltersBreadCrumbs();\r\n        this.controller.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n            this.controller.filterBrowseResults();\r\n        });\r\n    }\r\n}\r\n\r\nlet state: State = undefined; //todo: assuming here that all calls to getState() will receive a valid state object.\r\n\r\nexport function setState(newState: State) { state = newState; }\r\nconst getState = () => state;\r\n\r\nexport default getState;","export interface WithId<T> {\r\n    id: T;\r\n}\r\n\r\nexport class IdStack<T extends WithId<Tid>, Tid> extends Array<T> {\r\n    resetTo(id: number) {\r\n        let index = this.findIndex((breadCrumb, index, obj) => {\r\n            return breadCrumb.id == id;\r\n        });\r\n        this.splice(index + 1);\r\n    }\r\n\r\n    getLast(): WithId<Tid> | undefined {\r\n        return this[this.length - 1];\r\n    }\r\n\r\n    get(id: number): WithId<Tid> | undefined {\r\n        return this.find(crumb => crumb.id == id);\r\n    }\r\n}","import {IdStack, WithId} from \"./util/idStack\";\r\n\r\nexport class BreadCrumb<Tdata, TName extends string> implements WithId<number>{\r\n    id: number;\r\n    label: string;\r\n    data: Tdata;\r\n    type: TName\r\n\r\n    private static nextId = 1;\r\n\r\n\r\n    constructor(label: string, value: Tdata, type: TName) {\r\n        this.label = label;\r\n        this.data = value;\r\n        this.id = BreadCrumb.nextId++;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport class BreadCrumbStack<TName extends string, Tbreadcrumb extends BreadCrumb<any, TName> & WithId<number>,> extends IdStack<Tbreadcrumb, number> {}\r\n","import models from \"../js/mopidy\";\r\nimport {BreadCrumb} from \"./breadCrumb\";\r\nimport Ref = models.Ref;\r\nimport Image = models.Image;\r\n\r\ndeclare const __brand: unique symbol;\r\n\r\nexport type Branded<T, Brand> = T & {__brand: Brand};\r\nexport type AlbumUri = Branded<string, \"AlbumUri\">;\r\nexport type TrackUri = Branded<string, \"TrackUri\">;\r\nexport type RadioUri = Branded<string, \"RadioUri\">;\r\nexport type PlaylistUri = Branded<string, \"PlaylistUri\">;\r\nexport type GenreUri = Branded<string, \"GenreUri\">;\r\nexport type ArtistUri = Branded<string, \"ArtistUri\">;\r\nexport type ImageUri = Branded<string, \"ImageUri\">;\r\nexport type StreamUri = Branded<string, \"StreamUri\">;\r\nexport type LibraryUri = Branded<string, \"LibraryUri\">;\r\nexport type BrowseUri = Branded<string, \"BrowseUri\">;\r\n\r\nexport type AllUris = AlbumUri | TrackUri | RadioUri | PlaylistUri | GenreUri | ArtistUri | ImageUri | StreamUri | LibraryUri | BrowseUri;\r\n\r\nexport enum ItemType { None, File, Stream, Album}\r\n\r\nexport type FilterBreadCrumbTypeName = \"home\" | \"browseFilter\" | \"ref\";\r\n\r\nexport class BrowseFilterBreadCrumb<T> extends BreadCrumb<T, FilterBreadCrumbTypeName> {\r\n    constructor(label: string, filter: T, type: FilterBreadCrumbTypeName) {\r\n        super(label, filter, type);\r\n    }\r\n}\r\n\r\nexport type Uri = string;\r\nexport class BreadCrumbHome extends BrowseFilterBreadCrumb<null> {\r\n    constructor() {\r\n        super(\"Home\", null, \"home\");\r\n    }\r\n}\r\nexport class BreadCrumbBrowseFilter extends BrowseFilterBreadCrumb<BrowseFilter> {\r\n    constructor(label: string, filter: BrowseFilter) {\r\n        super(label, filter, \"browseFilter\");\r\n    }\r\n}\r\nexport class BreadCrumbRef<T extends AllUris> extends BrowseFilterBreadCrumb<Ref<T>> {\r\n    constructor(label: string, ref: Ref<T>) {\r\n        super(label, ref, \"ref\");\r\n    }\r\n}\r\nexport type FilterBreadCrumb = BreadCrumbRef<AllUris> | BreadCrumbBrowseFilter | BreadCrumbHome;\r\n\r\nexport function isBreadCrumbForAlbum(breadCrumb: BreadCrumbRef<AllUris>): breadCrumb is BreadCrumbRef<AlbumUri> {\r\n    return breadCrumb.data.type == \"album\";\r\n}\r\nexport function isBreadCrumbForArtist(breadCrumb: BreadCrumbRef<AllUris>): breadCrumb is BreadCrumbRef<ArtistUri> {\r\n    return breadCrumb.data.type == \"artist\";\r\n}\r\n\r\nexport type ImageLookup = {[string: string]: Image[]} //todo replace with [uri:string] ?\r\n\r\nexport class BrowseFilter {\r\n    searchText: string;\r\n    album: boolean;\r\n    track: boolean;\r\n    radio: boolean;\r\n    artist: boolean;\r\n    playlist: boolean;\r\n    genre: boolean;\r\n\r\n    constructor() {\r\n        this.searchText = \"\";\r\n        this.track = false;\r\n        this.artist = false;\r\n        this.genre = false;\r\n        this.radio = false;\r\n        this.playlist = false;\r\n        this.album = false;\r\n    }\r\n\r\n    isNoTypeSelected(): boolean {\r\n        return !(this.album || this.track || this.radio || this.artist || this.playlist || this.genre);\r\n    }\r\n\r\n    getSelectedFilters() {\r\n        return [\"album\", \"track\", \"radio\", \"artist\", \"playlist\", \"genre\"].filter(key => this[key] == true);\r\n    }\r\n}\r\n\r\nexport interface AlbumModel {\r\n    type: ItemType.Album;\r\n    tracks: string[];\r\n    albumInfo: models.Album;\r\n    imageUrl: string;\r\n}\r\n\r\nexport interface FileTrackModel {\r\n    type: ItemType.File;\r\n    track: models.Track;\r\n    title: string,\r\n    composer?: string,\r\n    performer: string,\r\n    songlenght: number,\r\n}\r\n\r\nexport interface StreamTrackModel {\r\n    type: ItemType.Stream;\r\n    track: models.Track;\r\n    name: string,\r\n    infoLines: string[],\r\n    imageUrl: string,\r\n}\r\n\r\nexport interface NoneTrackModel {\r\n    type: ItemType.None;\r\n}\r\n\r\nexport const TrackNone = {type: ItemType.None} as NoneTrackModel;\r\n\r\nexport interface ExpandedFileTrackModel {\r\n    track: FileTrackModel,\r\n    album: AlbumModel,\r\n}\r\n\r\nexport interface AlbumMetaData {\r\n    showTrackNumbers: boolean,\r\n    albumTitle: string,\r\n    imageFile: string\r\n}\r\n\r\nexport interface CachedAlbumMetaData {\r\n    meta?: AlbumMetaData,\r\n}\r\n\r\nexport interface ExpandedAlbumModel {\r\n    album: AlbumModel,\r\n    tracks: FileTrackModel[],\r\n    meta: AlbumMetaData,\r\n}\r\n\r\nexport interface ExpandedStreamModel {\r\n    stream: StreamTrackModel,\r\n    historyLines: string[][];\r\n}\r\n\r\nexport function isInstanceOfExpandedStreamModel(model: ExpandedAlbumModel | ExpandedStreamModel | ExpandedFileTrackModel): model is ExpandedStreamModel {\r\n    return 'stream' in model;\r\n}\r\n\r\nexport type TrackModel = NoneTrackModel | FileTrackModel | StreamTrackModel;\r\nexport type DeepReadonly<T> = T extends Function ? T :\r\n    T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } :\r\n        T;\r\n\r\nexport enum ConnectionState {Offline, Online}\r\n\r\nexport enum MessageType { None, Info, Warning, Error}\r\n\r\nexport interface Message {\r\n    type: MessageType,\r\n    message: string\r\n}\r\n\r\nexport interface PlaybackModesState {\r\n    repeat: boolean,\r\n    random: boolean,\r\n    consume: boolean,\r\n    single: boolean\r\n}\r\n\r\nexport enum PlayState {\r\n    stopped = \"stopped\",\r\n    playing = \"playing\",\r\n    paused = \"paused\",\r\n    unknown = \"unknown\"\r\n}\r\n\r\nexport interface HistoryRef {\r\n    __model__: string,\r\n    name: string;\r\n    type: string;\r\n    uri: string;\r\n}\r\n\r\nexport interface HistoryLine {\r\n    timestamp: number;\r\n    ref: HistoryRef;\r\n}\r\n\r\nexport type LibraryItem = models.Track[];\r\nexport type LibraryDict = { [index: string]: LibraryItem };\r\n\r\nexport const NoStreamTitles: StreamTitles = {uri: \"\", active_titles: []};\r\n\r\nexport interface StreamTitles {\r\n    uri: string;\r\n    active_titles: string[]\r\n}\r\n\r\nexport enum AlbumDataType {\r\n    None,\r\n    Loading,\r\n    Loaded,\r\n    StreamLinesLoaded\r\n}\r\n\r\ninterface AlbumDataNone {\r\n    type: AlbumDataType.None;\r\n}\r\n\r\ninterface AlbumDataLoading {\r\n    type: AlbumDataType.Loading;\r\n}\r\n\r\nexport interface AlbumDataLoaded {\r\n    type: AlbumDataType.Loaded;\r\n    album: AlbumModel;\r\n}\r\n\r\nexport interface AlbumStreamLinesLoaded {\r\n    type: AlbumDataType.StreamLinesLoaded;\r\n    albumTrack: models.Track;\r\n}\r\n\r\nexport const AlbumNone: AlbumDataNone = {\r\n    type: AlbumDataType.None\r\n}\r\n\r\nexport type AlbumData = AlbumDataLoaded | AlbumDataNone | AlbumDataLoading | AlbumStreamLinesLoaded;\r\n\r\nexport enum Views {\r\n    NowPlaying = \"#NowPlaying\",\r\n    Browse = \"#Browse\",\r\n    Album = \"#Album\"\r\n}\r\n","import {AllUris} from \"./modelTypes\";\r\n\r\nexport enum EboplayerEvents {\r\n    activeStreamLinesChanged =      \"eboplayer.activeStreamLinesChanged\",\r\n    addAlbumClicked =               \"eboplayer.addAlbumClicked\",\r\n    addTrackClicked =               \"eboplayer.addTrackClicked\",\r\n    albumToViewChanged =            \"eboplayer.albumToViewChanged\",\r\n    breadCrumbClick =               \"eboplayer.breadCrumbClick\",\r\n    breadCrumbsChanged =            \"eboplayer.breadCrumbsChanged\",\r\n    browseFilterChanged =           \"eboplayer.browseFilterChanged\",\r\n    browseResultClick =             \"eboplayer.browseResultClick\",\r\n    browseResultDblClick =          \"eboplayer.browseResultDblClick\",\r\n    buttonBarAlbumImgClicked =      \"eboplayer.buttonBarAlbumImgClicked\",\r\n    changingVolume =                \"eboplayer.changingVolume\",\r\n    connectionChanged =             \"eboplayer.connectionChanged\",\r\n    currentImageSet =               \"eboplayer.currentImageSet\",\r\n    currentRefsLoaded =             \"eboplayer.currentRefsLoaded\",\r\n    currentTrackChanged =           \"eboplayer.currentTrackChanged\",\r\n    historyChanged =                \"eboplayer.historyChanged\",\r\n    longPress =                     \"eboplayer.longPress\",\r\n    messageChanged =                \"eboplayer.messageChanged\",\r\n    pausePressed =                  \"eboplayer.pausePressed\",\r\n    playListClicked =               \"eboplayer.playListClicked\",\r\n    playPressed =                   \"eboplayer.playPressed\",\r\n    playStateChanged =              \"eboplayer.playbackStateChanged\",\r\n    playTrackClicked =              \"eboplayer.playTrackClicked\",\r\n    refsFiltered =                  \"eboplayer.refsFiltered\",\r\n    selectedTrackChanged =          \"eboplayer.selectedTrackChanged\",\r\n    stopPressed =                   \"eboplayer.stopPressed\",\r\n    trackListChanged =              \"eboplayer.trackListChanged\",\r\n    viewChanged =                   \"eboplayer.viewChanged\",\r\n    volumeChanged =                 \"eboplayer.volumeChanged\",\r\n}\r\n\r\nexport class EboplayerEvent<T extends EboEventArgs> extends CustomEvent<T> {\r\n    constructor(event: EboplayerEvents, detail?: T) {\r\n        super(event, {detail, bubbles: true, composed: true, cancelable: true});\r\n    }\r\n}\r\n\r\nexport interface EboEventArgs {}\r\nexport interface UriArgs extends EboEventArgs {\r\n    \"uri\": string\r\n}\r\nexport interface BreadcrumbArgs extends EboEventArgs {\r\n    \"breadcrumbId\": number\r\n}\r\nexport interface BrowseResultArgs extends EboEventArgs {\r\n    \"label\": string,\r\n    \"uri\": AllUris,\r\n    \"type\": string,\r\n}","import models from \"../js/mopidy\";\r\nimport {Refs, SearchResult, SearchResults} from \"./refs\";\r\nimport {AlbumMetaData, AlbumModel, AlbumUri, BreadCrumbHome, BrowseFilter, CachedAlbumMetaData, ConnectionState, FileTrackModel, FilterBreadCrumb, FilterBreadCrumbTypeName, HistoryLine, ItemType, Message, MessageType, NoneTrackModel, PlaybackModesState, PlayState, StreamTitles, StreamTrackModel, TrackModel, Views} from \"./modelTypes\";\r\nimport {BreadCrumb, BreadCrumbStack} from \"./breadCrumb\";\r\nimport TlTrack = models.TlTrack;\r\nimport {EboplayerEvents} from \"./events\";\r\nimport {WithId} from \"./util/idStack\";\r\n\r\n\r\n\r\nexport interface ViewModel extends EventTarget {\r\n    getConnectionState: () => ConnectionState;\r\n    getCurrentTrack: () => string;\r\n    getSelectedTrack: () => string | undefined;\r\n    getCurrentMessage: () => Message;\r\n    getVolume: () => number;\r\n    getPlayState: () => PlayState;\r\n    getActiveStreamLines: () => StreamTitles;\r\n    getHistory: () => HistoryLine[];\r\n    getCachedInfo(uri: string): (FileTrackModel | StreamTrackModel | AlbumModel);\r\n    getCurrentBrowseFilter: () => BrowseFilter;\r\n    getCurrentSearchResults(): SearchResults;\r\n    getTrackList(): TlTrack[];\r\n    getBreadCrumbs(): BrowseFilterBreadCrumbStack;\r\n    getView(): Views;\r\n    getAlbumToView(): AlbumUri;\r\n}\r\n\r\nexport class BrowseFilterBreadCrumbStack extends BreadCrumbStack<FilterBreadCrumbTypeName, FilterBreadCrumb>{}\r\n\r\n// Model contains the data to be viewed and informs the view of changes through events.\r\n// Views should not update the model directly. See ViewModel for that.\r\nexport class Model extends EventTarget implements ViewModel {\r\n    static NoTrack: TrackModel = { type: ItemType.None } as NoneTrackModel;\r\n    currentTrack: string;\r\n    //note that selectedTrack is not part of the mopidy server.\r\n    //don't set selectedTrack to currentTrack unless you want it displayed\r\n    selectedTrack?: string;\r\n    volume: number;\r\n    connectionState: ConnectionState = ConnectionState.Offline;\r\n    currentMessage: Message = {\r\n        type: MessageType.None,\r\n        message: \"\"\r\n    };\r\n\r\n    playbackModesState: PlaybackModesState = {\r\n        repeat: false,\r\n        random: false,\r\n        consume: false,\r\n        single: false\r\n    }\r\n    private playState: PlayState = PlayState.unknown;\r\n    private activeStreamLines: StreamTitles;\r\n    private history: HistoryLine[];\r\n    private trackList: TlTrack[] = [];\r\n    private libraryCache: Map<string, (FileTrackModel | StreamTrackModel | AlbumModel)> = new Map();\r\n    private metaCache: Map<string, CachedAlbumMetaData> = new Map();\r\n    private currentBrowseFilter= new BrowseFilter();\r\n    // private filterBreadCrumbStack: BreadCrumbStack<number> = new BreadCrumbStack<number>();\r\n    private filterBreadCrumbStack: BrowseFilterBreadCrumbStack = new BrowseFilterBreadCrumbStack();\r\n\r\n    private allRefs?: Refs;\r\n    private currentRefs?: Refs;\r\n    private view: Views = Views.NowPlaying;\r\n    private albumToViewUri: AlbumUri;\r\n    // private albumCache: Set<LibraryItem> = new Map();\r\n    private currentImage: string;\r\n\r\n    constructor() {\r\n        super();\r\n        this.initializeBreadcrumbStack();\r\n    }\r\n\r\n    pushBreadCrumb(crumb: FilterBreadCrumb) {\r\n        this.filterBreadCrumbStack.push(crumb);\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n    popBreadCrumb() {\r\n        let crumb = this.filterBreadCrumbStack.pop();\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n        return crumb;\r\n    }\r\n\r\n    getBreadCrumbs = () => this.filterBreadCrumbStack;\r\n\r\n    resetBreadCrumbsTo(id: number) {\r\n        this.filterBreadCrumbStack.resetTo(id);\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n\r\n    private initializeBreadcrumbStack() {\r\n        this.filterBreadCrumbStack.length = 0;\r\n        this.filterBreadCrumbStack.push(new BreadCrumbHome());\r\n    }\r\n\r\n    clearBreadCrumbs() {\r\n        this.initializeBreadcrumbStack();\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n\r\n    setAllRefs(refs: Refs) {\r\n        this.allRefs = refs;\r\n    }\r\n\r\n    getCurrentSearchResults(): SearchResults {\r\n        return this.currentRefs?.getSearchResults() ?? { refs: [], availableRefTypes: new Set()} as SearchResults;\r\n    }\r\n\r\n    getAllRefs = () => this.allRefs;\r\n\r\n    filterCurrentRefs(){\r\n        if(!this.currentRefs)\r\n            return;\r\n        this.currentRefs.browseFilter = this.currentBrowseFilter;\r\n        this.currentRefs.filter();\r\n        this.dispatchEvent(new Event(EboplayerEvents.refsFiltered));\r\n    }\r\n    setConnectionState(state: ConnectionState) {\r\n        this.connectionState  = state;\r\n        if(this.connectionState == ConnectionState.Online)\r\n            this.clearMessage();\r\n        else\r\n            this.setErrorMessage(\"Offline\");\r\n        this.dispatchEvent(new Event(EboplayerEvents.connectionChanged));\r\n    }\r\n\r\n    getConnectionState = () => this.connectionState;\r\n\r\n    getCachedInfo(uri: string): (FileTrackModel | StreamTrackModel  | AlbumModel) {\r\n        return this.libraryCache.get(uri);\r\n    }\r\n\r\n    getCurrentBrowseFilter = () => this.currentBrowseFilter;\r\n    setCurrentBrowseFilter(browseFilter: BrowseFilter) {\r\n        this.currentBrowseFilter = browseFilter;\r\n        this.dispatchEvent(new Event(EboplayerEvents.browseFilterChanged));\r\n    }\r\n\r\n    setBrowseFilterBreadCrumbs(breadCrumbStack: BrowseFilterBreadCrumbStack) {\r\n        this.filterBreadCrumbStack.length = 0;\r\n        this.filterBreadCrumbStack.push(...breadCrumbStack);\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n\r\n    getCurrentTrack(): string {\r\n        return this.currentTrack;\r\n    }\r\n\r\n    setCurrentTrack(track: TrackModel) {\r\n        if(track.type == ItemType.None) {\r\n            this.currentTrack = undefined;\r\n            return;\r\n        }\r\n        this.currentTrack = track.track.uri;\r\n        this.addToLibraryCache(this.currentTrack, track);\r\n        this.dispatchEvent(new Event(EboplayerEvents.currentTrackChanged));\r\n    }\r\n\r\n    getSelectedTrack = () => this.selectedTrack;\r\n\r\n    setSelectedTrack(uri?: string) {\r\n        if(uri == \"\")\r\n            this.selectedTrack = undefined;\r\n        else\r\n            this.selectedTrack = uri;\r\n        this.dispatchEvent(new Event(EboplayerEvents.selectedTrackChanged));\r\n    }\r\n\r\n    setVolume(volume: number) {\r\n        this.volume = volume;\r\n        this.dispatchEvent(new Event(EboplayerEvents.volumeChanged));\r\n    }\r\n\r\n    private setMessage(message: Message) {\r\n        this.currentMessage = message;\r\n        this.dispatchEvent(new Event(EboplayerEvents.messageChanged));\r\n    }\r\n\r\n    getCurrentMessage = () => this.currentMessage;\r\n\r\n    clearMessage() {\r\n        this.setMessage( { type: MessageType.None, message: \"\"});\r\n    }\r\n    setInfoMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Info, message});\r\n    }\r\n    setWarningMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Warning, message});\r\n    }\r\n    setErrorMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Error, message});\r\n    }\r\n\r\n    setPlaybackState(state: PlaybackModesState) {\r\n        this.playbackModesState = {...state};\r\n        this.dispatchEvent(new Event(EboplayerEvents.playStateChanged));\r\n    }\r\n\r\n    getVolume = () => this.volume;\r\n\r\n    getPlayState(): PlayState {\r\n        return this.playState;\r\n    }\r\n\r\n    setPlayState(state: PlayState) {\r\n        this.playState = state;\r\n        this.dispatchEvent(new Event(EboplayerEvents.playStateChanged));\r\n    }\r\n\r\n    setActiveStreamLinesHistory(streamTitles: StreamTitles) {\r\n        if(!streamTitles) //todo: why can this be empty (at PC startup?)\r\n            return;\r\n        streamTitles.active_titles = Object.values<string>(streamTitles.active_titles); //todo: this really is a hack. Can't python return an array, like normal people?\r\n        this.activeStreamLines = streamTitles;\r\n        this.dispatchEvent(new Event(EboplayerEvents.activeStreamLinesChanged));\r\n    }\r\n\r\n    getActiveStreamLines = () => this.activeStreamLines;\r\n\r\n    setHistory(history: HistoryLine[]) {\r\n        this.history = history;\r\n        this.dispatchEvent(new Event(EboplayerEvents.historyChanged));\r\n    }\r\n\r\n    getHistory = () => this.history;\r\n\r\n    setTrackList(trackList: TlTrack[]) {\r\n        this.trackList = trackList;\r\n        this.dispatchEvent(new Event(EboplayerEvents.trackListChanged));\r\n    }\r\n    getTrackList = () => this.trackList;\r\n\r\n    //Doesn't overwrite\r\n    addToLibraryCache(uri: string, item: (FileTrackModel | StreamTrackModel | AlbumModel)) {\r\n        if(!this.libraryCache.has(uri))\r\n            this.libraryCache.set(uri, item);\r\n    }\r\n\r\n    //Doesn't overwrite\r\n    addToMetaCache(albumUri: string, item: AlbumMetaData) {\r\n        if(!this.metaCache.has(albumUri))\r\n            this.metaCache.set(albumUri, {meta: item});\r\n    }\r\n\r\n    getFromMetaCache(albumUri: string): CachedAlbumMetaData | undefined {\r\n        return this.metaCache.get(albumUri);\r\n    }\r\n\r\n    updateLibraryCache(uri: string, item: (FileTrackModel | StreamTrackModel | AlbumModel)) {\r\n        this.libraryCache.set(uri, item);\r\n    }\r\n\r\n    //Overwrites!\r\n    addItemsToLibraryCache(items: (FileTrackModel | StreamTrackModel | AlbumModel)[]) {\r\n        for(let item of items) {\r\n            if(item.type == ItemType.Album)\r\n                this.updateLibraryCache(item.albumInfo.uri, item);\r\n            else\r\n                this.updateLibraryCache(item.track.uri, item);\r\n        }\r\n    }\r\n\r\n    getFromLibraryCache(uri: string): (FileTrackModel | StreamTrackModel | AlbumModel) | undefined {\r\n        return this.libraryCache.get(uri);\r\n    }\r\n\r\n    setCurrentRefs(refs: Refs) {\r\n        this.currentRefs = refs;\r\n        this.dispatchEvent(new Event(EboplayerEvents.currentRefsLoaded));\r\n    }\r\n\r\n    setView(view: Views) {\r\n        this.view = view;\r\n        this.dispatchEvent(new Event(EboplayerEvents.viewChanged));\r\n    }\r\n    getView = () => this.view;\r\n\r\n    setAlbumToView(uri: AlbumUri) {\r\n        this.albumToViewUri = uri;\r\n        this.dispatchEvent(new Event(EboplayerEvents.albumToViewChanged));\r\n    }\r\n    getAlbumToView = () => this.albumToViewUri;\r\n\r\n    setCurrentImage(uri: string) {\r\n        this.currentImage = uri;\r\n        this.dispatchEvent(new Event(EboplayerEvents.currentImageSet));\r\n    }\r\n\r\n    getCurrentImage = () => this.currentImage;\r\n\r\n}\r\n","import {EboPlayerDataType} from \"./view\";\r\n\r\nexport interface Parent<Child> {\r\n    addChildren(...children: Child[]): void;\r\n\r\n    get children(): Child[];\r\n}\r\n\r\nexport interface DataRequester {\r\n    getRequiredDataTypes(): EboPlayerDataType[];\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[];\r\n}\r\n\r\nexport abstract class NestedDataRequester<T extends NestedDataRequester<T>> implements Parent<T>, DataRequester {\r\n    private _children: T[] = [];\r\n\r\n    abstract getRequiredDataTypes(): EboPlayerDataType[];\r\n\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[] {\r\n        return [...this.getRequiredDataTypes(), ...this._children.map(child => child.getRequiredDataTypesRecursive()).flat()];\r\n    }\r\n\r\n    addChildren(...children: T[]) {\r\n        this._children.push(...children);\r\n    }\r\n\r\n    get children(): T[] {\r\n        return this._children;\r\n    }\r\n}","import {NestedDataRequester} from \"./dataRequester\";\r\n\r\nexport enum EboPlayerDataType {\r\n    Volume,\r\n    CurrentTrack,\r\n    PlayState,\r\n    StreamLines,\r\n    TrackList,\r\n}\r\n\r\nexport abstract class View extends NestedDataRequester<View> {\r\n    abstract bind(): void;\r\n    static getSubId(parentId: string, subId: string) {\r\n        return document.getElementById(`${parentId}.${subId}`);\r\n    }\r\n\r\n    bindRecursive() {\r\n        this.children.forEach(child => child.bindRecursive());\r\n        this.bind();\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {MessageType} from \"../modelTypes\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\nexport class HeaderView extends View {\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.messageChanged, () => {\r\n            this.onMessageChanged();\r\n        });\r\n    }\r\n\r\n    private onMessageChanged() {\r\n        let msg = getState().getModel().getCurrentMessage();\r\n        let headerSpan = document.getElementById(\"contentHeadline\");\r\n        headerSpan.innerText = msg.message;\r\n        switch (msg.type) {\r\n            case MessageType.Error:\r\n                headerSpan.classList.add(\"warning\");\r\n                break;\r\n            default:\r\n                headerSpan.classList.remove(\"warning\", \"error\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [];\r\n    }\r\n}","// import * as controls from \"./controls\";\r\nimport getState from \"./playerState\";\r\nimport models from \"../js/mopidy\";\r\nimport TlTrack = models.TlTrack;\r\n\r\n// interface ArtistInfo {\r\n//     name: string;\r\n//     uri: string;\r\n// }\r\n//\r\n// interface AlbumInfo {\r\n//     name: string;\r\n//     uri: string;\r\n// }\r\n//\r\n// interface TrackInfo {\r\n//     name: string;\r\n//     artists: ArtistInfo[];\r\n//     length: number;\r\n//     uri: string;\r\n//     album: AlbumInfo;\r\n// }\r\n\r\ninterface StreamInfo {\r\n    tlid: number;\r\n    track: TlTrack;\r\n    stream: string;\r\n}\r\n\r\n\r\n// constants\r\nexport const STREAMS_PLAYLIST_NAME = '[Radio Streams]'; //todo: put in config of...see todo.txt\r\nexport const STREAMS_PLAYLIST_SCHEME = 'm3u';\r\nexport const HOSTNAME = document.body.dataset.hostname;\r\nexport const ARTIST_TABLE = '#artiststable';\r\nexport const ALBUM_TABLE = '#albumstable';\r\nexport const BROWSE_TABLE = '#browsetable';\r\nexport const PLAYLIST_TABLE = '#playlisttracks';\r\nexport const CURRENT_PLAYLIST_TABLE = '#currenttable';\r\nexport const SEARCH_ALL_TABLE = '#allresulttable';\r\nexport const SEARCH_ALBUM_TABLE = '#albumresulttable';\r\nexport const SEARCH_ARTIST_TABLE = '#artistresulttable';\r\nexport const SEARCH_TRACK_TABLE = '#trackresulttable';\r\n\r\nconst URI_SCHEME = 'mbw';\r\n\r\nexport enum TRACK_ACTIONS {\r\n    UNDEFINED = -1,\r\n    PLAY_NOW = 0,\r\n    PLAY_NEXT = 1,\r\n    ADD_THIS_BOTTOM = 2,\r\n    ADD_ALL_BOTTOM = 3,\r\n    PLAY_ALL = 4,\r\n    DYNAMIC = 5,\r\n    INSERT_AT_INDEX = 6,\r\n}\r\n\r\n// the first part of Mopidy extensions which serve radio streams\r\nlet radioExtensionsList = ['somafm', 'tunein', 'dirble', 'audioaddict']\r\n\r\nlet uriClassList = [\r\n    ['spotify', 'fa-spotify'],\r\n    ['spotifytunigo', 'fa-spotify'],\r\n    ['spotifyweb', 'fa-spotify'],\r\n    ['local', 'fa-file-sound-o'],\r\n    ['file', 'fa-file-sound-o'],\r\n    ['m3u', 'fa-file-sound-o'],\r\n    ['podcast', 'fa-rss-square'],\r\n    ['podcast+file', 'fa-rss-square'],\r\n    ['podcast+itunes', 'fa-apple'],\r\n    ['dirble', 'fa-microphone'],\r\n    ['tunein', 'fa-headphones'],\r\n    ['soundcloud', 'fa-soundcloud'],\r\n    ['sc', 'fa-soundcloud'],\r\n    ['gmusic', 'fa-google'],\r\n    ['internetarchive', 'fa-university'],\r\n    ['somafm', 'fa-flask'],\r\n    ['youtube', 'fa-youtube'],\r\n    ['yt', 'fa-youtube'],\r\n    ['audioaddict', 'fa-bullhorn'],\r\n    ['subsonic', 'fa-folder-open']\r\n]\r\n\r\n// TODO: It should be possible to retrieve a user-friendly name for a given Mopidy scheme dynamically by\r\n//       calling mopidy.library.browse() on the root dir:\r\n//       1. each backend contained in the result will have a 'name' attribute that can be shown as-is in the UI.\r\n//       2. the URI prefix of the backend result should === mopidy.getUriSchemes(), which can be used for the mapping.\r\n//       3. only backends that cannot be 'browsed' (e.g. youtube) should have a static mapping defined here.\r\nlet uriHumanList = [\r\n    ['spotify', 'Spotify'],\r\n    ['spotifytunigo', 'Spotify browse'],\r\n    ['spotifyweb', 'Spotify browse'],\r\n    ['local', 'Local media'],\r\n    ['m3u', 'Local playlists'],\r\n    ['podcast', 'Podcasts'],\r\n    ['podcast+itunes', 'iTunes Store: Podcasts'],\r\n    ['dirble', 'Dirble'],\r\n    ['tunein', 'TuneIn'],\r\n    ['soundcloud', 'SoundCloud'],\r\n    ['gmusic', 'Google Music'],\r\n    ['internetarchive', 'Internet Archive'],\r\n    ['somafm', 'Soma FM'],\r\n    ['youtube', 'YouTube'],\r\n    ['audioaddict', 'AudioAddict'],\r\n    ['subsonic', 'Subsonic']\r\n]\r\n\r\n// List of Mopidy URI schemes that should not be searched directly.\r\n// Also blacklists 'yt' in favour of using the other 'youtube' supported scheme.\r\nexport const searchBlacklist = [\r\n    'file',\r\n    'http',\r\n    'https',\r\n    'mms',\r\n    'rtmp',\r\n    'rtmps',\r\n    'rtsp',\r\n    'yt'\r\n]\r\n\r\n// List of known audio file extensions\r\n// TODO: consider querying GStreamer for supported audio formats - see:https://discuss.mopidy.com/t/supported-codecs-file-formats/473\r\nconst VALID_AUDIO_EXT = [\r\n    'aa', 'aax',  // Audible.com\r\n    'aac',  // Advanced Audio Coding format\r\n    'aiff',  // Apple\r\n    'au',  // Sun Microsystems\r\n    'flac',  // Free Lossless Audio Codec\r\n    'gsm',\r\n    'iklax',\r\n    'ivs',\r\n    'm4a',\r\n    'm4b',\r\n    'm4p',\r\n    'mp3',\r\n    'mpc',  // Musepack\r\n    'ogg', 'oga', 'mogg',  // Ogg-Vorbis\r\n    'opus',  // Internet Engineering Task Force (IETF)\r\n    'ra', 'rm',  // RealAudio\r\n    'raw',\r\n    'tta',  // True Audio\r\n    'vox',\r\n    'wav',\r\n    'wma',  // Microsoft\r\n    'wv',\r\n    'webm'  // HTML5 video\r\n]\r\n\r\nfunction scrollToTop () {\r\n    //todo\r\n    // $('body,html').animate({\r\n    //     scrollTop: 0\r\n    // }, 250)\r\n}\r\n\r\nexport function scrollToTracklist () {\r\n    //todo\r\n    // let divtop = $('#playlisttracksdiv').offset().top - 120\r\n    // $('body,html').animate({\r\n    //     scrollTop: divtop\r\n    // }, 250)\r\n}\r\n\r\n// A hack to find the name of the first artist of a playlist. this is not yet returned by mopidy\r\n// does not work wel with multiple artists of course\r\nexport function getArtist (pl) {\r\n    for (let i = 0; i < pl.length; i++) {\r\n        for (let j = 0; j < pl[i].artists.length; j++) {\r\n            if (pl[i].artists[j].name !== '') {\r\n                return pl[i].artists[j].name\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// A hack to find the first album of a playlist. this is not yet returned by mopidy\r\nexport function getAlbum (pl) {\r\n    for (let i = 0; i < pl.length; i++) {\r\n        if (pl[i].album.name !== '') {\r\n            return pl[i].album.name\r\n        }\r\n    }\r\n}\r\n\r\nexport function artistsToString (artists, max = 3) {\r\n    let result = '';\r\n    if (artists && artists.length > 0) {\r\n        for (let i = 0; i < artists.length && i < max; i++) {\r\n            if (artists[i].name) {\r\n                if (i > 0) {\r\n                    result += ', ';\r\n                }\r\n                result += artists[i].name;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/** ******************************************************\r\n * break up results and put them in album tables\r\n *********************************************************/\r\nexport function albumTracksToTable (pl, target, uri) {\r\n    let track, previousTrack, nextTrack;\r\n    let html = '';\r\n    document.querySelector(target).innerHTML = \"\";\r\n    document.querySelector(target).attr('data', uri);\r\n    for (let i = 0; i < pl.length; i++) {\r\n        previousTrack = track || undefined;\r\n        nextTrack = i < pl.length - 1 ? pl[i + 1] : undefined;\r\n        track = pl[i];\r\n        getState().popupData[track.uri] = track;\r\n        html += renderSongLi(previousTrack, track, nextTrack, uri, '', target, i, pl.length);\r\n    }\r\n    document.querySelector(target).append(html);\r\n    // updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction());\r\n}\r\n\r\nexport function renderSongLi (previousTrack, track, nextTrack, uri, tlid, target, currentIndex, listLength) {\r\n    let tlidParameter = '';\r\n    let onClick = '';\r\n    let html = '';\r\n    track.name = validateTrackName(track, currentIndex);\r\n    // Streams\r\n    if (track.length === -1) {\r\n        html += '<li class=\"albumli\"><a href=\"#\"><h1><i class=\"' + getMediaClass(track) + '\"></i> ' + track.name + ' [Stream]</h1></a></li>';\r\n        return html;\r\n    }\r\n\r\n    if (target === CURRENT_PLAYLIST_TABLE && typeof tlid === 'number' && tlid >= 0) {  // Current queue: Show popup menu icon. onClick plays track.\r\n        tlidParameter = '\\',\\'' + tlid;\r\n        onClick = 'return controls.playQueueTrack(' + tlid + ');';\r\n    } else {  // All other tracklist: Show default action icon. onClick performs default action\r\n        onClick = 'return controls.playTracks(\\'\\', mopidy, \\'' + track.uri + '\\', \\'' + uri + '\\');';\r\n    }\r\n\r\n    html += '<li class=\"song albumli\" id=\"' + getUniqueId(target, track.uri) + '\" tlid=\"' + tlid + '\">';\r\n    if (isPlayable(track)) {\r\n        // Show popup icon for audio files or 'tracks' of other scheme types\r\n        html += '<a href=\"#\" class=\"moreBtn\" onclick=\"return popupTracks(event, \\'' + uri + '\\',\\'' + track.uri + tlidParameter + '\\');\">' +\r\n        '<i class=\"fa fa-play-circle-o\"></i></a>';\r\n    }\r\n    html += '<a href=\"#\" onclick=\"' + onClick + '\"><h1><i class=\"' + getMediaClass(track) + '\"></i> ' + track.name + '</h1>';\r\n\r\n    if (listLength === 1 || (!hasSameAlbum(previousTrack, track) && !hasSameAlbum(track, nextTrack))) {\r\n        html += renderSongLiAlbumInfo(track);\r\n    }\r\n    html += '</a></li>';\r\n    return html;\r\n}\r\n\r\n/* Tracklist renderer for track artist and album name. */\r\nexport function renderSongLiAlbumInfo (track, target: string = undefined) {\r\n    let html = renderSongLiTrackArtists(track);\r\n    if (track.album && track.album.name) {\r\n        html += ' - <em>' + track.album.name + '</em></p>';\r\n    }\r\n    if (typeof target !== 'undefined' && target.length > 0) {\r\n        target = getUniqueId(target, track.uri, true);\r\n        document.querySelector(target).querySelectorAll('a')[1].append(html);\r\n    }\r\n    return html;\r\n}\r\n\r\n/* Tracklist renderer for track artist information. */\r\nfunction renderSongLiTrackArtists (track) {\r\n    let html = ''\r\n    if (track.artists) {\r\n        for (let i = 0; i < track.artists.length; i++) {\r\n            html += track.artists[i].name\r\n            html += (i === track.artists.length - 1) ? '' : ' / '\r\n            // Stop after 3\r\n            if (i > 2) {\r\n                html += '...'\r\n                break\r\n            }\r\n        }\r\n    }\r\n    return html\r\n}\r\n\r\n/* Tracklist renderer to insert dividers between albums. */\r\nexport function renderSongLiDivider (previousTrack, track, nextTrack, target) {\r\n    // let html = ''\r\n    // let imageID\r\n    // // Render differently if part of an album.\r\n    // if (!hasSameAlbum(previousTrack, track) && hasSameAlbum(track, nextTrack)) {\r\n    //     // Large divider with album cover.\r\n    //     let showAlbum = '';\r\n    //     if (typeof track.album.uri !== 'undefined') {\r\n    //         showAlbum = 'onclick=\"return library.showAlbum(\\'' + track.album.uri + '\\', mopidy);\"'\r\n    //     }\r\n    //     html +=\r\n    //         '<li class=\"albumdivider\"><a href=\"#\" ' + showAlbum + '>' +\r\n    //         '<img id=\"' + getUniqueId(target + '-cover', track.uri) + '\" class=\"artistcover\" width=\"30\" height=\"30\"/>' +\r\n    //         '<h1>' + track.album.name + '</h1><p>' +\r\n    //         renderSongLiTrackArtists(track) + '</p></a></li>'\r\n    //     // The element ID to populate with an album cover.\r\n    //     imageID = getUniqueId(target + '-cover', track.uri, true)\r\n    // } else if (previousTrack && !hasSameAlbum(previousTrack, track)) {\r\n    //     // Small divider\r\n    //     html += '<li class=\"smalldivider\"> &nbsp;</li>'\r\n    // }\r\n    // if (html.length > 0 && typeof target !== 'undefined' && target.length > 0) {\r\n    //     target = getUniqueId(target, track.uri, true)\r\n    //     document.querySelector(target).before(html);\r\n    // }\r\n    // return [html, imageID];\r\n}\r\n\r\nexport function renderSongLiBackButton (results, target, onClick, optional = undefined) {\r\n    if (onClick && onClick.length > 0) {\r\n        if (!results || results.length === 0) {\r\n            document.querySelector(target).innerHTML= \"\";\r\n            document.querySelector(target).append(\r\n                '<li class=\"song albumli\"><a href=\"#\" onclick=\"' + onClick + '\"><h1><i></i>No tracks found...</h1></a></li>'\r\n            );\r\n        }\r\n        let opt = '';\r\n        if (optional) {\r\n            opt = ' backnav-optional';\r\n        }\r\n        document.querySelector(target).prepend(\r\n            '<li class=\"backnav' + opt + '\"><a href=\"#\" onclick=\"' + onClick + '\"><h1><i class=\"fa fa-arrow-circle-left\"></i> Back</h1></a></li>'\r\n        );\r\n    }\r\n}\r\n\r\nexport function hasSameAlbum (track1, track2) {\r\n    // 'true' if album for each track exists and has the same name\r\n    let name1 = track1 ? (track1.album ? track1.album.name : undefined) : undefined\r\n    let name2 = track2 ? (track2.album ? track2.album.name : undefined) : undefined\r\n    return name1 && name2 && (name1 === name2)\r\n}\r\n\r\nfunction validateTrackName (track, trackNumber) {\r\n    // Create name if there is none\r\n    let name = ''\r\n    if (!track.name || track.name === '') {\r\n        name = track.uri.split('/')\r\n        name = decodeURI(name[name.length - 1]) || 'Track ' + String(trackNumber)\r\n    } else {\r\n        name = track.name\r\n    }\r\n    return name\r\n}\r\n\r\nexport function resultsToTables (results, target: string, uri: string = undefined, onClickBack = undefined, backIsOptional = undefined) {\r\n    // document.querySelector(target).innerHTML = \"\";\r\n    // renderSongLiBackButton(results, target, onClickBack, backIsOptional)\r\n    // if (!results || results.length === 0) {\r\n    //     return;\r\n    // }\r\n    // document.querySelector(target).setAttribute('data', uri);\r\n    //\r\n    // let track, previousTrack, nextTrack, tlid;\r\n    // let html = '';\r\n    // let requiredImages = {};\r\n    //\r\n    // // Break into albums and put in tables\r\n    // for (let i = 0; i < results.length; i++) {\r\n    //     previousTrack = track || undefined;\r\n    //     nextTrack = i < results.length - 1 ? results[i + 1] : undefined;\r\n    //     track = results[i];\r\n    //     if (track) {\r\n    //         if ('tlid' in track) {\r\n    //             // Get track information from TlTrack instance\r\n    //             tlid = track.tlid;\r\n    //             track = track.track;\r\n    //             nextTrack = nextTrack ? nextTrack.track : undefined;\r\n    //         }\r\n    //         getState().popupData[track.uri] = track;\r\n    //         let divider = renderSongLiDivider(previousTrack, track, nextTrack, target);\r\n    //         html += divider[0] + renderSongLi(previousTrack, track, nextTrack, uri, tlid, target, i, results.length);\r\n    //         requiredImages[track.uri] = divider[1];\r\n    //     }\r\n    // }\r\n    // document.querySelector(target).append(html);\r\n    // updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction())\r\n    // images.setImages(requiredImages, getState().mopidy, 'small');\r\n}\r\n\r\nfunction getUris (tracks) {\r\n    let results = []\r\n    for (let i = 0; i < tracks.length; i++) {\r\n        results.push(tracks[i].uri)\r\n    }\r\n    return results\r\n}\r\n\r\nexport function getTracksFromUri (uri, full_track_data) {\r\n    let returnTracksOrUris = function (tracks) {\r\n        return full_track_data ? tracks : getUris(tracks)\r\n    }\r\n    if (getState().customTracklists[uri]) {\r\n        return returnTracksOrUris(getState().customTracklists[uri])\r\n    } else if (getState().playlists[uri] && getState().playlists[uri].tracks) {\r\n        return returnTracksOrUris(getState().playlists[uri].tracks)\r\n    }\r\n    return []\r\n}\r\n\r\n// convert time to human readable format\r\nfunction timeFromSeconds (length) {\r\n    let d = Number(length);\r\n    let h = Math.floor(d / 3600);\r\n    let m = Math.floor(d % 3600 / 60);\r\n    let s = Math.floor(d % 3600 % 60);\r\n    return ((h > 0 ? h + ':' : '') + (m > 0 ? (h > 0 && m < 10 ? '0' : '') + m + ':' : '0:') + (s < 10 ? '0' : '') + s);\r\n}\r\n\r\n/** ***** Toast ***/\r\nfunction toast (message, delay, textOnly) {\r\n    //todo\r\n    // let textOnl = textOnly || false;\r\n    // message = message || 'Loading...'\r\n    // delay = delay || 1000\r\n    // $.mobile.loading('show', {\r\n    //     text: message,\r\n    //     textVisible: true,\r\n    //     theme: 'a',\r\n    //     textonly: textOnl\r\n    // })\r\n    // if (delay > 0) {\r\n    //     setTimeout(function () {\r\n    //         $.mobile.loading('hide')\r\n    //     }, delay)\r\n    // }\r\n}\r\n\r\n/** ****************\r\n * Modal dialogs  *\r\n ******************/\r\nexport function showLoading (on) {\r\n    //todo\r\n    // if (on) {\r\n    //     document.body.classList.add('cursor', 'progress');\r\n    //     $.mobile.loading('show', {\r\n    //         text: 'Loading data from ' + HOSTNAME + '. Please wait...',\r\n    //         textVisible: true,\r\n    //         theme: 'a'\r\n    //     })\r\n    // } else {\r\n    //     $('body').css('cursor', 'default')\r\n    //     $.mobile.loading('hide')\r\n    // }\r\n}\r\n\r\n// from http://dzone.com/snippets/validate-url-regexp\r\nexport function validUri (uri: string) {\r\n    let regexp = /^(http|https|mms|rtmp|rtmps|rtsp):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?/;\r\n    return regexp.test(uri);\r\n}\r\n\r\nfunction validServiceUri (str: string) {\r\n    return validUri(str) || isServiceUri(str);\r\n}\r\n\r\nexport function getScheme (uri: string) {\r\n    return uri.split(':')[0].toLowerCase();\r\n}\r\n\r\nfunction isPlayable (track) {\r\n    if (typeof track.type === 'undefined' || track.type === 'track') {\r\n        if (track.uri && getScheme(track.uri) === 'file') {\r\n            let ext = track.uri.split('.').pop().toLowerCase();\r\n            // Files must have the correct extension\r\n            return VALID_AUDIO_EXT.includes(ext);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function isStreamUri (uri) {\r\n    return validUri(uri) || radioExtensionsList.indexOf(getScheme(uri)) >= 0\r\n}\r\n\r\nexport function getMediaClass (track) {\r\n    let defaultIcon = 'fa-file-sound-o'\r\n    let type = track.type\r\n    if (typeof type === 'undefined' || type === 'track') {\r\n        if (!isPlayable(track)) {\r\n            return 'fa fa-file-o'  // Unplayable file\r\n        } else if (isStreamUri(track.uri)) {\r\n            return 'fa fa-rss'  // Stream\r\n        }\r\n    } else if (type === 'directory') {\r\n        return 'fa fa-folder-o'\r\n    } else if (type === 'album') {\r\n        // return 'fa fa-bullseye'  // Album\r\n        defaultIcon = 'fa-folder-o'\r\n    } else if (type === 'artist') {\r\n        // return 'fa fa-user-circle-o'  // Artist\r\n        defaultIcon = 'fa-folder-o'\r\n    } else if (type === 'playlist') {\r\n        // return 'fa fa-star'  // Playlist\r\n    }\r\n    if (track.uri) {\r\n        let scheme = getScheme(track.uri)\r\n        for (let i = 0; i < uriClassList.length; i++) {\r\n            if (scheme === uriClassList[i][0]) {\r\n                return 'fa ' + uriClassList[i][1]\r\n            }\r\n        }\r\n        return 'fa ' + defaultIcon\r\n    }\r\n    return ''\r\n}\r\n\r\nfunction getMediaHuman (uri) {\r\n    let scheme = getScheme(uri)\r\n    for (let i = 0; i < uriHumanList.length; i++) {\r\n        if (scheme.toLowerCase() === uriHumanList[i][0].toLowerCase()) {\r\n            return uriHumanList[i][1]\r\n        }\r\n    }\r\n    return ''\r\n}\r\n\r\nfunction isServiceUri (uri) {\r\n    let scheme = getScheme(uri)\r\n    let i = 0\r\n    for (i = 0; i < uriClassList.length; i++) {\r\n        if (scheme === uriClassList[i][0]) {\r\n            return true\r\n        }\r\n    }\r\n    for (i = 0; i < radioExtensionsList.length; i++) {\r\n        if (scheme === radioExtensionsList[i]) {\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function isFavouritesPlaylist (playlist) {\r\n    return (playlist.name === STREAMS_PLAYLIST_NAME &&\r\n            getScheme(playlist.uri) === STREAMS_PLAYLIST_SCHEME)\r\n}\r\n\r\n// Returns a string where {x} in template is replaced by tokens[x].\r\nfunction stringFromTemplate (template, tokens) {\r\n    return template.replace(/{[^}]+}/g, function (match) {\r\n        return tokens[match.slice(1, -1)]\r\n    })\r\n}\r\n\r\n/**\r\n * Converts a URI to a jQuery-safe identifier. jQuery identifiers need to be\r\n * unique per page and cannot contain special characters.\r\n *\r\n * @param {string} identifier - Identifier string to prefix to the URI. Can\r\n * be used to ensure that the generated ID will be unique for the page that\r\n * it will be included on. Also accepts jQuery identifiers starting with '#'.\r\n *\r\n * @param {string} uri - URI to encode, usually the URI of a Mopidy track.\r\n *\r\n * @param {boolean} includePrefix - Will prefix the generated identifier\r\n * with the '#' character if set to 'true', ready to be passed to $() or\r\n * jQuery().\r\n *\r\n * @return {string} - a string in the format '[#]identifier-encodedURI' that\r\n * is safe to use as a jQuery identifier.\r\n */\r\nexport function getUniqueId (identifier: string, uri: string, includePrefix: boolean = false) {\r\n    if (identifier.charAt(0) === '#' && !includePrefix) {\r\n        identifier = identifier.substring(1);\r\n    } else if (identifier.charAt(0) !== '#' && includePrefix) {\r\n        identifier = '#' + identifier\r\n    }\r\n    return identifier + '-' + fixedEncodeURIComponent(uri).replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '')  // eslint-disable-line no-useless-escape\r\n}\r\n\r\n// Strict URI encoding as per https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\r\nfunction fixedEncodeURIComponent (str) {\r\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\r\n        return '%' + c.charCodeAt(0).toString(16)\r\n    })\r\n}\r\n\r\nexport function updatePlayIcons(uri: string, tlid: number, popupMenuIcon) {\r\n    // Update styles of listviews\r\n    let listviews = [PLAYLIST_TABLE, SEARCH_TRACK_TABLE, ARTIST_TABLE, ALBUM_TABLE, BROWSE_TABLE];\r\n    let target = CURRENT_PLAYLIST_TABLE.substring(1);\r\n    if (uri && typeof tlid === 'number' && tlid >= 0) {\r\n        document.querySelector(CURRENT_PLAYLIST_TABLE).querySelectorAll('li.song.albumli').forEach((el) => {\r\n            let eachTlid = parseInt(el.getAttribute('tlid'));\r\n            if (this.id === getUniqueId(target, uri) && eachTlid === tlid) {\r\n                if (!el.classList.contains('currenttrack')) {\r\n                    el.classList.add('currenttrack');\r\n                }\r\n            } else if (el.classList.contains('currenttrack')) {\r\n                el.classList.remove('currenttrack');\r\n            }\r\n        })\r\n    }\r\n\r\n    let popupElement;\r\n\r\n    for (let i = 0; i < listviews.length; i++) {\r\n        target = listviews[i].substring(1)\r\n        document.querySelector(listviews[i]).querySelectorAll('li.song.albumli').forEach((el) => {\r\n            if (uri) {\r\n                if (this.id === getUniqueId(target, uri)) {\r\n                    el.classList.add('currenttrack2');\r\n                } else {\r\n                    el.classList.remove('currenttrack2');\r\n                }\r\n            }\r\n            if (popupMenuIcon) {\r\n                popupElement = el.querySelector('a.moreBtn').querySelectorAll('i').item(0);\r\n                if (!popupElement.hasClass(popupMenuIcon)) {\r\n                    popupElement.removeClass()\r\n                    popupElement.addClass(popupMenuIcon)\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport function switchContent(divid: string, uri: string = undefined) {\r\n    let hash = divid;\r\n    if (uri) {\r\n        hash += '?' + uri\r\n    }\r\n    location.hash = '#' + hash\r\n}\r\n\r\nexport function jsonParse<T>(data: string, defaultValue: T): T {\r\n    try {\r\n        return JSON.parse(data);\r\n    } catch (e) {\r\n        console.error(e);\r\n        return defaultValue;\r\n    }\r\n}","import getState from \"./playerState\";\r\nimport {processCurrentPlaylist, processGetPlaylists} from \"./process_ws\";\r\n\r\nexport let library = {\r\n\r\n    /** *******************************\r\n     * Search\r\n     *********************************/\r\n    searchPressed: function (key) {\r\n        // var value = document.getElementById('searchinput').val();\r\n        // switchContent('search');\r\n        //\r\n        // if (key === 13) {\r\n        //     library.initSearch()\r\n        //     return false\r\n        // }\r\n        return true\r\n    },\r\n\r\n    // init search\r\n    initSearch: function () {\r\n        // let value = document.getElementById('searchinput').val();\r\n        // let searchService = document.getElementById(#selectSearchService').val();\r\n        // // $.cookie('searchScheme', searchService, {expires: 365})\r\n        //\r\n        // if ((value.length < 100) && (value.length > 0)) {\r\n        //     showLoading(true)\r\n        //     // hide ios/android keyboard\r\n        //     document.activeElement.blur()\r\n        //     $('input').blur()\r\n        //\r\n        //     delete customTracklists[URI_SCHEME + ':trackresultscache']\r\n        //     document.getElementById(#searchartists').hide()\r\n        //     document.getElementById(#searchalbums').hide()\r\n        //     document.getElementById(#searchtracks').hide()\r\n        //\r\n        //     if (searchService !== 'all') {\r\n        //         mopidy.library.search({'query': {any: [value]}, 'uris': [searchService + ':']}).then(library.processSearchResults, console.error)\r\n        //     } else {\r\n        //         mopidy.getUriSchemes().then(function (schemes) {\r\n        //             var query = {}\r\n        //             var uris = []\r\n        //\r\n        //             var regexp = $.map(schemes, function (scheme) {\r\n        //                 return '^' + scheme + ':'\r\n        //             }).join('|')\r\n        //\r\n        //             var match = value.match(regexp)\r\n        //             if (match) {\r\n        //                 var scheme = match[0]\r\n        //                 query = {uri: [value]}\r\n        //                 uris = [scheme]\r\n        //             } else {\r\n        //                 query = {any: [value]}\r\n        //             }\r\n        //             mopidy.library.search({'query': query, 'uris': uris}).then(library.processSearchResults, console.error)\r\n        //         })\r\n        //     }\r\n        // }\r\n    },\r\n\r\n    /** ******************************************************\r\n     * process results of a search\r\n     *********************************************************/\r\n    processSearchResults: function (resultArr) {\r\n        // $(SEARCH_TRACK_TABLE).empty()\r\n        // $(SEARCH_ARTIST_TABLE).empty()\r\n        // $(SEARCH_ALBUM_TABLE).empty()\r\n        //\r\n        // // Merge results from different backends.\r\n        // // TODO  should of coures have multiple tables\r\n        // var results = {'tracks': [], 'artists': [], 'albums': []}\r\n        // var i, j\r\n        // var emptyResult = true\r\n        //\r\n        // for (i = 0; i < resultArr.length; i++) {\r\n        //     if (resultArr[i].tracks) {\r\n        //         for (j = 0; j < resultArr[i].tracks.length; j++) {\r\n        //             results.tracks.push(resultArr[i].tracks[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        //     if (resultArr[i].artists) {\r\n        //         for (j = 0; j < resultArr[i].artists.length; j++) {\r\n        //             results.artists.push(resultArr[i].artists[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        //     if (resultArr[i].albums) {\r\n        //         for (j = 0; j < resultArr[i].albums.length; j++) {\r\n        //             results.albums.push(resultArr[i].albums[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        // }\r\n        //\r\n        // customTracklists[URI_SCHEME + ':trackresultscache'] = results.tracks\r\n        //\r\n        // if (emptyResult) {\r\n        //     document.getElementById(#searchtracks').show()\r\n        //     $(SEARCH_TRACK_TABLE).append(\r\n        //         '<li class=\"song albumli\"><a href=\"#\"><h1><i></i>No tracks found...</h1></a></li>'\r\n        //     )\r\n        //     toast('No results')\r\n        //     showLoading(false)\r\n        //     return false\r\n        // }\r\n        //\r\n        // if (results.artists.length > 0) {\r\n        //     document.getElementById(#searchartists').show()\r\n        // }\r\n        //\r\n        // if (results.albums.length > 0) {\r\n        //     document.getElementById(#searchalbums').show()\r\n        // }\r\n        //\r\n        // if (results.tracks.length > 0) {\r\n        //     document.getElementById(#searchtracks').show()\r\n        // }\r\n        //\r\n        // // 'Show more' template\r\n        // var showMoreTemplate = '<li onclick=\"$(this).hide().siblings().show(); return false;\"><a>Show {count} more</a></li>'\r\n        //\r\n        // // Artist results\r\n        // var child = ''\r\n        // var template = '<li><a href=\"#\" onclick=\"return library.showArtist(this.id, mopidy)\" id={id}><i class=\"{class}\"></i> <strong>{name}</strong></a></li>'\r\n        // var tokens\r\n        //\r\n        // for (i = 0; i < results.artists.length; i++) {\r\n        //     tokens = {\r\n        //         'id': results.artists[i].uri,\r\n        //         'name': results.artists[i].name,\r\n        //         'class': getMediaClass(results.artists[i])\r\n        //     }\r\n        //\r\n        //     // Add 'Show all' item after a certain number of hits.\r\n        //     if (i === 4 && results.artists.length > 5) {\r\n        //         child += stringFromTemplate(showMoreTemplate, {'count': results.artists.length - i})\r\n        //         template = template.replace('<li>', '<li class=\"overflow\">')\r\n        //     }\r\n        //\r\n        //     child += stringFromTemplate(template, tokens)\r\n        // }\r\n        //\r\n        // // Inject list items, refresh listview and hide superfluous items.\r\n        // $(SEARCH_ARTIST_TABLE).html(child).listview('refresh').find('.overflow').hide()\r\n        //\r\n        // // Album results\r\n        // child = ''\r\n        // template = '<li><a href=\"#\" onclick=\"return library.showAlbum(this.id, mopidy)\" id=\"{albumId}\">'\r\n        // template += '<h5 data-role=\"heading\"><i class=\"{class}\"></i> {albumName}</h5>'\r\n        // template += '<p data-role=\"desc\">{artistName}</p>'\r\n        // template += '</a></li>'\r\n        //\r\n        // for (i = 0; i < results.albums.length; i++) {\r\n        //     tokens = {\r\n        //         'albumId': results.albums[i].uri,\r\n        //         'albumName': results.albums[i].name,\r\n        //         'artistName': '',\r\n        //         'albumYear': results.albums[i].date,\r\n        //         'class': getMediaClass(results.albums[i])\r\n        //     }\r\n        //     if (results.albums[i].artists) {\r\n        //         for (j = 0; j < results.albums[i].artists.length; j++) {\r\n        //             if (results.albums[i].artists[j].name) {\r\n        //                 tokens.artistName += results.albums[i].artists[j].name + ' '\r\n        //             }\r\n        //         }\r\n        //     }\r\n        //     if (tokens.albumYear) {\r\n        //         tokens.artistName += '(' + tokens.albumYear + ')'\r\n        //     }\r\n        //     // Add 'Show all' item after a certain number of hits.\r\n        //     if (i === 4 && results.albums.length > 5) {\r\n        //         child += stringFromTemplate(showMoreTemplate, {'count': results.albums.length - i})\r\n        //         template = template.replace('<li>', '<li class=\"overflow\">')\r\n        //     }\r\n        //\r\n        //     child += stringFromTemplate(template, tokens)\r\n        // }\r\n        // // Inject list items, refresh listview and hide superfluous items.\r\n        // $(SEARCH_ALBUM_TABLE).html(child).listview('refresh').find('.overflow').hide()\r\n        //\r\n        // // Track results\r\n        // resultsToTables(results.tracks, SEARCH_TRACK_TABLE, URI_SCHEME + ':trackresultscache')\r\n        //\r\n        // showLoading(false)\r\n    },\r\n\r\n    /** *******************************\r\n     * Playlists & Browse\r\n     *********************************/\r\n    getPlaylists: function () {\r\n        //  get playlists without tracks\r\n        // getState().commands.core.playlists.asList().then(processGetPlaylists, console.error)\r\n    },\r\n\r\n    getBrowseDir: function (rootdir: string | undefined) {\r\n        // //  get directory to browse\r\n        // showLoading(true)\r\n        // if (!rootdir) {\r\n        //     browseStack.pop()\r\n        //     if (browseStack.length > 0) {\r\n        //         rootdir = browseStack[browseStack.length - 1].uri  // Navigated one level up\r\n        //     } else {\r\n        //         rootdir = null  // Navigated to top of library\r\n        //     }\r\n        // } else if (browseStack.length === 0 || rootdir !== browseStack[browseStack.length - 1].uri) {\r\n        //     browseStack.push({'uri': rootdir, 'scrollPos': 0})  // Navigated one level down\r\n        // }\r\n        // mopidy.library.browse({'uri': rootdir}).then(function (resultArr) {\r\n        //     processBrowseDir(resultArr)\r\n        //     if (rootdir === null) {\r\n        //         $('.refreshLibraryBtnDiv').hide()  // Mopidy does not support refreshing list of backends.\r\n        //     } else {\r\n        //         $('.refreshLibraryBtnDiv').show()\r\n        //         document.getElementById(#refreshLibraryBtn').data('url', rootdir)\r\n        //         document.getElementById(#refreshLibraryBtn').off('click')\r\n        //         document.getElementById(#refreshLibraryBtn').one('click', controls.refreshLibrary)\r\n        //     }\r\n        // }, console.error)\r\n    },\r\n\r\n    /** ******************************************************\r\n     * Show tracks of playlist\r\n     ********************************************************/\r\n    togglePlaylists: function () {\r\n        // if (window.innerWidth <= 960) {\r\n        //     document.getElementById('playlisttracksdiv').toggle();\r\n        //     // Hide other div\r\n        //     (document.getElementById('playlisttracksdiv').is(':visible')) ? document.getElementById('playlistslistdiv').hide() : document.getElementById('playlistslistdiv').show()\r\n        // } else {\r\n        //     document.getElementById('playlisttracksdiv').show()\r\n        //     document.getElementById('playlistslistdiv').show()\r\n        // }\r\n        return true\r\n    },\r\n\r\n    /** **********\r\n     * Lookups\r\n     ************/\r\n    showTracklist: function (uri) {\r\n        // showLoading(true)\r\n        // $(PLAYLIST_TABLE).empty()\r\n        // library.togglePlaylists()\r\n        // var tracks = getPlaylistTracks(uri).then(function (tracks) {\r\n        //     resultsToTables(tracks, PLAYLIST_TABLE, uri, 'return library.togglePlaylists();', true)\r\n        //     showLoading(false)\r\n        // })\r\n        // updatePlayIcons(uri, '', controls.getIconForAction())\r\n        // document.getElementById('playlistslist li a').each(function () {\r\n        //     $(this).removeClass('playlistactive')\r\n        //     if (this.id === uri) {\r\n        //         $(this).addClass('playlistactive')\r\n        //     }\r\n        // })\r\n        return false\r\n    },\r\n\r\n    showArtist: function (nwuri, mopidy) {\r\n        // document.getElementById('popupQueue').popup('close')\r\n        // document.getElementById('popupTracks').popup('close')\r\n        // document.getElementById('controlsmodal').popup('close')\r\n        // $(ARTIST_TABLE).empty()\r\n        //\r\n        // if (!nwuri.length || nwuri === 'undefined') {\r\n        //     return false\r\n        // }\r\n        //\r\n        // // TODO cache\r\n        //\r\n        // document.getElementById('h_artistname').html('')\r\n        // showLoading(true)\r\n        // mopidy.library.lookup({'uris': [nwuri]}).then(function (resultDict) {\r\n        //     var resultArr = resultDict[nwuri]\r\n        //     resultArr.uri = nwuri\r\n        //     processArtistResults(resultArr)\r\n        // }, console.error)\r\n        // switchContent('artists', nwuri)\r\n        // scrollToTop()\r\n        return false\r\n    },\r\n\r\n    showAlbum: function (uri, mopidy) {\r\n        // document.getElementById('popupQueue').popup('close')\r\n        // document.getElementById('popupTracks').popup('close')\r\n        // document.getElementById('controlsmodal').popup('close')\r\n        // $(ALBUM_TABLE).empty()\r\n        //\r\n        // if (!uri.length || uri === 'undefined') {\r\n        //     return false\r\n        // }\r\n        //\r\n        // // fill from cache\r\n        // var pl = getTracksFromUri(uri, true)\r\n        // if (pl.length > 0) {\r\n        //     albumTracksToTable(pl, ALBUM_TABLE, uri)\r\n        //     var albumname = getAlbum(pl)\r\n        //     var artistname = getArtist(pl)\r\n        //     document.getElementById('h_albumname').html(albumname)\r\n        //     document.getElementById('h_albumartist').html(artistname)\r\n        //     document.getElementById('coverpopupalbumname').html(albumname)\r\n        //     document.getElementById('coverpopupartist').html(artistname)\r\n        //     showLoading(false)\r\n        //     mopidy.library.lookup({'uris': [uri]}).then(function (resultDict) {\r\n        //         var resultArr = resultDict[uri]\r\n        //         resultArr.uri = uri\r\n        //         processAlbumResults(resultArr)\r\n        //     }, console.error)\r\n        // } else {\r\n        //     showLoading(true)\r\n        //     document.getElementById('h_albumname').html('')\r\n        //     document.getElementById('h_albumartist').html('')\r\n        //     mopidy.library.lookup({'uris': [uri]}).then(function (resultDict) {\r\n        //         var resultArr = resultDict[uri]\r\n        //         resultArr.uri = uri\r\n        //         processAlbumResults(resultArr)\r\n        //     }, console.error)\r\n        // }\r\n        // // show page\r\n        // switchContent('albums', uri)\r\n        // scrollToTop()\r\n        // return false\r\n    },\r\n\r\n    getSearchSchemes: function (searchBlacklist, mopidy) {\r\n        // var backendName\r\n        // var searchScheme = $.cookie('searchScheme')\r\n        // if (searchScheme) {\r\n        //     searchScheme = searchScheme.replace(/\"/g, '')\r\n        // } else {\r\n        //     searchScheme = 'all'\r\n        // }\r\n        // document.getElementById('selectSearchService').empty()\r\n        // document.getElementById('selectSearchService').append(new Option('All services', 'all'))\r\n        // mopidy.getUriSchemes().then(function (schemesArray) {\r\n        //     schemesArray = schemesArray.filter(function (el) {\r\n        //         return searchBlacklist.indexOf(el) < 0\r\n        //     })\r\n        //     for (var i = 0; i < schemesArray.length; i++) {\r\n        //         backendName = getMediaHuman(schemesArray[i])\r\n        //         if (!backendName) {\r\n        //             // No mapping defined, revert to just showing the scheme with first letter capitalized.\r\n        //             backendName = schemesArray[i].charAt(0).toUpperCase() + schemesArray[i].slice(1)\r\n        //         }\r\n        //         document.getElementById('selectSearchService').append(new Option(backendName, schemesArray[i]))\r\n        //     }\r\n        //     document.getElementById('selectSearchService').val(searchScheme)\r\n        //     document.getElementById('selectSearchService').selectmenu('refresh', true)\r\n        // }, console.error)\r\n    }\r\n};\r\n","//GENERATED by build_commands.ts (although probably customized, so do a diff when regenerating).\nimport models, {core, Mopidy} from \"../js/mopidy\";\nimport TlTrack = models.TlTrack;\nimport PlaybackState = core.PlaybackState;\nimport Playlist = models.Playlist;\n\nexport class Commands {\n    protected mopidy: Mopidy;\n    \n    constructor(mopidy: Mopidy) {\n        this.mopidy = mopidy;\n        this.core.commands = this;\n        this.core.history.commands = this;\n        this.core.library.commands = this;\n        this.core.mixer.commands = this;\n        this.core.playback.commands = this;\n        this.core.playlists.commands = this;\n        this.core.tracklist.commands = this;\n\n    }\n    \n    send(method: string, params: Object) {\n        if(params)\n            return this.mopidy.send({method, params});\n        else\n            return this.mopidy.send({method});\n    }\n    core = {\n        commands: undefined as Commands,\n\n            //Get list of URI schemes we can handle\n        getUriSchemes() {\n            return this.commands.send(\"core.get_uri_schemes\");\n        },\n            //Get version of the Mopidy core API\n        getVersion() {\n            return this.commands.send(\"core.get_version\");\n        },\n        history: {\n            commands: undefined as Commands,\n                //Get the track history.\n                //\n                //The timestamps are milliseconds since epoch.\n                //\n                //:returns: the track history\n                //:rtype: list of (timestamp, :class:`mopidy.models.Ref`) tuples\n            getHistory() {\n                return this.commands.send(\"core.history.get_history\");\n            },\n                //Get the number of tracks in the history.\n                //\n                //:returns: the history length\n                //:rtype: int\n            getLength() {\n                return this.commands.send(\"core.history.get_length\");\n            },\n        },\n        library: {\n            commands: undefined as Commands,\n                //Browse directories and tracks at the given ``uri``.\n                //\n                //``uri`` is a string which represents some directory belonging to a\n                //backend. To get the intial root directories for backends pass\n                //:class:`None` as the URI.\n                //\n                //Returns a list of :class:`mopidy.models.Ref` objects for the\n                //directories and tracks at the given ``uri``.\n                //\n                //The :class:`~mopidy.models.Ref` objects representing tracks keep the\n                //track's original URI. A matching pair of objects can look like this::\n                //\n                //    Track(uri='dummy:/foo.mp3', name='foo', artists=..., album=...)\n                //    Ref.track(uri='dummy:/foo.mp3', name='foo')\n                //\n                //The :class:`~mopidy.models.Ref` objects representing directories have\n                //backend specific URIs. These are opaque values, so no one but the\n                //backend that created them should try and derive any meaning from them.\n                //The only valid exception to this is checking the scheme, as it is used\n                //to route browse requests to the correct backend.\n                //\n                //For example, the dummy library's ``/bar`` directory could be returned\n                //like this::\n                //\n                //    Ref.directory(uri='dummy:directory:/bar', name='bar')\n                //\n                //:param string uri: URI to browse\n                //:rtype: list of :class:`mopidy.models.Ref`\n                //\n                //.. versionadded:: 0.18\n            browse(uri: string) {\n                return this.commands.send(\"core.library.browse\", {uri});\n            },\n                //List distinct values for a given field from the library.\n                //\n                //This has mainly been added to support the list commands the MPD\n                //protocol supports in a more sane fashion. Other frontends are not\n                //recommended to use this method.\n                //\n                //:param string field: Any one of ``uri``, ``track_name``, ``album``,\n                //    ``artist``, ``albumartist``, ``composer``, ``performer``,\n                //    ``track_no``, ``genre``, ``date``, ``comment``, ``disc_no``,\n                //    ``musicbrainz_albumid``, ``musicbrainz_artistid``, or\n                //    ``musicbrainz_trackid``.\n                //:param dict query: Query to use for limiting results, see\n                //    :meth:`search` for details about the query format.\n                //:rtype: set of values corresponding to the requested field type.\n                //\n                //.. versionadded:: 1.0\n            getDistinct(field: string, query: Object) {\n                return this.commands.send(\"core.library.get_distinct\", {field, query});\n            },\n                //Lookup the images for the given URIs\n                //\n                //Backends can use this to return image URIs for any URI they know about\n                //be it tracks, albums, playlists. The lookup result is a dictionary\n                //mapping the provided URIs to lists of images.\n                //\n                //Unknown URIs or URIs the corresponding backend couldn't find anything\n                //for will simply return an empty list for that URI.\n                //\n                //:param uris: list of URIs to find images for\n                //:type uris: list of string\n                //:rtype: {uri: tuple of :class:`mopidy.models.Image`}\n                //\n                //.. versionadded:: 1.0\n            getImages(uris: string[]) {\n                return this.commands.send(\"core.library.get_images\", {uris});\n            },\n                //Lookup the given URIs.\n                //\n                //If the URI expands to multiple tracks, the returned list will contain\n                //them all.\n                //\n                //:param uris: track URIs\n                //:type uris: list of string\n                //:rtype: {uri: list of :class:`mopidy.models.Track`}\n            lookup(uris: string[]) {\n                return this.commands.send(\"core.library.lookup\", {uris});\n            },\n                //Refresh library. Limit to URI and below if an URI is given.\n                //\n                //:param uri: directory or track URI\n                //:type uri: string\n            refresh(uri: string) {\n                return this.commands.send(\"core.library.refresh\", {uri});\n            },\n                //Search the library for tracks where ``field`` contains ``values``.\n                //\n                //``field`` can be one of ``uri``, ``track_name``, ``album``, ``artist``,\n                //``albumartist``, ``composer``, ``performer``, ``track_no``, ``genre``,\n                //``date``, ``comment``, ``disc_no``, ``musicbrainz_albumid``,\n                //``musicbrainz_artistid``, ``musicbrainz_trackid`` or ``any``.\n                //\n                //If ``uris`` is given, the search is limited to results from within the\n                //URI roots. For example passing ``uris=['file:']`` will limit the search\n                //to the local backend.\n                //\n                //Examples::\n                //\n                //    # Returns results matching 'a' in any backend\n                //    search({'any': ['a']})\n                //\n                //    # Returns results matching artist 'xyz' in any backend\n                //    search({'artist': ['xyz']})\n                //\n                //    # Returns results matching 'a' and 'b' and artist 'xyz' in any\n                //    # backend\n                //    search({'any': ['a', 'b'], 'artist': ['xyz']})\n                //\n                //    # Returns results matching 'a' if within the given URI roots\n                //    # \"file:///media/music\" and \"spotify:\"\n                //    search({'any': ['a']}, uris=['file:///media/music', 'spotify:'])\n                //\n                //    # Returns results matching artist 'xyz' and 'abc' in any backend\n                //    search({'artist': ['xyz', 'abc']})\n                //\n                //:param query: one or more queries to search for\n                //:type query: dict\n                //:param uris: zero or more URI roots to limit the search to\n                //:type uris: list of string or :class:`None`\n                //:param exact: if the search should use exact matching\n                //:type exact: :class:`bool`\n                //:rtype: list of :class:`mopidy.models.SearchResult`\n                //\n                //.. versionadded:: 1.0\n                //    The ``exact`` keyword argument.\n            search(query: Object, uris?: string[], exact: boolean = false) {\n                return this.commands.send(\"core.library.search\", {query, uris, exact});\n            },\n        },\n        mixer: {\n            commands: undefined as Commands,\n                //Get mute state.\n                //\n                //:class:`True` if muted, :class:`False` unmuted, :class:`None` if\n                //unknown.\n            getMute() {\n                return this.commands.send(\"core.mixer.get_mute\");\n            },\n                //Get the volume.\n                //\n                //Integer in range [0..100] or :class:`None` if unknown.\n                //\n                //The volume scale is linear.\n            getVolume() {\n                return this.commands.send(\"core.mixer.get_volume\");\n            },\n                //Set mute state.\n                //\n                //:class:`True` to mute, :class:`False` to unmute.\n                //\n                //Returns :class:`True` if call is successful, otherwise :class:`False`.\n            setMute(mute: boolean) {\n                return this.commands.send(\"core.mixer.set_mute\", {mute});\n            },\n                //Set the volume.\n                //\n                //The volume is defined as an integer in range [0..100].\n                //\n                //The volume scale is linear.\n                //\n                //Returns :class:`True` if call is successful, otherwise :class:`False`.\n            setVolume(volume: number) {\n                return this.commands.send(\"core.mixer.set_volume\", {volume});\n            },\n        },\n        playback: {\n            commands: undefined as Commands,\n                //Get the currently playing or selected track.\n                //\n                //Returns a :class:`mopidy.models.TlTrack` or :class:`None`.\n            getCurrentTlTrack() {\n                return this.commands.send(\"core.playback.get_current_tl_track\");\n            },\n                //Get the currently playing or selected TLID.\n                //\n                //Extracted from :meth:`get_current_tl_track` for convenience.\n                //\n                //Returns a :class:`int` or :class:`None`.\n                //\n                //.. versionadded:: 1.1\n            getCurrentTlid() {\n                return this.commands.send(\"core.playback.get_current_tlid\");\n            },\n                //Get the currently playing or selected track.\n                //\n                //Extracted from :meth:`get_current_tl_track` for convenience.\n                //\n                //Returns a :class:`mopidy.models.Track` or :class:`None`.\n            getCurrentTrack() {\n                return this.commands.send(\"core.playback.get_current_track\");\n            },\n                //Get The playback state.\n            getState() {\n                return this.commands.send(\"core.playback.get_state\");\n            },\n                //Get the current stream title or :class:`None`.\n            getStreamTitle() {\n                return this.commands.send(\"core.playback.get_stream_title\");\n            },\n                //Get time position in milliseconds.\n            getTimePosition() {\n                return this.commands.send(\"core.playback.get_time_position\");\n            },\n                //Change to the next track.\n                //\n                //The current playback state will be kept. If it was playing, playing\n                //will continue. If it was paused, it will still be paused, etc.\n            next() {\n                return this.commands.send(\"core.playback.next\");\n            },\n                //Pause playback.\n            pause() {\n                return this.commands.send(\"core.playback.pause\");\n            },\n                //Play the given track, or if the given tl_track and tlid is\n                //:class:`None`, play the currently active track.\n                //\n                //Note that the track **must** already be in the tracklist.\n                //\n                //.. deprecated:: 3.0\n                //    The ``tl_track`` argument. Use ``tlid`` instead.\n                //\n                //:param tl_track: track to play\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:param tlid: TLID of the track to play\n                //:type tlid: :class:`int` or :class:`None`\n            play(tl_track?: TlTrack, tlid?: number) {\n                return this.commands.send(\"core.playback.play\", {tl_track, tlid});\n            },\n                //Change to the previous track.\n                //\n                //The current playback state will be kept. If it was playing, playing\n                //will continue. If it was paused, it will still be paused, etc.\n            previous() {\n                return this.commands.send(\"core.playback.previous\");\n            },\n                //If paused, resume playing the current track.\n            resume() {\n                return this.commands.send(\"core.playback.resume\");\n            },\n                //Seeks to time position given in milliseconds.\n                //\n                //:param time_position: time position in milliseconds\n                //:type time_position: int\n                //:rtype: :class:`True` if successful, else :class:`False`\n            seek(time_position: number) {\n                return this.commands.send(\"core.playback.seek\", {time_position});\n            },\n                //Set the playback state.\n                //\n                //Must be :attr:`PLAYING`, :attr:`PAUSED`, or :attr:`STOPPED`.\n                //\n                //Possible states and transitions:\n                //\n                //.. digraph:: state_transitions\n                //\n                //    \"STOPPED\" -> \"PLAYING\" [ label=\"play\" ]\n                //    \"STOPPED\" -> \"PAUSED\" [ label=\"pause\" ]\n                //    \"PLAYING\" -> \"STOPPED\" [ label=\"stop\" ]\n                //    \"PLAYING\" -> \"PAUSED\" [ label=\"pause\" ]\n                //    \"PLAYING\" -> \"PLAYING\" [ label=\"play\" ]\n                //    \"PAUSED\" -> \"PLAYING\" [ label=\"resume\" ]\n                //    \"PAUSED\" -> \"STOPPED\" [ label=\"stop\" ]\n            setState(new_state: PlaybackState) {\n                return this.commands.send(\"core.playback.set_state\", {new_state});\n            },\n                //Stop playing.\n            stop() {\n                return this.commands.send(\"core.playback.stop\");\n            },\n        },\n        playlists: {\n            commands: undefined as Commands,\n                //Get a list of the currently available playlists.\n                //\n                //Returns a list of :class:`~mopidy.models.Ref` objects referring to the\n                //playlists. In other words, no information about the playlists' content\n                //is given.\n                //\n                //:rtype: list of :class:`mopidy.models.Ref`\n                //\n                //.. versionadded:: 1.0\n            asList() {\n                return this.commands.send(\"core.playlists.as_list\");\n            },\n                //Create a new playlist.\n                //\n                //If ``uri_scheme`` matches an URI scheme handled by a current backend,\n                //that backend is asked to create the playlist. If ``uri_scheme`` is\n                //:class:`None` or doesn't match a current backend, the first backend is\n                //asked to create the playlist.\n                //\n                //All new playlists must be created by calling this method, and **not**\n                //by creating new instances of :class:`mopidy.models.Playlist`.\n                //\n                //:param name: name of the new playlist\n                //:type name: string\n                //:param uri_scheme: use the backend matching the URI scheme\n                //:type uri_scheme: string\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            create(name: string, uri_scheme: string) {\n                return this.commands.send(\"core.playlists.create\", {name, uri_scheme});\n            },\n                //Delete playlist identified by the URI.\n                //\n                //If the URI doesn't match the URI schemes handled by the current\n                //backends, nothing happens.\n                //\n                //Returns :class:`True` if deleted, :class:`False` otherwise.\n                //\n                //:param uri: URI of the playlist to delete\n                //:type uri: string\n                //:rtype: :class:`bool`\n                //\n                //.. versionchanged:: 2.2\n                //    Return type defined.\n            delete(uri: string) {\n                return this.commands.send(\"core.playlists.delete\", {uri});\n            },\n                //Get the items in a playlist specified by ``uri``.\n                //\n                //Returns a list of :class:`~mopidy.models.Ref` objects referring to the\n                //playlist's items.\n                //\n                //If a playlist with the given ``uri`` doesn't exist, it returns\n                //:class:`None`.\n                //\n                //:rtype: list of :class:`mopidy.models.Ref`, or :class:`None`\n                //\n                //.. versionadded:: 1.0\n            getItems(uri: string) {\n                return this.commands.send(\"core.playlists.get_items\", {uri});\n            },\n                //Get the list of URI schemes that support playlists.\n                //\n                //:rtype: list of string\n                //\n                //.. versionadded:: 2.0\n            getUriSchemes() {\n                return this.commands.send(\"core.playlists.get_uri_schemes\");\n            },\n                //Lookup playlist with given URI in both the set of playlists and in any\n                //other playlist sources. Returns :class:`None` if not found.\n                //\n                //:param uri: playlist URI\n                //:type uri: string\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            lookup(uri: string) {\n                return this.commands.send(\"core.playlists.lookup\", {uri});\n            },\n                //Refresh the playlists in :attr:`playlists`.\n                //\n                //If ``uri_scheme`` is :class:`None`, all backends are asked to refresh.\n                //If ``uri_scheme`` is an URI scheme handled by a backend, only that\n                //backend is asked to refresh. If ``uri_scheme`` doesn't match any\n                //current backend, nothing happens.\n                //\n                //:param uri_scheme: limit to the backend matching the URI scheme\n                //:type uri_scheme: string\n            refresh(uri_scheme: string) {\n                return this.commands.send(\"core.playlists.refresh\", {uri_scheme});\n            },\n                //Save the playlist.\n                //\n                //For a playlist to be saveable, it must have the ``uri`` attribute set.\n                //You must not set the ``uri`` atribute yourself, but use playlist\n                //objects returned by :meth:`create` or retrieved from :attr:`playlists`,\n                //which will always give you saveable playlists.\n                //\n                //The method returns the saved playlist. The return playlist may differ\n                //from the saved playlist. E.g. if the playlist name was changed, the\n                //returned playlist may have a different URI. The caller of this method\n                //must throw away the playlist sent to this method, and use the\n                //returned playlist instead.\n                //\n                //If the playlist's URI isn't set or doesn't match the URI scheme of a\n                //current backend, nothing is done and :class:`None` is returned.\n                //\n                //:param playlist: the playlist\n                //:type playlist: :class:`mopidy.models.Playlist`\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            save(playlist: Playlist) {\n                return this.commands.send(\"core.playlists.save\", {playlist});\n            },\n        },\n        tracklist: {\n            commands: undefined as Commands,\n                //Add tracks to the tracklist.\n                //\n                //If ``uris`` is given instead of ``tracks``, the URIs are\n                //looked up in the library and the resulting tracks are added to the\n                //tracklist.\n                //\n                //If ``at_position`` is given, the tracks are inserted at the given\n                //position in the tracklist. If ``at_position`` is not given, the tracks\n                //are appended to the end of the tracklist.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param tracks: tracks to add\n                //:type tracks: list of :class:`mopidy.models.Track` or :class:`None`\n                //:param at_position: position in tracklist to add tracks\n                //:type at_position: int or :class:`None`\n                //:param uris: list of URIs for tracks to add\n                //:type uris: list of string or :class:`None`\n                //:rtype: list of :class:`mopidy.models.TlTrack`\n                //\n                //.. versionadded:: 1.0\n                //    The ``uris`` argument.\n                //\n                //.. deprecated:: 1.0\n                //    The ``tracks`` argument. Use ``uris``.\n            add(tracks?: undefined, at_position?: number, uris?: string[]) {\n                return this.commands.send(\"core.tracklist.add\", {tracks, at_position, uris});\n            },\n                //Clear the tracklist.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n            clear() {\n                return this.commands.send(\"core.tracklist.clear\");\n            },\n                //The track that will be played after the given track.\n                //\n                //Not necessarily the same track as :meth:`next_track`.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_eot_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            eotTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.eot_track\", {tl_track});\n            },\n                //Filter the tracklist by the given criteria.\n                //\n                //Each rule in the criteria consists of a model field and a list of\n                //values to compare it against. If the model field matches any of the\n                //values, it may be returned.\n                //\n                //Only tracks that match all the given criteria are returned.\n                //\n                //Examples::\n                //\n                //    # Returns tracks with TLIDs 1, 2, 3, or 4 (tracklist ID)\n                //    filter({'tlid': [1, 2, 3, 4]})\n                //\n                //    # Returns track with URIs 'xyz' or 'abc'\n                //    filter({'uri': ['xyz', 'abc']})\n                //\n                //    # Returns track with a matching TLIDs (1, 3 or 6) and a\n                //    # matching URI ('xyz' or 'abc')\n                //    filter({'tlid': [1, 3, 6], 'uri': ['xyz', 'abc']})\n                //\n                //:param criteria: one or more rules to match by\n                //:type criteria: dict, of (string, list) pairs\n                //:rtype: list of :class:`mopidy.models.TlTrack`\n            filter(criteria: any /*TODO: a dict*/) {\n                return this.commands.send(\"core.tracklist.filter\", {criteria});\n            },\n                //Get consume mode.\n                //\n                //:class:`True`\n                //    Tracks are removed from the tracklist when they have been played.\n                //:class:`False`\n                //    Tracks are not removed from the tracklist.\n            getConsume() {\n                return this.commands.send(\"core.tracklist.get_consume\");\n            },\n                //The TLID of the track that will be played after the current track.\n                //\n                //Not necessarily the same TLID as returned by :meth:`get_next_tlid`.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getEotTlid() {\n                return this.commands.send(\"core.tracklist.get_eot_tlid\");\n            },\n                //Get length of the tracklist.\n            getLength() {\n                return this.commands.send(\"core.tracklist.get_length\");\n            },\n                //The tlid of the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.next()`.\n                //\n                //For normal playback this is the next track in the tracklist. If repeat\n                //is enabled the next track can loop around the tracklist. When random is\n                //enabled this should be a random track, all tracks should be played once\n                //before the tracklist repeats.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getNextTlid() {\n                return this.commands.send(\"core.tracklist.get_next_tlid\");\n            },\n                //Returns the TLID of the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.previous()`.\n                //\n                //For normal playback this is the previous track in the tracklist. If\n                //random and/or consume is enabled it should return the current track\n                //instead.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getPreviousTlid() {\n                return this.commands.send(\"core.tracklist.get_previous_tlid\");\n            },\n                //Get random mode.\n                //\n                //:class:`True`\n                //    Tracks are selected at random from the tracklist.\n                //:class:`False`\n                //    Tracks are played in the order of the tracklist.\n            getRandom() {\n                return this.commands.send(\"core.tracklist.get_random\");\n            },\n                //Get repeat mode.\n                //\n                //:class:`True`\n                //    The tracklist is played repeatedly.\n                //:class:`False`\n                //    The tracklist is played once.\n            getRepeat() {\n                return this.commands.send(\"core.tracklist.get_repeat\");\n            },\n                //Get single mode.\n                //\n                //:class:`True`\n                //    Playback is stopped after current song, unless in ``repeat`` mode.\n                //:class:`False`\n                //    Playback continues after current song.\n            getSingle() {\n                return this.commands.send(\"core.tracklist.get_single\");\n            },\n                //Get tracklist as list of :class:`mopidy.models.TlTrack`.\n            getTlTracks() {\n                return this.commands.send(\"core.tracklist.get_tl_tracks\");\n            },\n                //Get tracklist as list of :class:`mopidy.models.Track`.\n            getTracks() {\n                return this.commands.send(\"core.tracklist.get_tracks\");\n            },\n                //Get the tracklist version.\n                //\n                //Integer which is increased every time the tracklist is changed. Is not\n                //reset before Mopidy is restarted.\n            getVersion() {\n                return this.commands.send(\"core.tracklist.get_version\");\n            },\n                //The position of the given track in the tracklist.\n                //\n                //If neither *tl_track* or *tlid* is given we return the index of\n                //the currently playing track.\n                //\n                //:param tl_track: the track to find the index of\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:param tlid: TLID of the track to find the index of\n                //:type tlid: :class:`int` or :class:`None`\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n                //    The *tlid* parameter\n            index(tl_track?: TlTrack, tlid?: number) {\n                return this.commands.send(\"core.tracklist.index\", {tl_track, tlid});\n            },\n                //Move the tracks in the slice ``[start:end]`` to ``to_position``.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param start: position of first track to move\n                //:type start: int\n                //:param end: position after last track to move\n                //:type end: int\n                //:param to_position: new position for the tracks\n                //:type to_position: int\n            move(start: number, end: number, to_position: number) {\n                return this.commands.send(\"core.tracklist.move\", {start, end, to_position});\n            },\n                //The track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.next()`.\n                //\n                //For normal playback this is the next track in the tracklist. If repeat\n                //is enabled the next track can loop around the tracklist. When random is\n                //enabled this should be a random track, all tracks should be played once\n                //before the tracklist repeats.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_next_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            nextTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.next_track\", {tl_track});\n            },\n                //Returns the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.previous()`.\n                //\n                //For normal playback this is the previous track in the tracklist. If\n                //random and/or consume is enabled it should return the current track\n                //instead.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_previous_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            previousTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.previous_track\", {tl_track});\n            },\n                //Remove the matching tracks from the tracklist.\n                //\n                //Uses :meth:`filter()` to lookup the tracks to remove.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param criteria: one or more rules to match by\n                //:type criteria: dict, of (string, list) pairs\n                //:rtype: list of :class:`mopidy.models.TlTrack` that were removed\n            remove(criteria: string /*TODO: or list */) {\n                return this.commands.send(\"core.tracklist.remove\", {criteria});\n            },\n                //Set consume mode.\n                //\n                //:class:`True`\n                //    Tracks are removed from the tracklist when they have been played.\n                //:class:`False`\n                //    Tracks are not removed from the tracklist.\n            setConsume(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_consume\", {value});\n            },\n                //Set random mode.\n                //\n                //:class:`True`\n                //    Tracks are selected at random from the tracklist.\n                //:class:`False`\n                //    Tracks are played in the order of the tracklist.\n            setRandom(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_random\", {value});\n            },\n                //Set repeat mode.\n                //\n                //To repeat a single track, set both ``repeat`` and ``single``.\n                //\n                //:class:`True`\n                //    The tracklist is played repeatedly.\n                //:class:`False`\n                //    The tracklist is played once.\n            setRepeat(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_repeat\", {value});\n            },\n                //Set single mode.\n                //\n                //:class:`True`\n                //    Playback is stopped after current song, unless in ``repeat`` mode.\n                //:class:`False`\n                //    Playback continues after current song.\n            setSingle(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_single\", {value});\n            },\n                //Shuffles the entire tracklist. If ``start`` and ``end`` is given only\n                //shuffles the slice ``[start:end]``.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param start: position of first track to shuffle\n                //:type start: int or :class:`None`\n                //:param end: position after last track to shuffle\n                //:type end: int or :class:`None`\n            shuffle(start?: number, end?: number) {\n                return this.commands.send(\"core.tracklist.shuffle\", {start, end});\n            },\n                //Returns a slice of the tracklist, limited by the given start and end\n                //positions.\n                //\n                //:param start: position of first track to include in slice\n                //:type start: int\n                //:param end: position after last track to include in slice\n                //:type end: int\n                //:rtype: :class:`mopidy.models.TlTrack`\n            slice(start: number, end: number) {\n                return this.commands.send(\"core.tracklist.slice\", {start, end});\n            },\n        },\n    }\n}\n","import models from \"../js/mopidy\";\r\nimport {validUri} from \"./functionsvars\";\r\nimport getState from \"./playerState\";\r\nimport {FileTrackModel, LibraryItem, NoneTrackModel, StreamTrackModel, TrackModel, ItemType} from \"./modelTypes\";\r\n\r\n// Stretch a value, e.g., between (0, 100), to a new range e.g., (-5, 100)\r\nfunction stretchLeft(x: number, min: number, max: number) {\r\n    return x*(max+min)/max - min;\r\n}\r\n\r\nexport function quadratic100(x: number) {\r\n    x = stretchLeft(x, -5, 100);\r\n    return (x * x) / 100;\r\n}\r\n\r\nexport function inverseQuadratic100(y: number) {\r\n    let x = Math.floor(Math.sqrt(y * 100));\r\n    return stretchLeft(x, 5, 100);\r\n}\r\n\r\n// noinspection JSUnusedLocalSymbols\r\nexport function cubic100(x: number) {\r\n    return (x * x * x) / 10000;\r\n}\r\n\r\nexport function numberedDictToArray<T>(dict: Object, converter?: (object: any) => T): T[] {\r\n    let length = dict[\"length\"];\r\n    let array: any[] = [];\r\n    for (let index = 0; index < length; index++) {\r\n        let line = dict[index.toString()];\r\n        array.push(line);\r\n    }\r\n    if (!converter)\r\n        return array;\r\n    return array.map(converter);\r\n}\r\n\r\nexport function getHostAndPort() {\r\n    let hostDefs = getHostAndPortDefs();\r\n    return hostDefs.altHost ?? hostDefs.host;\r\n}\r\n\r\nexport function getHostAndPortDefs() {\r\n    let altHostName = document.body.dataset.hostname;\r\n    if (altHostName.startsWith(\"{{\"))\r\n        altHostName = undefined;\r\n\r\n    if(!altHostName) {\r\n        altHostName = localStorage.getItem(\"eboplayer.hostName\");\r\n    }\r\n    return {host: document.location.host, altHost: altHostName};\r\n}\r\n\r\nexport function isStream(track: models.Track) {\r\n    return track?.track_no == undefined; //todo: this isn't waterproof. A track may NOT belong to an album and thus have no track_no\r\n}\r\n\r\nexport function transformTrackDataToModel(track: (models.Track)): FileTrackModel | StreamTrackModel {\r\n    if (isStream(track)) {\r\n        // noinspection UnnecessaryLocalVariableJS\r\n        let model: StreamTrackModel = {\r\n            type: ItemType.Stream,\r\n            track,\r\n            name: track.name,\r\n            infoLines: [],\r\n            imageUrl: undefined\r\n        };\r\n        return model;\r\n    }\r\n    //for now, assume it's a file track\r\n    let model: FileTrackModel = {\r\n        type: ItemType.File,\r\n        composer: \"\",\r\n        track,\r\n        title: track.name,\r\n        performer: \"\",\r\n        songlenght: 0,\r\n    };\r\n    if (!track.name || track.name === '') {\r\n        let parts = track.uri.split('/');\r\n        model.title = decodeURI(parts[parts.length - 1])\r\n    }\r\n\r\n    if (validUri(track.name)) {\r\n        for (let key in getState().streamUris) {\r\n            let rs = getState().streamUris[key]\r\n            if (rs && rs[1] === track.name) {\r\n                model.title = (rs[0] || rs[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!track.length || track.length === 0) {\r\n        model.songlenght = getState().songlength = Infinity;\r\n    } else {\r\n        model.songlenght = getState().songlength = track.length;\r\n    }\r\n\r\n    //todo: fetch the image, set it in the model and the model should send an event: eboplayer:imageLoaded with the id of the track\r\n    // images.fetchAlbumImage(track.uri, ['infocover', 'albumCoverImg'], getState().mopidy);\r\n\r\n    return model;\r\n}\r\n\r\nexport function console_yellow(msg: string) {\r\n    console.log(`%c${msg}`, 'background-color: yellow');\r\n}","import {Model} from \"../model\";\r\nimport {Commands} from \"../commands\";\r\nimport models from \"../../js/mopidy\";\r\nimport {EboPlayerDataType} from \"../views/view\";\r\nimport {Controller} from \"../controller\";\r\nimport {numberedDictToArray, quadratic100} from \"../global\";\r\nimport TlTrack = models.TlTrack;\r\nimport Ref = models.Ref;\r\nimport {AllUris, HistoryLine, ImageLookup, LibraryDict, PlaylistUri} from \"../modelTypes\";\r\nimport {SearchResult} from \"../refs\";\r\n\r\nexport class MopidyProxy {\r\n    private controller: Controller;\r\n    private model: Model;\r\n    private commands: Commands;\r\n\r\n    constructor(controller: Controller, model: Model, commands: Commands) {\r\n        this.controller = controller;\r\n        this.model = model;\r\n        this.commands = commands;\r\n    }\r\n\r\n    async fetchRootDirs() {\r\n        return this.browse(null);\r\n    }\r\n\r\n    //todo: this is a test function.\r\n    async fetchTracksforArtist() {\r\n        return await this.commands.core.library.search({artist: [\"Sting\"]}, null);\r\n    }\r\n\r\n    async playTracklistItem(tlid: number) {\r\n        await this.commands.core.playback.play(null, tlid);\r\n    }\r\n\r\n    async addTrackToTracklist(uri: string) {\r\n        return await this.commands.core.tracklist.add(null, null, [uri]);\r\n    }\r\n\r\n    async clearTrackList() {\r\n        await this.commands.core.tracklist.clear();\r\n    }\r\n\r\n    async browse<T extends AllUris>(uri: string) {\r\n        return await this.commands.core.library.browse(uri) as Ref<T>[];\r\n    }\r\n\r\n    async sendVolume(value: number) {\r\n        await this.commands.core.mixer.setVolume(value);\r\n    }\r\n\r\n    async sendStop() {\r\n        return this.commands.core.playback.stop();\r\n    }\r\n\r\n    async sendPause() {\r\n        return this.commands.core.playback.pause();\r\n    }\r\n\r\n    async sendPlay() {\r\n        return this.commands.core.playback.play();\r\n    }\r\n\r\n    async search(uri: string) {\r\n        return await this.commands.core.library.search({uri}, [], true) as SearchResult[];\r\n    }\r\n\r\n    async fetchRequiredData(dataType: EboPlayerDataType) {\r\n        switch (dataType) {\r\n            case EboPlayerDataType.Volume:\r\n                let volume = await this.commands.core.mixer.getVolume() as number;\r\n                this.controller.setVolume(volume);\r\n                break;\r\n            case  EboPlayerDataType.CurrentTrack:\r\n                let track = await this.commands.core.playback.getCurrentTlTrack() as TlTrack;\r\n                await this.controller.setCurrentTrackAndFetchDetails(track);\r\n                break;\r\n            case  EboPlayerDataType.PlayState:\r\n                let state = await this.commands.core.playback.getState() as string;\r\n                this.controller.setPlayState(state);\r\n                break;\r\n            case  EboPlayerDataType.TrackList:\r\n                await this.fetchTracklistAndDetails();\r\n                break;\r\n        }\r\n    }\r\n\r\n    async fetchTracks(uris: string | string[]) {\r\n        if (typeof uris == \"string\")\r\n            uris = [uris];\r\n        let dict: LibraryDict = await this.commands.core.library.lookup(uris);\r\n        return dict;\r\n    }\r\n\r\n    async fetchTracklistAndDetails() {\r\n        let tracks = await this.commands.core.tracklist.getTlTracks();\r\n        this.model.setTrackList(tracks);\r\n    }\r\n\r\n    async fetchHistory() {\r\n        let historyObject: Object = await this.commands.core.history.getHistory();\r\n        let historyLines = numberedDictToArray<HistoryLine>(historyObject, line => {\r\n            return {\r\n                timestamp: line[\"0\"],\r\n                ref: line[\"1\"]\r\n            };\r\n        });\r\n\r\n\r\n        //Make sure a stream is only listed once.\r\n        let foundStreams = new Set<string>();\r\n        let filtered = historyLines.filter(line => {\r\n            if (!line.ref.uri.startsWith(\"http:\"))\r\n                return true; //assume not a stream\r\n            if (foundStreams.has(line.ref.uri))\r\n                return false;\r\n            foundStreams.add(line.ref.uri);\r\n            return true;\r\n        });\r\n\r\n\r\n        let prev = {ref: {uri: \"\"}};\r\n        let dedupLines = filtered.filter((line) => {\r\n            if (line.ref.uri == prev.ref.uri)\r\n                return false;\r\n            prev = line;\r\n            return true;\r\n        });\r\n\r\n        this.model.setHistory(dedupLines);\r\n    }\r\n\r\n    fetchPlaybackOptions() {\r\n        let promises = [\r\n            this.commands.core.tracklist.getRepeat(),\r\n            this.commands.core.tracklist.getRandom(),\r\n            this.commands.core.tracklist.getConsume(),\r\n            this.commands.core.tracklist.getSingle(),\r\n        ];\r\n        Promise.all(promises).then((results) => {\r\n            this.model.setPlaybackState({\r\n                repeat: results[0],\r\n                random: results[1],\r\n                consume: results[2],\r\n                single: results[3]\r\n            });\r\n        })\r\n    }\r\n\r\n    async fetchCurrentTrackAndDetails() {\r\n        let currentTrack = await this.commands.core.playback.getCurrentTlTrack(); //todo: likely to result in null, as the track probably hasn't been started yet. Remoove this line?\r\n        await this.controller.setCurrentTrackAndFetchDetails(currentTrack);\r\n    }\r\n\r\n    async fetchPlayLists() {\r\n        return await this.commands.core.playlists.asList() as Ref<PlaylistUri>[];\r\n    }\r\n\r\n    async fetchPlaylistItems(uri: string) {\r\n        return await this.commands.core.playlists.getItems(uri) as Ref<AllUris>[];\r\n    }\r\n\r\n    async fetchImages(uris: string[]) {\r\n        return await this.commands.core.library.getImages(uris) as ImageLookup;\r\n    }\r\n}","import {BrowseFilterBreadCrumbStack, Model} from \"../model\";\r\nimport {jsonParse} from \"../functionsvars\";\r\nimport {AllUris, BreadCrumbBrowseFilter, BreadCrumbHome, BreadCrumbRef, BrowseFilter, FilterBreadCrumb} from \"../modelTypes\";\r\nimport {BreadCrumb, BreadCrumbStack} from \"../breadCrumb\";\r\nimport models from \"../../js/mopidy\";\r\nimport Ref = models.Ref;\r\n\r\nconst CURRENT_BROWSE_FILTERS__KEY = \"currentBrowseFilters\";\r\nconst BROWSE_FILTERS_BREADCRUMBS_KEY = \"browseFiltersBreadCrumbs\";\r\n\r\nexport class LocalStorageProxy {\r\n    private model: Model;\r\n\r\n    constructor(model: Model) {\r\n        this.model = model;\r\n    }\r\n\r\n    loadCurrentBrowseFilter() {\r\n        let browseFilterString = localStorage.getItem(CURRENT_BROWSE_FILTERS__KEY);\r\n        if (browseFilterString) {\r\n            let browseFilterObject = jsonParse(browseFilterString, this.model.getCurrentBrowseFilter());\r\n            let browseFilter = new BrowseFilter();\r\n            Object.assign(browseFilter, browseFilterObject);\r\n            this.model.setCurrentBrowseFilter(browseFilter);\r\n            return;\r\n        }\r\n        console.error(\"Could not load or parse browse filter bread crumbs from local storage. Using default bread crumbs.\");\r\n    }\r\n\r\n    loadBrowseFiltersBreadCrumbs() {\r\n        let breadCrumbsString = localStorage.getItem(BROWSE_FILTERS_BREADCRUMBS_KEY);\r\n        if (breadCrumbsString) {\r\n            let breadCrumbsArray = jsonParse(breadCrumbsString, this.model.getBreadCrumbs());\r\n            let breadCrumbs = new BrowseFilterBreadCrumbStack();\r\n            breadCrumbsArray\r\n                .map(crumb => {\r\n                    switch (crumb.type) {\r\n                        case \"browseFilter\": //todo: make this a const in BreadCrumbBrowseFilter\r\n                            let browseFilter = new BrowseFilter();\r\n                            Object.assign(browseFilter, crumb.data);\r\n                            return new BreadCrumbBrowseFilter(crumb.label, browseFilter);\r\n                        case \"ref\":\r\n                            return new BreadCrumbRef(crumb.label, crumb.data as Ref<AllUris>);\r\n                        case \"home\":\r\n                            return new BreadCrumbHome();\r\n                    }\r\n                })\r\n                .forEach(crumb =>\r\n                    breadCrumbs.push(crumb));\r\n            if(breadCrumbs.length == 0) {\r\n                breadCrumbs.push(new BreadCrumbHome());\r\n            }\r\n            else {\r\n                if (breadCrumbs[0].type != \"home\")\r\n                    breadCrumbs.unshift(new BreadCrumbHome());\r\n            }\r\n            this.model.setBrowseFilterBreadCrumbs(breadCrumbs);\r\n            return;\r\n        }\r\n        console.error(\"Could not load or parse browse filters from local storage. Using default filters.\");\r\n    }\r\n\r\n    saveCurrentBrowseFilter(browseFilter: BrowseFilter) {\r\n        let obj = JSON.stringify(browseFilter);\r\n        console.log(obj);\r\n        localStorage.setItem(CURRENT_BROWSE_FILTERS__KEY, obj);\r\n    }\r\n\r\n    saveBrowseFilterBreadCrumbs(breadCrumbs: BrowseFilterBreadCrumbStack) {\r\n        let obj = JSON.stringify(breadCrumbs);\r\n        console.log(obj);\r\n        localStorage.setItem(BROWSE_FILTERS_BREADCRUMBS_KEY, obj);\r\n    }\r\n\r\n}","import models from \"../js/mopidy\";\r\nimport Ref = models.Ref;\r\n\r\nimport {AlbumUri, AllUris, ArtistUri, BrowseFilter, GenreUri, PlaylistUri, RadioUri, TrackUri} from \"./modelTypes\";\r\nimport Track = models.Track;\r\nimport Artist = models.Artist;\r\n\r\nexport type RefType = \"album\" | \"artist\" | \"playlist\" | \"track\" | \"genre\" | \"radio\";\r\nexport interface TypedRef {\r\n    ref: Ref<AllUris>,\r\n    type: RefType\r\n}\r\n\r\nexport interface SearchResult {\r\n    ref: TypedRef;\r\n    weight: number;\r\n}\r\n\r\nexport interface SearchResults {\r\n    refs: SearchResult[];\r\n    availableRefTypes: Set<RefType>;\r\n}\r\n\r\nexport abstract class Refs {\r\n    searchResults: SearchResults;\r\n\r\n    get browseFilter(): BrowseFilter {\r\n        return this._browseFilter;\r\n    }\r\n\r\n    protected constructor() {\r\n        this.searchResults = { refs:[], availableRefTypes:new Set()};\r\n    }\r\n\r\n    set browseFilter(value: BrowseFilter) {\r\n        this._browseFilter = value;\r\n    }\r\n    private _browseFilter: BrowseFilter;\r\n\r\n    abstract filter(): void;\r\n\r\n    protected calculateWeight(result: SearchResult, browseFilter: BrowseFilter) {\r\n        if (result.ref.ref.name.toLowerCase().startsWith(browseFilter.searchText.toLowerCase()))\r\n            result.weight += 100;\r\n        if (result.ref.ref.name.toLowerCase().includes(browseFilter.searchText.toLowerCase()))\r\n            result.weight += 100;\r\n        if (!browseFilter.searchText)\r\n            result.weight += 1; //No search text? Give every result a weight of 1, so that they are always shown.\r\n    }\r\n\r\n    setFilter(browseFilter: BrowseFilter) {\r\n        this._browseFilter = browseFilter;\r\n    }\r\n\r\n    protected applyFilter(searchResults: SearchResult[]) {\r\n        searchResults.forEach(result => {\r\n            this.calculateWeight(result, this.browseFilter);\r\n        });\r\n        return searchResults\r\n            .filter(result => result.weight > 0)\r\n            .sort((a, b) => {\r\n                if (b.weight === a.weight) {\r\n                    return a.ref.ref.name.localeCompare(b.ref.ref.name);\r\n                }\r\n                return b.weight - a.weight\r\n            });\r\n    }\r\n\r\n    getSearchResults(): SearchResults {\r\n        return this.searchResults;\r\n    }\r\n\r\n    protected getAvailableRefTypes(refs: TypedRef[]) {\r\n        let distinctTypes = refs\r\n            .map(r => r.type)\r\n            .reduce((typeSet, val) => typeSet.add(val), new Set<RefType>());\r\n        console.log(distinctTypes);\r\n        return distinctTypes;\r\n    }\r\n}\r\n\r\nexport class AllRefs extends Refs {\r\n    roots: Ref<AllUris>[]; //todo: is DirectoryUri\r\n    sub: Ref<AllUris>[];\r\n    tracks: TypedRef[];\r\n    albums: TypedRef[];\r\n    artists: TypedRef[];\r\n    genres: TypedRef[];\r\n    radios: TypedRef[];\r\n    playlists: TypedRef[];\r\n    availableRefTypes: Set<RefType>;\r\n\r\n    constructor( roots: Ref<AllUris>[], sub: Ref<AllUris>[], tracks: Ref<TrackUri>[], albums: Ref<AlbumUri>[], artists: Ref<ArtistUri>[], genres: Ref<GenreUri>[], radios: Ref<RadioUri>[], playlists: Ref<PlaylistUri>[]) {\r\n        super();\r\n        this.roots = roots;\r\n        this.sub = sub;\r\n        this.tracks = tracks.map(track => ({type: \"track\" as RefType, ref: track}));\r\n        this.albums = albums.map(album => ({type: \"album\" as RefType, ref: album}));\r\n        this.artists = artists.map(artist => ({type: \"artist\" as RefType, ref: artist}));\r\n        this.genres = genres.map(genre => ({type: \"genre\" as RefType, ref: genre}));\r\n        this.radios = radios.map(radio => ({type: \"radio\" as RefType, ref: radio}));\r\n        this.playlists = playlists.map(album => ({type: \"playlist\" as RefType, ref: album}));\r\n        this.availableRefTypes = new Set();\r\n        this.getAvailableRefTypes(this.tracks).forEach(type => this.availableRefTypes.add(type));\r\n        this.getAvailableRefTypes(this.albums).forEach(type => this.availableRefTypes.add(type));\r\n        this.getAvailableRefTypes(this.artists).forEach(type => this.availableRefTypes.add(type));\r\n        this.getAvailableRefTypes(this.genres).forEach(type => this.availableRefTypes.add(type));\r\n        this.getAvailableRefTypes(this.radios).forEach(type => this.availableRefTypes.add(type));\r\n        this.getAvailableRefTypes(this.playlists).forEach(type => this.availableRefTypes.add(type));\r\n    }\r\n\r\n    filter() {\r\n        this.searchResults = {\r\n            refs: this.applyFilter(this.prefillWithTypes(this.browseFilter)),\r\n            availableRefTypes: this.availableRefTypes\r\n        };\r\n    }\r\n\r\n    private prefillWithTypes(browseFilter: BrowseFilter): SearchResult[] {\r\n        let refs: SearchResult[] =  [];\r\n        if(browseFilter.album || browseFilter.isNoTypeSelected())\r\n            refs.push(...this.albums.map(ref => ({ref, weight: 0})));\r\n        if(browseFilter.artist || browseFilter.isNoTypeSelected())\r\n            refs.push(...this.artists.map(ref => ({ref, weight: 0})));\r\n        if(browseFilter.track || browseFilter.isNoTypeSelected())\r\n            refs.push(...this.tracks.map(ref => ({ref, weight: 0})));\r\n        if(browseFilter.genre || browseFilter.isNoTypeSelected())\r\n            refs.push(...this.genres.map(ref => ({ref, weight: 0})));\r\n        if(browseFilter.radio || browseFilter.isNoTypeSelected())\r\n            refs.push(...this.radios.map(ref => ({ref, weight: 0})));\r\n        if(browseFilter.playlist || browseFilter.isNoTypeSelected())\r\n            refs.push(...this.playlists.map(ref => ({ref, weight: 0})));\r\n        return refs;\r\n    }\r\n}\r\n\r\nexport class SomeRefs extends Refs {\r\n    refs: TypedRef[];\r\n    availableRefTypes: Set<RefType>\r\n\r\n    constructor(refs: Ref<AllUris>[]) {\r\n        super();\r\n        this.refs = refs.map(r => {\r\n            return {ref: r, type: SomeRefs.toRefType(r)};\r\n        });\r\n        this.availableRefTypes = this.getAvailableRefTypes(this.refs);\r\n    }\r\n\r\n    static toRefType(ref: models.Ref<AllUris>): RefType {\r\n        if(![\"directory\", \"track\"].includes(ref.type)) {\r\n            return ref.type as RefType;\r\n        }\r\n        if(ref.uri.startsWith(\"eboback:stream:\"))\r\n            return \"radio\";\r\n        if(ref.uri.startsWith(\"eboback:directory?genre\"))\r\n            return \"genre\";\r\n        return ref.type as RefType; //WARNING: this really is an unknown type!\r\n    }\r\n\r\n    filter() {\r\n        this.searchResults = {\r\n            refs: this.applyFilter(this.refs.map(ref => ({ref: ref, weight: 0}))),\r\n            availableRefTypes: this.availableRefTypes\r\n        };\r\n    }\r\n}","import {Model} from \"../model\";\r\nimport {EboPlayerDataType} from \"../views/view\";\r\nimport {getHostAndPort} from \"../global\";\r\nimport {AlbumMetaData, NoStreamTitles} from \"../modelTypes\";\r\n\r\nexport class WebProxy {\r\n    private model: Model;\r\n\r\n    constructor(model: Model) {\r\n        this.model = model;\r\n    }\r\n\r\n    async fetchRequiredData(dataType: EboPlayerDataType) {\r\n        switch (dataType) {\r\n            case  EboPlayerDataType.StreamLines:\r\n                await this.fetchActiveStreamLines();\r\n                break;\r\n        }\r\n    }\r\n\r\n    async fetchActiveStreamLines() {\r\n        if (!this.model.currentTrack) {\r\n            this.model.setActiveStreamLinesHistory(NoStreamTitles);\r\n            return;\r\n        }\r\n\r\n        let url = new URL(`http://${getHostAndPort()}/eboplayer2/stream/activeLines`);\r\n        url.searchParams.set(\"uri\", this.model.currentTrack);\r\n        let res = await fetch(url);\r\n        let lines = await res.json();\r\n        this.model.setActiveStreamLinesHistory(lines);\r\n    }\r\n\r\n    async fetchAllStreamLines(uri: string) {\r\n        let url = new URL(`http://${getHostAndPort()}/eboplayer2/stream/allLines`);\r\n        url.searchParams.set(\"uri\", uri);\r\n        let res = await fetch(url);\r\n        return await res.json() as string[];\r\n    }\r\n\r\n    async fetchMetaData(albumUri: string) {\r\n        let url = new URL(`http://${getHostAndPort()}/eboback/data/get_album_meta`);\r\n        url.searchParams.set(\"uri\", albumUri);\r\n        let res = await fetch(url);\r\n        let text = await res.text();\r\n        if(text)\r\n            return JSON.parse(text) as AlbumMetaData;\r\n        return null;\r\n    }\r\n}","import getState from \"./playerState\";\r\nimport {showLoading} from \"./functionsvars\";\r\nimport {library} from \"./library\";\r\nimport {transformTlTrackDataToModel} from \"./process_ws\";\r\nimport {Model} from \"./model\";\r\nimport {Commands} from \"./commands\";\r\nimport models, {Mopidy} from \"../js/mopidy\";\r\nimport {EboPlayerDataType} from \"./views/view\";\r\nimport {DataRequester} from \"./views/dataRequester\";\r\nimport {MopidyProxy} from \"./proxies/mopidyProxy\";\r\nimport {LocalStorageProxy} from \"./proxies/localStorageProxy\";\r\nimport {getHostAndPortDefs, numberedDictToArray, transformTrackDataToModel} from \"./global\";\r\nimport {AllRefs, SomeRefs} from \"./refs\";\r\nimport {AlbumModel, AlbumUri, AllUris, ArtistUri, BreadCrumbBrowseFilter, BreadCrumbHome, BreadCrumbRef, BrowseFilter, ConnectionState, ExpandedAlbumModel, ExpandedFileTrackModel, ExpandedStreamModel, FileTrackModel, GenreUri, isBreadCrumbForAlbum, isBreadCrumbForArtist, ItemType, NoStreamTitles, PlayState, RadioUri, StreamTitles, StreamTrackModel, TrackModel, TrackNone, TrackUri, Views} from \"./modelTypes\";\r\nimport {JsonRpcController} from \"./jsonRpcController\";\r\nimport {WebProxy} from \"./proxies/webProxy\";\r\nimport {EboplayerEvents} from \"./events\";\r\nimport TlTrack = models.TlTrack;\r\nimport Ref = models.Ref;\r\n\r\nexport const LIBRARY_PROTOCOL = \"eboback:\";\r\n\r\n//The controller updates the model and has functions called by the views.\r\n//The controller does not update the views directly.\r\n//The controller should not listen to model events, to avoid circular updates (dead loops).\r\nexport class Controller extends Commands implements DataRequester{\r\n    protected model: Model;\r\n    public mopidyProxy: MopidyProxy;\r\n    public webProxy: WebProxy;\r\n    public localStorageProxy: LocalStorageProxy;\r\n    private eboWebSocketCtrl: JsonRpcController;\r\n    readonly baseUrl: string;\r\n    readonly DEFAULT_IMG_URL = \"images/default_cover.png\";\r\n\r\n    constructor(model: Model, mopidy: Mopidy, eboWebSocketCtrl: JsonRpcController) {\r\n        super(mopidy);\r\n        this.model  = model;\r\n        this.mopidyProxy = new MopidyProxy(this, model, new Commands(mopidy));\r\n        this.webProxy = new WebProxy(model);\r\n        this.localStorageProxy = new LocalStorageProxy(model);\r\n        this.eboWebSocketCtrl = eboWebSocketCtrl;\r\n        let portDefs = getHostAndPortDefs();\r\n        this.baseUrl = \"\";\r\n        if(portDefs.altHost && portDefs.altHost != portDefs.host)\r\n            this.baseUrl = \"http://\"+portDefs.altHost;\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.CurrentTrack];\r\n    }\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[] {\r\n        return this.getRequiredDataTypes();\r\n    }\r\n\r\n    initSocketevents () {\r\n        this.mopidy.on('state:online', async () => {\r\n            this.model.setConnectionState(ConnectionState.Online);\r\n            await getState().getRequiredData();\r\n            await this.mopidyProxy.fetchHistory();\r\n        });\r\n\r\n        this.mopidy.on('state:offline', () => {\r\n            this.model.setConnectionState(ConnectionState.Offline);\r\n        });\r\n\r\n        this.mopidy.on('event:optionsChanged', this.mopidyProxy.fetchPlaybackOptions);\r\n\r\n        this.mopidy.on('event:trackPlaybackStarted', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n        });\r\n\r\n        this.mopidy.on('event:trackPlaybackEnded', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n            this.setPlayState(\"stopped\"); //don't rely solely on the state changes!\r\n        });\r\n\r\n        this.mopidy.on('event:trackPlaybackResumed', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n        });\r\n\r\n        this.mopidy.on('event:playlistsLoaded', ()  => {\r\n            showLoading(true);\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:playlistChanged', (data) => {\r\n            delete getState().playlists[data.playlist.uri];\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:playlistDeleted', (data) => {\r\n            delete getState().playlists[data.uri];\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:volumeChanged', (data) => {\r\n            this.model.setVolume(data.volume);\r\n        });\r\n\r\n        this.mopidy.on('event:muteChanged', (_data) => {\r\n        });\r\n\r\n        this.mopidy.on('event:playbackStateChanged', async (data) => {\r\n            await this.onPlaybackStateChanged(data);\r\n        });\r\n\r\n        this.mopidy.on('event:tracklistChanged', async () => {\r\n            await this.mopidyProxy.fetchTracklistAndDetails();\r\n            await this.mopidyProxy.fetchCurrentTrackAndDetails();\r\n        });\r\n\r\n        this.mopidy.on('event:seeked', () => {\r\n            // controls.setPosition(data.time_position);\r\n            if (getState().play) {\r\n                getState().syncedProgressTimer.start();\r\n            }\r\n        });\r\n\r\n        //log all events:\r\n        this.mopidy.on((data) => {\r\n            if(data instanceof MessageEvent) {\r\n                try {\r\n                    let dataObject = JSON.parse(data.data);\r\n                    if((dataObject.event ?? \"\") == \"stream_title_changed\")\r\n                        return;\r\n                } catch (e) {} //not valid json.\r\n            }\r\n            if(typeof(data) == \"object\") {\r\n                if((data.title && Object.keys(data).length) == 1)\r\n                    return;\r\n            }\r\n            if(data instanceof Array) {\r\n                if (data.length && data[0] == \"event:streamTitleChanged\")\r\n                    return;\r\n            }\r\n            console.log(data);\r\n        });\r\n        this.eboWebSocketCtrl.on(\"event:streamHistoryChanged\", (data) => {\r\n            let streamTitles: StreamTitles = data.data;\r\n            this.model.setActiveStreamLinesHistory(streamTitles);\r\n        });\r\n        this.model.addEventListener(EboplayerEvents.playStateChanged, async () => {\r\n            await this.updateStreamLines();\r\n        });\r\n\r\n    }\r\n\r\n    private async onPlaybackStateChanged(data) {\r\n        getState().getController().setPlayState(data.new_state);\r\n        await this.updateStreamLines();\r\n    }\r\n\r\n    async setCurrentTrackAndFetchDetails(data: (TlTrack | null)) {\r\n        if(!data) {\r\n            this.model.setCurrentTrack(TrackNone);\r\n            return;\r\n        }\r\n        let trackModel = await this.lookupTrackCached(data.track.uri);\r\n        this.model.setCurrentTrack(trackModel);\r\n        if(!this.model.selectedTrack)\r\n            this.model.setSelectedTrack(trackModel.track.uri);\r\n        await this.updateStreamLines();\r\n\r\n        //todo: do this only when a track is started?s\r\n        // this.core.playback.getTimePosition().then(processCurrentposition, console.error)\r\n        // this.core.playback.getState().then(processPlaystate, console.error)\r\n        // this.core.mixer.getMute().then(processMute, console.error)\r\n    }\r\n\r\n    private async updateStreamLines() {\r\n        if (this.model.getPlayState() == \"playing\")\r\n            await this.webProxy.fetchActiveStreamLines();\r\n        else\r\n            this.model.setActiveStreamLinesHistory(NoStreamTitles);\r\n    }\r\n\r\n    private async fetchLargestImageOrDefault(uri: string) {\r\n        let images = await this.mopidyProxy.fetchImages([uri]);\r\n        let arr = images[uri];\r\n        arr.sort((imgA, imgB) => (imgA.width * imgA.height) - (imgB.width * imgB.height));\r\n        if(arr.length == 0)\r\n            return this.DEFAULT_IMG_URL;\r\n        let imageUrl = arr.pop().uri;\r\n        if(imageUrl == \"\")\r\n             imageUrl = this.DEFAULT_IMG_URL;\r\n        return this.baseUrl + imageUrl;\r\n    }\r\n\r\n    setVolume(volume: number) {\r\n        this.model.setVolume(volume);\r\n    }\r\n\r\n    setPlayState(state: string) {\r\n        this.model.setPlayState(state as PlayState);\r\n    }\r\n\r\n    setTracklist(trackList: TlTrack[]) {\r\n        this.model.setTrackList(trackList);\r\n    }\r\n\r\n    setAndSaveBrowseFilter(filter: BrowseFilter) {\r\n        this.localStorageProxy.saveCurrentBrowseFilter(filter);\r\n        this.model.setCurrentBrowseFilter(filter);\r\n        this.filterBrowseResults();\r\n    }\r\n\r\n    diveIntoBrowseResult(label: string, uri: AllUris, type: string, addTextFilterBreadcrumb: boolean) {\r\n        if(type == \"track\"  ||  type  == \"radio\") {\r\n            return; //don't dive.\r\n        }\r\n\r\n        if(type == \"album\") {\r\n            getState().getController().getExpandedAlbumModel(uri as AlbumUri).then(() => { //fetch before changing view, to avoid flicker.\r\n                this.model.setAlbumToView(uri as AlbumUri);\r\n                this.setView(Views.Album);\r\n            })\r\n        }\r\n\r\n        // set 2 new breadCrumbs and a new browseFilter.\r\n        // > setting the browseFilter should only trigger a view update. NOT a re-filter!!!\r\n        if(addTextFilterBreadcrumb) {\r\n            let browseFilter = this.model.getCurrentBrowseFilter();\r\n            let breadCrumb1 = new BreadCrumbBrowseFilter(browseFilter.searchText, browseFilter);\r\n            this.model.pushBreadCrumb(breadCrumb1);\r\n        }\r\n        let ref: Ref<AllUris> = {type: type as models.ModelType, name: label, uri};\r\n        let breadCrumb2 = new BreadCrumbRef(label, ref);\r\n        this.model.pushBreadCrumb(breadCrumb2);\r\n\r\n        this.localStorageProxy.saveBrowseFilterBreadCrumbs(this.model.getBreadCrumbs());\r\n\r\n        let newBrowseFilter = new BrowseFilter();\r\n        //for each type, we dive into the next level of type. E.g., artist -> album -> track.\r\n        switch (type) {\r\n            case \"artist\": newBrowseFilter.album = true; break;\r\n            case \"genre\":\r\n                newBrowseFilter.radio = true;\r\n                newBrowseFilter.playlist = true;\r\n                newBrowseFilter.artist = true;\r\n                newBrowseFilter.album = true;\r\n                newBrowseFilter.track = true;\r\n                newBrowseFilter.genre = true;\r\n                break;\r\n            case \"playlist\":\r\n                newBrowseFilter.playlist = true;\r\n                newBrowseFilter.artist = true;\r\n                newBrowseFilter.album = true;\r\n                newBrowseFilter.track = true;\r\n                break;\r\n        }\r\n        this.setAndSaveBrowseFilter(newBrowseFilter);\r\n\r\n        this.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n            this.filterBrowseResults();\r\n        });\r\n    }\r\n\r\n    resetToBreadCrumb(id: number) {\r\n        let breadCrumb = getState().getModel().getBreadCrumbs().get(id);\r\n        let breadCrumbs = getState().getModel().getBreadCrumbs();\r\n\r\n        //if the breadCrumb is a browseFilter, reset to the previous breadCrumb and set the current browseFilter to the one in the breadCrumb.\r\n        if(breadCrumb instanceof BreadCrumbBrowseFilter) {\r\n            this.model.resetBreadCrumbsTo(id);\r\n            let browseFilter = this.model.popBreadCrumb().data as BrowseFilter;\r\n            this.setAndSaveBrowseFilter(browseFilter);\r\n            this.localStorageProxy.saveBrowseFilterBreadCrumbs(breadCrumbs);\r\n            this.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n                this.filterBrowseResults();\r\n            });\r\n        } else if(breadCrumb instanceof BreadCrumbRef) {\r\n            if(isBreadCrumbForArtist(breadCrumb)) {\r\n                this.model.resetBreadCrumbsTo(id);\r\n                this.model.popBreadCrumb(); // remove the artist breadCrumb as it will be added again below.\r\n                this.diveIntoBrowseResult(breadCrumb.label, breadCrumb.data.uri, breadCrumb.data.type, false);\r\n            } else if(isBreadCrumbForAlbum(breadCrumb)) {\r\n                this.model.setAlbumToView(breadCrumb.data.uri);\r\n                this.setView(Views.Album);\r\n            }\r\n        } else if (breadCrumb instanceof BreadCrumbHome) {\r\n            this.model.resetBreadCrumbsTo(id);\r\n            this.setAndSaveBrowseFilter(new BrowseFilter());\r\n            this.localStorageProxy.saveBrowseFilterBreadCrumbs(breadCrumbs);\r\n            this.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n                this.filterBrowseResults();\r\n            });\r\n        }\r\n    }\r\n\r\n    async lookupTrackCached(trackUri: string) {\r\n        let item = this.model.getFromLibraryCache(trackUri);\r\n        if(item)\r\n            return item as FileTrackModel | StreamTrackModel;\r\n\r\n        let libraryList = await this.fetchAndConvertTracks(trackUri);\r\n        this.model.addItemsToLibraryCache(libraryList);\r\n        return this.model.getFromLibraryCache(trackUri) as FileTrackModel | StreamTrackModel | undefined; //assuming the trackUri points to a file or a stream.\r\n    }\r\n\r\n    async lookupAlbumCached(albumUri: AlbumUri) {\r\n        let item = this.model.getFromLibraryCache(albumUri);\r\n        if(item)\r\n            return item as AlbumModel; //assuming the albumUri points to an album.\r\n        return await this.fetchAlbum(albumUri);\r\n    }\r\n\r\n    private async fetchAlbum(albumUri: string) {\r\n        let dict = await this.mopidyProxy.fetchTracks(albumUri);\r\n        let trackList = dict[albumUri] as models.Track[];\r\n        let albumModel: AlbumModel = {\r\n            type: ItemType.Album,\r\n            albumInfo: trackList[0].album,\r\n            tracks: trackList.map(track => track.uri),\r\n            imageUrl: await this.fetchLargestImageOrDefault(albumUri)\r\n        }\r\n        this.model.addItemsToLibraryCache([albumModel]);\r\n        return albumModel;\r\n    }\r\n\r\n    private async fetchAndConvertTracks(uri: string) {\r\n        let dict = await this.mopidyProxy.fetchTracks(uri);\r\n        let trackList = dict[uri] as models.Track[];\r\n        let newListPromises = trackList.map(async track => {\r\n            let model = transformTrackDataToModel(track);\r\n            if(model.type == ItemType.Stream) {\r\n                let images = await this.mopidyProxy.fetchImages([track.uri]);\r\n                if(images[track.uri].length > 0)\r\n                    model.imageUrl = this.baseUrl + images[track.uri][0].uri;\r\n                else\r\n                    model.imageUrl = this.DEFAULT_IMG_URL;\r\n            }\r\n            return model;\r\n        });\r\n        return await Promise.all(newListPromises);\r\n    }\r\n\r\n    async getExpandedTrackModel(trackUri: string): Promise<ExpandedStreamModel | ExpandedFileTrackModel>{\r\n        let track = await this.lookupTrackCached(trackUri);\r\n        if(track.type == ItemType.Stream) {\r\n            let streamLines = await this.fetchStreamLines(trackUri);\r\n            // noinspection UnnecessaryLocalVariableJS\r\n            let streamModel: ExpandedStreamModel = {\r\n                stream: track,\r\n                historyLines: streamLines,\r\n            };\r\n            return streamModel;\r\n        } else {\r\n            let album = await this.lookupAlbumCached(track.track.album.uri);\r\n            return {track, album};\r\n        }\r\n    }\r\n\r\n    async getExpandedAlbumModel(albumUri: AlbumUri): Promise<ExpandedAlbumModel> {\r\n        let album = await this.lookupAlbumCached(albumUri) as AlbumModel;\r\n        let meta = await this.getMetaDataCached(albumUri);\r\n        let tracks = await Promise.all(album.tracks.map(trackUri => this.lookupTrackCached(trackUri) as Promise<FileTrackModel>));\r\n        return {album, tracks, meta};\r\n    }\r\n\r\n    async getMetaDataCached(albumUri: string) {\r\n        let cachedMeta = this.model.getFromMetaCache(albumUri);\r\n        if(cachedMeta)\r\n            return cachedMeta.meta;\r\n        let meta = await this.webProxy.fetchMetaData(albumUri);\r\n        this.model.addToMetaCache(albumUri, meta);\r\n        return meta;\r\n    }\r\n\r\n    async clearListAndPlay(uri: string) {\r\n        await this.mopidyProxy.clearTrackList();\r\n        let trackList = await this.addToPlaylist(uri);\r\n        // noinspection ES6MissingAwait\r\n        this.play(trackList[0].tlid);\r\n    }\r\n\r\n    async play(tlid: number) {\r\n        // noinspection ES6MissingAwait\r\n        this.mopidyProxy.playTracklistItem(tlid);\r\n    }\r\n\r\n    private async addToPlaylist(uri: string) {\r\n        let tracks = await this.mopidyProxy.addTrackToTracklist(uri);\r\n        let trackList = numberedDictToArray(tracks) as models.TlTrack[];\r\n        this.setTracklist(trackList);\r\n        return trackList;\r\n    }\r\n\r\n    setSelectedTrack(uri: string) {\r\n        this.model.setSelectedTrack(uri);\r\n    }\r\n\r\n    async getCurrertTrackInfoCached() {\r\n        let trackUri = this.model.getCurrentTrack();\r\n        if(!trackUri)\r\n            return TrackNone;\r\n        return await this.lookupTrackCached(trackUri) as TrackModel;\r\n    }\r\n\r\n\r\n    async fetchAllRefs() {\r\n        let roots = await this.mopidyProxy.fetchRootDirs();\r\n        let subDir1 = await this.mopidyProxy.browse<AllUris>(roots[1].uri);\r\n        let allTracks = await this.mopidyProxy.browse<TrackUri>(LIBRARY_PROTOCOL+\"directory?type=track\");\r\n        let allAlbums = await this.mopidyProxy.browse<AlbumUri>(LIBRARY_PROTOCOL+\"directory?type=album\");\r\n        let allArtists = await this.mopidyProxy.browse<ArtistUri>(LIBRARY_PROTOCOL+\"directory?type=artist\");\r\n        let allGenres = await this.mopidyProxy.browse<GenreUri>(LIBRARY_PROTOCOL+\"directory?type=genre\");\r\n        let playLists = await this.mopidyProxy.fetchPlayLists();\r\n        let radioStreamsPlayList = playLists.find(playlist => playlist.name == \"[Radio Streams]\");\r\n        let playlists = playLists.filter(playlist => playlist.name != \"[Radio Streams]\");\r\n        let radioStreams: models.Ref<RadioUri>[];\r\n        if(radioStreamsPlayList) {\r\n            radioStreams = await this.mopidyProxy.fetchPlaylistItems(radioStreamsPlayList.uri) as models.Ref<RadioUri>[];\r\n        }\r\n\r\n        return new AllRefs(roots, subDir1, allTracks, allAlbums, allArtists, allGenres, radioStreams, playlists);\r\n    }\r\n\r\n    filterBrowseResults() {\r\n        this.model.filterCurrentRefs();\r\n    }\r\n\r\n    async fetchRefsForCurrentBreadCrumbs() {\r\n        let breadCrumbs = this.model.getBreadCrumbs();\r\n        let lastCrumb = breadCrumbs.getLast();\r\n        if(!lastCrumb) {\r\n            await this.setAllRefsAsCurrent();\r\n            return;\r\n        }\r\n\r\n        if(lastCrumb instanceof BreadCrumbHome) {\r\n            await this.setAllRefsAsCurrent();\r\n            return;\r\n        }\r\n\r\n        if(lastCrumb instanceof BreadCrumbBrowseFilter) {\r\n            await this.setAllRefsAsCurrent();\r\n            return;\r\n        }\r\n\r\n        if(lastCrumb instanceof BreadCrumbRef) {\r\n            if(lastCrumb.data.type == \"playlist\") {\r\n                let playlistItems = await this.mopidyProxy.fetchPlaylistItems(lastCrumb.data.uri);\r\n                playlistItems.forEach(ref => {\r\n                    //\"local:track:Air/Moon%20Safari/01%20La%20Femme%20d%27Argent.wma\"\r\n\r\n                    if(!ref.name || ref.name == \"\") {\r\n                        ref.name = ref.uri\r\n                            .replace(LIBRARY_PROTOCOL + \"track:\", \"\")\r\n                            .replaceAll(\"%20\", \" \");\r\n                        //remove the last part of the uri, which is the file extension.\r\n                        ref.name = ref.name.split(\".\").slice(0, -1).join(\".\");\r\n                    }\r\n                });\r\n                this.model.setCurrentRefs(new SomeRefs(playlistItems));\r\n                return;\r\n            }\r\n\r\n            let refs = await this.mopidyProxy.browse(lastCrumb.data.uri);\r\n            this.model.setCurrentRefs(new SomeRefs(refs));\r\n            return;\r\n        }\r\n    }\r\n\r\n    private async setAllRefsAsCurrent() {\r\n        if (!this.model.getAllRefs()) {\r\n            let allRefs = await this.fetchAllRefs();\r\n            this.model.setAllRefs(allRefs);\r\n        }\r\n        this.model.setCurrentRefs(this.model.getAllRefs());\r\n    }\r\n\r\n    playUri(uri: string) {\r\n        this.clearListAndPlay(uri);\r\n    }\r\n\r\n    addUri(uri: string) {\r\n        this.addToPlaylist(uri);\r\n    }\r\n\r\n    async fetchAlbumDataForTrack(track: TrackModel) {\r\n        switch (track.type) {\r\n            case ItemType.File:\r\n                let albumUri = track.track.album.uri;\r\n                return await this.lookupAlbumCached(albumUri);\r\n        }\r\n    }\r\n\r\n    async fetchStreamLines(streamUri: string) {\r\n        let stream_lines = await this.webProxy.fetchAllStreamLines(streamUri);\r\n        let groupLines = function (grouped: string[][], line: string){ //todo: normal function declaration?\r\n            if(line == \"---\") {\r\n                grouped.push([]);\r\n                return grouped;\r\n            }\r\n            grouped[grouped.length-1].push(line);\r\n            return grouped;\r\n        }\r\n        return stream_lines\r\n            .reduce<string[][]>(groupLines, new Array([]))\r\n            .filter(lineGroup => lineGroup.length); // remove empty groups.\r\n    }\r\n\r\n    setView(view: Views) {\r\n        this.model.setView(view);\r\n    }\r\n\r\n    async fetchAllAlbums() {\r\n        //get all the albums.\r\n        //first refs:\r\n        let albumRefs = await this.mopidyProxy.browse(LIBRARY_PROTOCOL+\"directory?type=album\") as Ref<AlbumUri>[];\r\n        let albumsPromises = albumRefs.map(async ref => {\r\n            return await this.lookupAlbumCached(ref.uri);\r\n        });\r\n\r\n        let albums = await Promise.all(albumsPromises);\r\n\r\n        console.log(albums);\r\n    }\r\n}\r\n\r\n","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {isInstanceOfExpandedStreamModel, Views} from \"../modelTypes\";\r\nimport {MainView} from \"./mainView\";\r\nimport {EboButtonBar} from \"../components/eboButtonBarComp\";\r\nimport {console_yellow} from \"../global\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\nexport class ButtonBarView extends View {\r\n    private componentId: string;\r\n    private parent: MainView;\r\n\r\n    constructor(containerId: string, parent: MainView) {\r\n        super();\r\n        this.parent = parent;\r\n        this.componentId = containerId;\r\n    }\r\n\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.playStateChanged, () => {\r\n            this.onPlaybackStateChangegd();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, () => {\r\n            this.onSelectedTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.activeStreamLinesChanged, () => {\r\n            this.onActiveStreamLinesChanged();\r\n        });\r\n\r\n        //todo: capture img click in comp.\r\n        // document.getElementById(\"buttonBarImg\").onclick = () => {\r\n        //     this.onButtonBarImgClicked();\r\n        // }\r\n\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.addEventListener(EboplayerEvents.playPressed, () => {\r\n            this.playOrStopOrPause(EboplayerEvents.playPressed).then(r => {});\r\n        });\r\n        comp.addEventListener(EboplayerEvents.stopPressed, () => {\r\n            this.playOrStopOrPause(EboplayerEvents.stopPressed).then(r => {});\r\n        });\r\n        comp.addEventListener(EboplayerEvents.pausePressed, () => {\r\n            this.playOrStopOrPause(EboplayerEvents.pausePressed).then(r => {});\r\n        });\r\n        comp.addEventListener(EboplayerEvents.buttonBarAlbumImgClicked, () => {\r\n            this.onButtonBarImgClicked();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.volumeChanged, () => {\r\n            this.onVolumeChanged();\r\n        });\r\n        comp.addEventListener(EboplayerEvents.changingVolume, async (ev) => {\r\n            let value = parseInt((ev as CustomEvent).detail.volume);\r\n            await getState().getController().mopidyProxy.sendVolume(value);\r\n\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.viewChanged, () => {\r\n            this.showHideInfo();\r\n        });\r\n    }\r\n\r\n    private onVolumeChanged() {\r\n        let volume = getState().getModel().getVolume();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"volume\", volume.toString());\r\n\r\n    }\r\n\r\n    private async onPlaybackStateChangegd() {\r\n        let playState = getState().getModel().getPlayState();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"play_state\", playState);\r\n        await this.updateComponent();\r\n    }\r\n\r\n    private async onCurrentTrackChanged() {\r\n        await this.updateComponent();\r\n    }\r\n\r\n    private async onSelectedTrackChanged() {\r\n        await this.updateComponent();\r\n    }\r\n\r\n    private async updateComponent() {\r\n        let track = getState().getModel().getCurrentTrack();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        if (!track) {\r\n            comp.setAttribute(\"text\", \"\");\r\n            comp.setAttribute(\"allow_play\", \"false\");\r\n            comp.setAttribute(\"allow_prev\", \"false\");\r\n            comp.setAttribute(\"allow_next\", \"false\");\r\n            comp.setAttribute(\"image_url\", \"\");\r\n            comp.setAttribute(\"stop_or_pause\", \"stop\");\r\n        } else {\r\n            let trackModel = await getState().getController().getExpandedTrackModel(track);\r\n            if (isInstanceOfExpandedStreamModel(trackModel)) {\r\n                let active_titles = \"\";\r\n                let activeStreamLines = getState().getModel().getActiveStreamLines();\r\n                if (activeStreamLines)\r\n                    active_titles = activeStreamLines.active_titles.join(\"\\n\");\r\n                comp.setAttribute(\"text\", active_titles);\r\n                comp.setAttribute(\"allow_play\", \"true\");\r\n                comp.setAttribute(\"allow_prev\", \"false\");\r\n                comp.setAttribute(\"allow_next\", \"false\");\r\n                comp.setAttribute(\"image_url\", trackModel.stream.imageUrl);\r\n                comp.setAttribute(\"stop_or_pause\", \"stop\");\r\n            } else {\r\n                comp.setAttribute(\"text\", trackModel.track.track.name);\r\n                comp.setAttribute(\"allow_play\", \"true\");\r\n                comp.setAttribute(\"allow_prev\", \"false\");\r\n                comp.setAttribute(\"allow_next\", \"false\");\r\n                comp.setAttribute(\"image_url\", trackModel.album.imageUrl);\r\n                comp.setAttribute(\"stop_or_pause\", \"pause\");\r\n            }\r\n        }\r\n        this.showHideInfo();\r\n    }\r\n\r\n    private showHideInfo() {\r\n        let currentTrack = getState().getModel().getCurrentTrack();\r\n        let selectedTrack = getState().getModel().getSelectedTrack();\r\n        let currentView = getState().getModel().getView();\r\n        let show_info = false;\r\n        if(selectedTrack && currentTrack != selectedTrack)\r\n            show_info = true;\r\n        if(currentView != Views.NowPlaying)\r\n            show_info = true;\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"show_info\", show_info.toString());\r\n    }\r\n\r\n    private async playOrStopOrPause(event: EboplayerEvents) {\r\n        switch(event) {\r\n            case EboplayerEvents.playPressed:\r\n                await getState().getController().mopidyProxy.sendPlay();\r\n                break;\r\n            case EboplayerEvents.stopPressed:\r\n                await getState().getController().mopidyProxy.sendStop();\r\n                break;\r\n            case EboplayerEvents.pausePressed:\r\n                await getState().getController().mopidyProxy.sendPause();\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.PlayState, EboPlayerDataType.Volume];\r\n    }\r\n\r\n    private onButtonBarImgClicked() {\r\n        getState().getController().setSelectedTrack(getState().getModel().getCurrentTrack());\r\n        getState().getController().setView(Views.NowPlaying);\r\n    }\r\n\r\n    private onActiveStreamLinesChanged() {\r\n        let lines = getState().getModel().getActiveStreamLines();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"text\", lines.active_titles.join(\"\\n\"));\r\n    }\r\n}\r\n","export class Batching {\r\n    constructor(private task: () => void) {\r\n    }\r\n    private requested = false;\r\n\r\n    async schedule() {\r\n        if(!this.requested) {\r\n            this.requested = true;\r\n            // noinspection ES6RedundantAwait\r\n            this.requested = await false;\r\n            this.execute();\r\n        }\r\n    }\r\n\r\n    private execute() {\r\n        this.task();\r\n    }\r\n}\r\n","import {Batching} from \"../Batching\";\r\nimport {console_yellow} from \"../global\";\r\n\r\nexport interface HasName {\r\n    tagName: string;\r\n}\r\n\r\nexport abstract class EboComponent extends HTMLElement implements HasName {\r\n    get rendered(): boolean {\r\n        return this._rendered;\r\n    }\r\n    static globalCss: CSSStyleSheet[] = [];\r\n    static cssCache: Map<string, CSSStyleSheet> = new Map();\r\n    private shadow: ShadowRoot; //todo: make private and expose only in renderPrepared and updateWhenConnected.\r\n    protected styleTemplate?: HTMLTemplateElement;\r\n    protected divTemplate?: HTMLTemplateElement;\r\n    private connected = false;\r\n    private _rendered = false;\r\n    private static readonly NO_TAG_NAME: string = \"todo: override in subclass\";\r\n    static tagName: string = EboComponent.NO_TAG_NAME;\r\n    private renderBatching: Batching;\r\n    private updateBatching: Batching;\r\n    protected cssNeeded: string[] = [];\r\n\r\n    protected constructor(styleText: string, htmlText: string) {\r\n        super();\r\n        if(styleText) {\r\n            this.styleTemplate = document.createElement(\"template\");\r\n            this.styleTemplate.innerHTML = styleText;\r\n        }\r\n        if(htmlText) {\r\n            this.divTemplate = document.createElement(\"template\");\r\n            this.divTemplate.innerHTML = htmlText;\r\n        }\r\n        this.renderBatching = new Batching(this.doRender.bind(this));\r\n        this.updateBatching = new Batching(this.doUpdate.bind(this));\r\n    }\r\n        // noinspection JSUnusedGlobalSymbols\r\n    attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n        if(oldValue === newValue)\r\n            return;\r\n        this.attributeReallyChangedCallback(name, oldValue, newValue);\r\n    }\r\n\r\n    abstract attributeReallyChangedCallback(name: string, oldValue: string, newValue: string): void;\r\n\r\n    static setGlobalCss(text: string[]) {\r\n        this.globalCss = text.map(text => {\r\n            let css = new CSSStyleSheet();\r\n            css.replaceSync(text);\r\n            return css;\r\n        });\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n        this.shadow = this.attachShadow({mode: \"open\"});\r\n        this.fetchCssAndCache().then( () => {\r\n            this.connected = true;\r\n            this.onConnected();\r\n            this.requestRender();\r\n        });\r\n    }\r\n\r\n    private async fetchCssAndCache() {\r\n        let fetches: Promise<string>[] = [];\r\n        this.cssNeeded.forEach(url => {\r\n            if (!EboComponent.cssCache.has(url)) {\r\n                fetches.push(fetch(url).then(res => res.text()));\r\n            }\r\n        });\r\n\r\n        const texts = await Promise.all(fetches);\r\n        texts.forEach((text, i) => {\r\n            let css = new CSSStyleSheet();\r\n            css.replaceSync(text);\r\n            EboComponent.cssCache.set(this.cssNeeded[i], css);\r\n        });\r\n    }\r\n\r\n    onConnected(){}\r\n\r\n    requestUpdate() {\r\n        // noinspection JSIgnoredPromiseFromCall\r\n        this.updateBatching.schedule();\r\n    }\r\n    private doUpdate() { //todo: aad TS option `noImplicitOverride` and set `override` modifier where needed.\r\n        if (!this.connected)\r\n            return;\r\n        if (!this._rendered)\r\n            return;\r\n        this.update(this.shadow);\r\n    }\r\n\r\n    update(shadow: ShadowRoot): void {\r\n        //should be overridden by subclasses.\r\n    }\r\n\r\n    requestRender() {\r\n        // noinspection JSIgnoredPromiseFromCall\r\n        this.renderBatching.schedule();\r\n    }\r\n    private doRender() {\r\n        if(!this.shadow)\r\n            return;\r\n        this.shadow.innerHTML = \"\";\r\n        let css = [...EboComponent.globalCss];\r\n        css = css.concat(this.cssNeeded.map(name => EboComponent.cssCache.get(name)!));\r\n        this.shadow.adoptedStyleSheets = css;\r\n        if(this.styleTemplate)\r\n            this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        if(this.divTemplate)\r\n            this.shadow.appendChild(this.divTemplate.content.cloneNode(true));\r\n\r\n        this.render(this.shadow);\r\n        this._rendered = true;\r\n    }\r\n\r\n    abstract render(shadow: ShadowRoot): void;\r\n\r\n    getShadow(){\r\n        return this.shadow;\r\n    }\r\n\r\n    setClassFromBoolAttribute(el: HTMLElement, attName: string) {\r\n        if (this[attName] == true)\r\n            el.classList.add(attName);\r\n        else\r\n            el.classList.remove(attName);\r\n    }\r\n\r\n    static define(comp: new (...args: any[]) => EboComponent) {\r\n        // @ts-ignore\r\n        if((comp as typeof EboComponent).tagName == EboComponent.NO_TAG_NAME)\r\n            throw \"Component class should have tagName defined.\";\r\n        // @ts-ignore\r\n        customElements.define(comp.tagName, comp);\r\n    }\r\n\r\n    addShadowEventListener(id: string, type: string, listener: (this: HTMLElement, ev: MouseEvent) => any) {\r\n        this.shadow.getElementById(id).addEventListener(type, listener);\r\n    }\r\n}\r\n\r\n","import {EboComponent} from \"./EboComponent\";\r\n\r\nexport class EboProgressBar extends EboComponent {\r\n    static readonly tagName=  \"ebo-progressbar\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    private position: number = 51;\r\n    private min: number = 0;\r\n    private max: number = 100;\r\n    private active: boolean = false;\r\n    private button: boolean = true;\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n        .movingGradient {\r\n            background-color: #555;\r\n        }\r\n        .active .movingGradient {\r\n            --darkGradient: #555;\r\n            background: linear-gradient(to right, var(--darkGradient),\r\n            #2a84a5, var(--darkGradient), #ffffff,\r\n                var(--darkGradient), #ca497c, var(--darkGradient), #9e9c2d, var(--darkGradient), #ee7752, var(--darkGradient),\r\n                #2a84a5\r\n            );\r\n            background-size: 1100% 1100%;  /*Must be a multiple of the number of colors above for a smooth transistion and the last color must be the first*/\r\n            animation: gradient 15s forwards infinite linear;\r\n            animation-timing-function: linear;\r\n            animation-direction: normal;\r\n        }\r\n        .button #button {\r\n                background-color: white;\r\n                width: 3px; \r\n                display: inline-block;\r\n                box-shadow: 0 0 5px white, 0 0 5px white,  0 0 5px white, 0 0 5px white, 0 0 15px white;\r\n        }\r\n        @keyframes gradient {\r\n            0% {\r\n                background-position: 0% 50%;\r\n            }\r\n            100% {\r\n                background-position: 100% 50%;\r\n            }\r\n        }\r\n        </style>\r\n    `;\r\n\r\n    static htmlText = `\r\n        <div style=\"\r\n            background-color: #444; \r\n            height: 1px; \r\n            display: flex; \r\n            \">\r\n            <div class=\"movingGradient\" style=\"\r\n                height: 1px;\r\n                display: inline-block;\">\r\n            </div>\r\n            <div id=\"button\"></div>\r\n        </div>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboProgressBar.styleText, EboProgressBar.htmlText);\r\n        this.requestRender();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"position\":\r\n            case \"min\":\r\n            case \"max\":\r\n                let test = parseInt(newValue);\r\n                if (isNaN(test))\r\n                    throw `\"${name}\" attribute should be a number. Current value: \"${newValue}\"`;\r\n                this[name] = test;\r\n                break;\r\n            case \"active\":\r\n            case \"button\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        if(!(this.min <= this.position && this.position <= this.max))\r\n            throw `Attribute position=\"${this.position}\" should be between min=\"${this.min}\" and max=\"${this.max}\".`;\r\n        this.requestRender();\r\n        }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n    }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        let percent = (this.position - this.min) / (this.max-this.min) * 100;\r\n        let styleElement = shadow.appendChild(document.createElement(\"style\"));\r\n        styleElement.innerHTML = `.movingGradient { width: ${percent}%; } `;\r\n        this.setClassFromBoolAttribute(shadow.firstElementChild as HTMLElement, \"button\");\r\n        this.setClassFromBoolAttribute(shadow.firstElementChild as HTMLElement, \"active\");\r\n    }\r\n\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport models from \"../../js/mopidy\";\r\nimport {transformTrackDataToModel} from \"../global\";\r\nimport {FileTrackModel, HistoryLine, StreamTrackModel, ItemType} from \"../modelTypes\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\nexport class TimelineView extends View {\r\n    private clickedRow: HTMLTableRowElement;\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.historyChanged, () => {\r\n            this.rebuildTimeline().then(r => {});\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.trackListChanged, () => {\r\n            this.rebuildTimeline().then(r => {});\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, () => {\r\n            this.onSelectedTrackChanged();\r\n        });\r\n    }\r\n\r\n\r\n    private async rebuildTimeline() {\r\n        let history = getState().getModel().getHistory() ?? [];\r\n        let trackList = getState().getModel().getTrackList() ?? [];\r\n\r\n        let timelineTable = document.getElementById(\"timelineTable\") as HTMLTableElement;\r\n        let body = timelineTable.tBodies[0];\r\n        body.innerHTML = \"\";\r\n\r\n        if(history.length > 0 && trackList.length > 0 && history[0].ref.uri == trackList[0].track.uri)\r\n            history.shift(); //remove most recent history line if it's the first track in the playlist.\r\n\r\n        // if we want to limit the number of history lines we can do so here.\r\n        // history = history.slice(0, 50);\r\n\r\n        let allLookups: Promise<void>[] = [];\r\n        //reverse order as we want the most recent tracks to at the bottom.\r\n        for(let i = history.length - 1; i >= 0; i-- ) {\r\n            allLookups.push(this.insertHistoryLine(history[i], body));\r\n        }\r\n\r\n        for(let track of trackList) {\r\n            allLookups.push(this.insertTrackLine(track.track.name, track.track.uri, body, [], track.tlid)); //todo: actually we already have the track info. No need for lookup.\r\n        }\r\n\r\n        Promise.all(allLookups).then(()=> {\r\n            this.setCurrentTrack();\r\n        });\r\n\r\n        body.querySelectorAll(\"tr\").forEach(tr => {\r\n            tr.addEventListener(\"dblclick\", ev => {this.onRowDoubleClicked(ev)});\r\n            tr.addEventListener(\"click\", ev => {this.onRowClicked(ev)});\r\n        });\r\n    }\r\n\r\n    private onRowClicked(ev: MouseEvent) {\r\n        let row = ev.currentTarget as HTMLTableRowElement;\r\n        this.setRowsClass(row, [\"clicked\"]);\r\n\r\n        getState().getController().setSelectedTrack(row.dataset.uri);\r\n    }\r\n\r\n    private async onRowDoubleClicked(ev: MouseEvent) {\r\n        this.clickedRow = ev.currentTarget as HTMLTableRowElement;\r\n        if(this.clickedRow.dataset.tlid)\r\n            await getState().getController().play(parseInt(this.clickedRow.dataset.tlid));\r\n        else\r\n            await getState().getController().clearListAndPlay(this.clickedRow.dataset.uri);\r\n    }\r\n\r\n    private setRowsClass(rowOrSelector: HTMLTableRowElement | string, classes: string[]) {\r\n        document\r\n            .getElementById(\"timelineTable\")\r\n            .querySelectorAll(`tr`)\r\n            .forEach(tr =>\r\n                tr.classList.remove(...classes)\r\n            );\r\n        if(rowOrSelector instanceof HTMLTableRowElement)\r\n            rowOrSelector.classList.add(...classes);\r\n        else {\r\n            document\r\n                .getElementById(\"timelineTable\")\r\n                .querySelectorAll(rowOrSelector)\r\n                .forEach(tr =>\r\n                    tr.classList.add(...classes)\r\n                );\r\n        }\r\n    }\r\n\r\n    private setSelectedTrack() {\r\n        let selectedTrackUri = getState().getModel().getSelectedTrack();\r\n        this.setRowsClass(`tr[data-uri=\"${selectedTrackUri}\"]`, [\"selected\"]);\r\n    }\r\n\r\n    private async setCurrentTrack() {\r\n        let timelineTable = document.getElementById(\"timelineTable\") as HTMLTableElement;\r\n        let currentTrack = await getState().getController().getCurrertTrackInfoCached();\r\n        if(!currentTrack)\r\n            return;\r\n        if (currentTrack.type == ItemType.None)\r\n            return; // don't clear the screen as this is probably temporary and will cause a flicker.\r\n        let currentUri = currentTrack.track.uri;\r\n        let trs = [...timelineTable.querySelectorAll(`tr[data-uri=\"${currentUri}\"]`)];\r\n        if(trs.length == 0)\r\n            return;\r\n        let tr = trs[trs.length - 1];\r\n        if(this.clickedRow?.dataset?.uri != currentTrack.track.uri)\r\n            tr.scrollIntoView( { block: \"nearest\" });\r\n        timelineTable.querySelectorAll(\"tr\").forEach(tr  => tr.classList.remove(\"current\", \"textGlow\"));\r\n        tr.classList.add(\"current\", \"textGlow\");\r\n    }\r\n\r\n    private async insertHistoryLine(line: HistoryLine, body: HTMLTableSectionElement) {\r\n        let slices = line.ref.name.split(\" - \");\r\n        let title = slices.pop();\r\n        await this.insertTrackLine(title, line.ref.uri, body, [\"historyLine\"]);\r\n    }\r\n\r\n    private async insertTrackLine(title: string, uri: string, body: HTMLTableSectionElement, classes: string[] = [], tlid?: number) {\r\n        let tr = document.createElement(\"tr\");\r\n        body.appendChild(tr);\r\n        tr.classList.add(\"trackLine\", ...classes);\r\n        tr.dataset.uri = uri;\r\n        if(tlid)\r\n            tr.dataset.tlid = tlid.toString();\r\n        this.setTrackLineContent(tr, title);\r\n        body.insertAdjacentHTML('beforeend', `\r\n<tr>\r\n    <td colspan=\"2\">\r\n        <div class=\"progressBar\"></div>\r\n    </td>\r\n</tr>\r\n            `);\r\n\r\n        //delayed update of track info.\r\n        const track = await getState().getController().lookupTrackCached(uri);\r\n        this.updateTrackLineFromLookup(tr, track, title);\r\n    }\r\n\r\n    private updateTrackLineFromLookup(tr: HTMLTableRowElement, track: (FileTrackModel | StreamTrackModel), title: string) {\r\n        let artist =  \"\";\r\n        let album =  \"\";\r\n        switch (track.type) {\r\n            case ItemType.File:\r\n                title = track.title;\r\n                artist = track.track.artists[0].name; //todo: add other names?\r\n                album = track.track.album.name;\r\n                break;\r\n            case ItemType.Stream:\r\n                title = track.name;\r\n                break;\r\n        }\r\n        this.setTrackLineContent(tr, title, artist, album);\r\n    }\r\n\r\n    private setTrackLineContent(tr: HTMLTableRowElement, title: string, artist: string = \"\", album: string = \"\") {\r\n        tr.innerHTML = `\r\n    <td>\r\n        <h1>${title}</h1>\r\n        <small>${artist}  ${album}</small>\r\n    </td>\r\n    <td>\r\n        <button><i class=\"fa fa fa-ellipsis-v\"></i></button>\r\n    </td>\r\n            `;\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.TrackList];\r\n    }\r\n\r\n    private onCurrentTrackChanged() {\r\n        this.setCurrentTrack();\r\n    }\r\n\r\n    private onSelectedTrackChanged() {\r\n        this.setSelectedTrack();\r\n    }\r\n\r\n}\r\n","import {EboComponent} from \"./EboComponent\";\r\nimport {AlbumData, AlbumDataType, AlbumNone} from \"../modelTypes\";\r\nimport {console_yellow} from \"../global\";\r\n\r\nexport class EboBigTrackComp extends EboComponent {\r\n    get albumInfo(): AlbumData {\r\n        return this._albumInfo;\r\n    }\r\n\r\n    set albumInfo(value: AlbumData) {\r\n        this._albumInfo = value;\r\n        this.requestRender();\r\n    }\r\n\r\n    static readonly tagName=  \"ebo-big-track-view\";\r\n    static progressBarAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"name\", \"stream_lines\", \"extra\", \"img\", \"disabled\", \"show_back\",\r\n        ...EboBigTrackComp.progressBarAttributes\r\n    ];\r\n    private name: string = \"\";\r\n    private stream_lines: string = \"\";\r\n    private extra: string = \"\";\r\n    private enabled: boolean = false;\r\n    private show_back: boolean = false;\r\n    //for progressBar\r\n    private position: string = \"40\";\r\n    private min: string = \"0\";\r\n    private max: string = \"100\";\r\n    private button: string = \"false\";\r\n    private active: string = \"true\";\r\n\r\n    private img: string  = \"\";\r\n    private albumClickEvent: CustomEvent<unknown>;\r\n    private _albumInfo: AlbumData = AlbumNone;\r\n\r\n    static styleText= `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                } \r\n                h3 {\r\n                    margin-block-start: .5em;\r\n                    margin-block-end: .5em;\r\n                }\r\n                .albumCoverContainer {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    /*align-content: center;*/\r\n                    overflow: hidden;\r\n                }\r\n                img {\r\n                    width: 100%;\r\n                    height: 100%;\r\n                    object-fit: contain;\r\n                    min-width: 200px;\r\n                    min-height: 200px;\r\n                    background-image: radial-gradient(circle, rgba(255,255,255, .5) 0%, transparent 100%);\r\n                }\r\n                ebo-progressbar {\r\n                    margin-top: .5em;\r\n                }\r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: row;\r\n                    height: 100%;\r\n                    width: 100%;\r\n                    #front {\r\n                        display: flex;\r\n                        flex-direction: column;\r\n                        width: 100%;\r\n                        align-items: center;\r\n                    }\r\n                }\r\n                #wrapper.front {\r\n                    #back {\r\n                        display: none;\r\n                    }                \r\n                }\r\n                .info {\r\n                    font-size: .7em;\r\n                }\r\n                ebo-album-tracks-view {\r\n                    height: 100%;\r\n                }\r\n            </style>\r\n        `;\r\n\r\n    // noinspection HtmlUnknownTarget\r\n    static htmlText = `\r\n            <div id=\"wrapper\" class=\"front\">\r\n                <div id=\"front\">\r\n                    <div class=\"albumCoverContainer\">\r\n                        <img id=\"image\" style=\"visibility: hidden\" src=\"\" alt=\"Album cover\"/>\r\n                        <ebo-progressbar position=\"40\" active=\"false\" button=\"false\"></ebo-progressbar>\r\n                    </div>\r\n        \r\n                    <div id=\"info\">\r\n                        <h3 id=\"albumTitle\" class=\"selectable\"></h3>\r\n                        <h3 id=\"name\" class=\"selectable\"></h3>\r\n                        <div id=\"stream_lines\" class=\"selectable info\"></div>\r\n                        <div id=\"extra\" class=\"selectable info\"></div>\r\n                    </div>\r\n                </div>\r\n            </div>        \r\n        `;\r\n\r\n    constructor() {\r\n        super(EboBigTrackComp.styleText, EboBigTrackComp.htmlText);\r\n        this.albumClickEvent = new CustomEvent(\"albumClick\", {\r\n            bubbles: true,\r\n            cancelable: false,\r\n            composed: true, //needed to 'break' out of the shadow.\r\n            detail: \"todo: tadaaa!\"\r\n        });\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        if(EboBigTrackComp.progressBarAttributes.includes(name)) {\r\n            this[name] = newValue;\r\n            this.getShadow().querySelector(\"ebo-progressbar\")?.setAttribute(name, newValue);\r\n            return;\r\n        }\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"stream_lines\":\r\n            case \"extra\":\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"enabled\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.requestRender();\r\n        }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        [\"name\", \"stream_lines\", \"extra\"].forEach(attName => {\r\n            shadow.getElementById(attName).innerHTML = this[attName];\r\n        });\r\n        let progressBarElement = shadow.querySelector(\"ebo-progressbar\") as HTMLElement;\r\n        //todo: try casting to EboProgressBar class and set attributes directly? Without re-rendering?\r\n        EboBigTrackComp.progressBarAttributes.forEach(attName => {\r\n            progressBarElement.setAttribute(attName, this[attName]);//todo: check if each of these causes a re-rendering.\r\n        });\r\n        let img = shadow.getElementById(\"image\") as HTMLImageElement;\r\n        img.src = this.img;\r\n        this.addShadowEventListener(\"image\",\"click\", (ev) => {\r\n            this.dispatchEvent(this.albumClickEvent);\r\n        });\r\n        this.requestUpdate();\r\n    }\r\n\r\n    override update(shadow:ShadowRoot) {\r\n        if(this.albumInfo.type == AlbumDataType.Loaded) {\r\n            shadow.getElementById(\"albumTitle\").textContent = this.albumInfo.album.albumInfo.name;\r\n        }\r\n        let img = shadow.getElementById(\"image\") as HTMLImageElement;\r\n        if(this.img != \"\") {\r\n            img.style.visibility = \"\";\r\n            img.src = this.img;\r\n        }\r\n        else {\r\n            img.style.visibility = \"hidden\";\r\n        }\r\n    }\r\n\r\n}","import {EboPlayerDataType, View} from \"./view\";\r\n\r\nexport class ComponentViewAdapter extends View {\r\n    protected componentId: string;\r\n\r\n    constructor(id: string) {\r\n        super();\r\n        this.componentId = id;\r\n    }\r\n\r\n    bind(): void {\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [];\r\n    }\r\n\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType} from \"./view\";\r\nimport {ComponentViewAdapter} from \"./componentViewAdapter\";\r\nimport {ExpandedFileTrackModel, ExpandedStreamModel, isInstanceOfExpandedStreamModel} from \"../modelTypes\";\r\nimport {EboBigTrackComp} from \"../components/eboBigTrackComp\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\nexport class BigTrackViewCurrentOrSelectedAdapter extends ComponentViewAdapter {\r\n    private streamLines: string;\r\n    private uri: string;\r\n\r\n    constructor(id: string) {\r\n        super(id);\r\n    }\r\n\r\n    bind() {\r\n        super.bind();\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, async () => {\r\n            this.onCurrentOrSelectedChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, async () => {\r\n            this.onCurrentOrSelectedChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.activeStreamLinesChanged, () => {\r\n            this.onStreamLinesChanged();\r\n        });\r\n    }\r\n\r\n    private onCurrentOrSelectedChanged() {\r\n        let currentTrackUri = getState().getModel().getCurrentTrack();\r\n        let selectedTrackUri = getState().getModel().getSelectedTrack();\r\n        this.setUri(selectedTrackUri ?? currentTrackUri);\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.CurrentTrack, EboPlayerDataType.TrackList, EboPlayerDataType.StreamLines, ...super.getRequiredDataTypes()];\r\n    }\r\n\r\n    protected onStreamLinesChanged() {\r\n        let selectedTrackUri = getState().getModel().getSelectedTrack();\r\n        let currentTrackUri = getState().getModel().getCurrentTrack();\r\n        this.streamLines = \"\";\r\n        if(selectedTrackUri == currentTrackUri) {\r\n            let linesObject = getState().getModel().getActiveStreamLines();\r\n            if (this.uri && linesObject?.uri == this.uri)\r\n                this.streamLines = linesObject.active_titles?.join(\"<br/>\") ?? \"\";\r\n        }\r\n        document.getElementById(this.componentId).setAttribute(\"stream_lines\", this.streamLines);\r\n    }\r\n\r\n    async setUri(uri: string) {\r\n        this.uri = uri;\r\n        let track = await getState().getController().getExpandedTrackModel(uri);\r\n        this.setComponentData(track);\r\n    }\r\n\r\n    protected setComponentData(track: ExpandedStreamModel | ExpandedFileTrackModel) {\r\n        let name = \"no current track\";\r\n        let info = \"\";\r\n        let position: string;\r\n        let button: string;\r\n        let imageUrl: string;\r\n        if(isInstanceOfExpandedStreamModel(track)) {\r\n            name = track.stream.name;\r\n            position = \"100\";\r\n            button = \"false\";\r\n            imageUrl = track.stream.imageUrl;\r\n        } else {\r\n            name = track.track.title;\r\n            info = track.album.albumInfo.name;\r\n            position = \"60\"; //todo: just a test\r\n            button = \"true\";\r\n            imageUrl = track.album.imageUrl;\r\n            let artists = track.track.track.artists.map(a => a.name).join(\", \");\r\n            let composers = track.track.track.composers?.map(c => c.name)?.join(\", \") ?? \"\";\r\n            if(artists)\r\n                info += \"<br>\" + artists;\r\n            if(composers)\r\n                info += \"<br>\" + composers;\r\n        }\r\n        let comp = document.getElementById(this.componentId) as EboBigTrackComp;\r\n        comp.setAttribute(\"name\", name);\r\n        comp.setAttribute(\"info\", info);\r\n        comp.setAttribute(\"position\", position);\r\n        comp.setAttribute(\"button\", button);\r\n        comp.setAttribute(\"img\", imageUrl);\r\n        this.onStreamLinesChanged();\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {ExpandedAlbumModel, ExpandedStreamModel} from \"../modelTypes\";\r\nimport {EboMenuButton} from \"./eboMenuButton\";\r\nimport {EboplayerEvent, EboplayerEvents, UriArgs} from \"../events\";\r\n\r\nexport class EboAlbumTracksComp extends EboComponent {\r\n    private _streamInfo?: ExpandedStreamModel;\r\n    get streamInfo(): ExpandedStreamModel {\r\n        return this._streamInfo;\r\n    }\r\n\r\n    set streamInfo(value: ExpandedStreamModel) {\r\n        this._streamInfo = value;\r\n        this.requestRender();\r\n    }\r\n    set activeTrackUri(value: string | null) {\r\n        this._activeTrackUri = value;\r\n        this.highLightActiveTrack();\r\n    }\r\n    get albumInfo() {\r\n        return this._albumInfo;\r\n    }\r\n\r\n    set albumInfo(value: ExpandedAlbumModel) {\r\n        this._albumInfo = value;\r\n        this.requestRender();\r\n    }\r\n\r\n    private _activeTrackUri: string | null = null;\r\n\r\n    static readonly tagName=  \"ebo-album-tracks-view\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"img\",\r\n    ];\r\n    private _albumInfo?: ExpandedAlbumModel;\r\n\r\n\r\n    constructor() {\r\n        super(EboAlbumTracksComp.styleText, EboAlbumTracksComp.htmlText);\r\n\r\n        this.albumInfo = undefined;\r\n        this.requestRender();\r\n    }\r\n\r\n    static styleText = `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                    text-align: start;\r\n                } \r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    height: 100%;\r\n                    width: 100%;\r\n                }\r\n                .info {\r\n                    font-size: .7em;\r\n                }\r\n                #tableScroller {\r\n                    overflow: scroll;\r\n                    scrollbar-width: none;\r\n                    height: 100%;    \r\n                }\r\n                #tracksTable {\r\n                    width: 100%;\r\n                    border-collapse: collapse;\r\n                    tr {\r\n                        border-bottom: 1px solid #ffffff80;\r\n                    }\r\n                }\r\n            </style>\r\n        `;\r\n        static htmlText = `\r\n            <div id=\"wrapper\">\r\n                <div id=\"tableScroller\">\r\n                    <table id=\"tracksTable\">\r\n                        <tbody>\r\n                        </tbody>                \r\n                    </table>\r\n                </div>          \r\n            </div>\r\n            <dialog popover id=\"albumTrackPopup\">\r\n              Tadaaa....\r\n            </dialog>        \r\n        `;\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(_name: string, _oldValue: string, _newValue: string) {\r\n        this.requestRender();\r\n        }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        this.renderTrackList(shadow);\r\n    }\r\n\r\n    renderTrackList(shadow:ShadowRoot) {\r\n        let tbody = (shadow.getElementById(\"tracksTable\") as HTMLTableElement).tBodies[0];\r\n        tbody.innerHTML  = \"\";\r\n        if(this.albumInfo) {\r\n            this.albumInfo.tracks.forEach(track => {\r\n                let tr = tbody.appendChild(document.createElement(\"tr\"));\r\n                let tdData = tr.appendChild(document.createElement(\"td\"));\r\n                tr.dataset.uri = track.track.uri;\r\n                tdData.innerText = track.track.name;\r\n                let tdButton = tr.appendChild(document.createElement(\"td\"));\r\n                tdButton.innerHTML = `\r\n                    <ebo-menu-button >\r\n                        <div class=\"flexColumn\">\r\n                            <button id=\"\" class=\"roundBorder trackButton\">Set genre</button>\r\n                            <button id=\"\" class=\"roundBorder trackButton\">Add to playlist</button>\r\n                            <button id=\"\" class=\"roundBorder trackButton\">Rename</button>\r\n                            <button id=\"\" class=\"roundBorder trackButton\">Artist ></button>\r\n                            <button id=\"\" class=\"roundBorder trackButton\">Album ></button>\r\n                            <div class=\"flexRow\">\r\n                                <button id=\"addTrack\" class=\"roundBorder trackButton\">\r\n                                    <i class=\"fa fa-plus\"></i>\r\n                                </button>\r\n                                <button id=\"playTrack\" class=\"roundBorder trackButton\">\r\n                                    <i class=\"fa fa-play\"></i>\r\n                                </button>\r\n                            </div>\r\n                        </div>  \r\n                    </ebo-menu-button>`;\r\n                tdButton.querySelector(\"#addTrack\")?.addEventListener(\"click\", (ev) => {\r\n                    let menuButton = ev.target as HTMLElement;\r\n                    let button = menuButton.closest(\"ebo-menu-button\") as EboMenuButton;\r\n                    button.closeMenu();\r\n                    this.dispatchEvent(new EboplayerEvent<UriArgs>(EboplayerEvents.addTrackClicked, {uri: track.track.uri}));\r\n                });\r\n                tdButton.querySelector(\"#playTrack\")?.addEventListener(\"click\", (ev) => {\r\n                    let menuButton = ev.target as HTMLElement;\r\n                    let button = menuButton.closest(\"ebo-menu-button\") as EboMenuButton;\r\n                    button.closeMenu();\r\n                    this.dispatchEvent(new EboplayerEvent<UriArgs>(EboplayerEvents.playTrackClicked, {uri: track.track.uri}));\r\n                });\r\n            });\r\n        }\r\n\r\n        if(this.streamInfo) {\r\n            this.streamInfo.historyLines.forEach(lineGroup => {\r\n                let tr = tbody.appendChild(document.createElement(\"tr\"));\r\n                let td = tr.appendChild(document.createElement(\"td\"));\r\n                td.innerHTML = lineGroup.join(\"<br>\");\r\n                td.classList.add(\"selectable\");\r\n            });\r\n        }\r\n        this.highLightActiveTrack();\r\n    }\r\n\r\n    private highLightActiveTrack() {\r\n        if(!this._activeTrackUri)\r\n            return;\r\n        let tr = this.getShadow().querySelector(`tr[data-uri=\"${this._activeTrackUri}\"]`) as HTMLTableRowElement;\r\n        if(tr) {\r\n            tr.classList.add(\"current\", \"textGlow\");\r\n        }\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\n\r\nimport {AllUris, ExpandedAlbumModel, ExpandedStreamModel, isInstanceOfExpandedStreamModel, ItemType, Views} from \"../modelTypes\";\r\nimport {EboBigAlbumComp} from \"../components/eboBigAlbumComp\";\r\nimport {EboBrowseComp} from \"../components/eboBrowseComp\";\r\nimport {console_yellow} from \"../global\";\r\nimport {EboplayerEvents, BreadcrumbArgs, BrowseResultArgs, UriArgs} from \"../events\";\r\n\r\nexport class MainView extends View {\r\n    bind() {\r\n        document.getElementById(\"headerSearchBtn\").addEventListener(\"click\", () => {\r\n            this.onBrowseButtonClick();\r\n        });\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.addEventListener(\"browseFilterChanged\", (ev) => {\r\n            getState().getController().setAndSaveBrowseFilter(browseComp.browseFilter);\r\n        });\r\n        browseComp.addEventListener(EboplayerEvents.breadCrumbClick, (ev: CustomEvent<BreadcrumbArgs>) => {\r\n            this.onBreadcrumbClick(ev.detail.breadcrumbId);\r\n        });\r\n        browseComp.addEventListener(EboplayerEvents.browseResultClick, (ev: CustomEvent<BrowseResultArgs>) => {\r\n            this.onBrowseResultClick(ev.detail.label, ev.detail.uri, ev.detail.type);\r\n        });\r\n        browseComp.addEventListener(EboplayerEvents.browseResultDblClick, async (ev: CustomEvent<UriArgs>) => {\r\n            await this.onBrowseResultDblClick(ev.detail.uri);\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.refsFiltered, () => {\r\n            this.onRefsFiltered();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.breadCrumbsChanged, () => {\r\n            this.onBreadCrumbsChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.browseFilterChanged, () => {\r\n            this.onBrowseFilterChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, async () => {\r\n            await this.onSelectedTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.trackListChanged, async () => {\r\n            await this.onTrackListChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.viewChanged, () => {\r\n            this.setCurrentView();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.albumToViewChanged, async () => {\r\n            await this.onAlbumToViewChanged();\r\n        });\r\n        let currentTrackBigViewComp = document.getElementById(\"currentTrackBigView\") as EboBrowseComp;\r\n        currentTrackBigViewComp.addEventListener(\"albumClick\", async (e) => {\r\n            this.onAlbumClick();\r\n        });\r\n        let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n        albumComp.addEventListener(EboplayerEvents.playListClicked, () => {\r\n            this.onAlbumPlayClick();\r\n        });\r\n        albumComp.addEventListener(EboplayerEvents.addAlbumClicked, () => {\r\n            this.onAlbumAddClick();\r\n        });\r\n        albumComp.addEventListener(EboplayerEvents.playTrackClicked, (ev: CustomEvent<UriArgs>) => {\r\n            this.onPlayTrackClicked(ev.detail.uri);\r\n        });\r\n        albumComp.addEventListener(EboplayerEvents.addTrackClicked, (ev: CustomEvent<UriArgs>) => {\r\n            this.onAddTrackClicked(ev.detail.uri);\r\n        });\r\n    }\r\n\r\n    private onRefsFiltered() {\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.results = getState()?.getModel()?.getCurrentSearchResults() ?? { refs: [], availableRefTypes: new Set()};\r\n        browseComp.renderResults();\r\n    }\r\n\r\n    private onBreadCrumbsChanged() {\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.breadCrumbs = getState()?.getModel()?.getBreadCrumbs() ?? [];\r\n    }\r\n\r\n    private onBrowseFilterChanged() {\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.browseFilter = getState().getModel().getCurrentBrowseFilter();\r\n    }\r\n\r\n    private onBrowseButtonClick() {\r\n        let browseBtn = document.getElementById(\"headerSearchBtn\");\r\n        switch (browseBtn.dataset.goto) {\r\n            case Views.Browse:\r\n                getState().getController().setView(Views.Browse);\r\n                break;\r\n            case Views.NowPlaying:\r\n                getState().getController().setView(Views.NowPlaying);\r\n                break;\r\n            case Views.Album:\r\n                getState().getController().setView(Views.Album);\r\n                break;\r\n        }\r\n    }\r\n\r\n    setCurrentView() {\r\n        let view = getState().getModel().getView();\r\n        this.showView(view);\r\n    }\r\n\r\n    private showView(view: Views) {\r\n        let browseBtn = document.getElementById(\"headerSearchBtn\");\r\n        let layout = document.getElementById(\"layout\");\r\n        let prevViewClass = [...layout.classList].filter(c => [\"browse\", \"bigAlbum\", \"bigTrack\"].includes(c))[0];\r\n        layout.classList.remove(\"browse\", \"bigAlbum\", \"bigTrack\");\r\n        switch (view) {\r\n            case Views.Browse:\r\n                layout.classList.add(\"browse\");\r\n                location.hash = Views.Browse;\r\n                browseBtn.dataset.goto = Views.NowPlaying;\r\n                browseBtn.title = \"Now playing\";\r\n                let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n                browseComp.browseFilter = getState().getModel().getCurrentBrowseFilter(); //todo: already set in controller?\r\n                browseComp.results = getState()?.getModel()?.getCurrentSearchResults() ?? {refs: [], availableRefTypes: new Set()};\r\n                browseComp.breadCrumbs = getState()?.getModel()?.getBreadCrumbs() ?? [];\r\n                browseComp.setFocusAndSelect();\r\n                break;\r\n            case Views.NowPlaying:\r\n                layout.classList.add(\"bigTrack\");\r\n                location.hash = \"\"; //default = now playing\r\n                browseBtn.dataset.goto = Views.Browse;\r\n                browseBtn.title = \"Search\";\r\n                break;\r\n            case Views.Album:\r\n                layout.classList.add(\"bigAlbum\");\r\n                location.hash = Views.Album;\r\n                if(prevViewClass == \"browse\") { //Provide some navigation back.\r\n                    browseBtn.dataset.goto = Views.Browse;\r\n                    browseBtn.title = \"Search\";\r\n                } else {\r\n                    browseBtn.dataset.goto = Views.NowPlaying;\r\n                    browseBtn.title = \"Now playing\";\r\n                }\r\n        }\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.TrackList, EboPlayerDataType.StreamLines];\r\n    }\r\n\r\n    private onAlbumClick() {\r\n        this.showView(Views.Album);\r\n    }\r\n\r\n    private async onTrackListChanged() {\r\n        if(!getState().getModel().getCurrentTrack()) {\r\n            let trackList = getState().getModel().getTrackList();\r\n            if(trackList.length > 0)\r\n                await getState().getController().setCurrentTrackAndFetchDetails(trackList[0]);\r\n        }\r\n    }\r\n\r\n    private async onSelectedTrackChanged() {\r\n        let uri = getState().getModel().getSelectedTrack();\r\n        getState().getController().lookupTrackCached(uri)\r\n            .then(async track => {\r\n                if(track.type == ItemType.File) {\r\n                    let albumModel = await getState().getController().getExpandedAlbumModel(track.track.album.uri);\r\n                    this.setAlbumComponentData(albumModel);\r\n                }\r\n                else {\r\n                    let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n                    let streamModel = await getState().getController().getExpandedTrackModel(track.track.uri) as ExpandedStreamModel;\r\n                    albumComp.albumInfo = undefined;\r\n                    albumComp.streamInfo = streamModel;\r\n                    albumComp.setAttribute(\"img\", streamModel.stream.imageUrl);\r\n                    albumComp.setAttribute(\"name\", streamModel.stream.name);\r\n                }\r\n            });\r\n    }\r\n\r\n    private async onAlbumToViewChanged() {\r\n        let albumModel = await getState().getController().getExpandedAlbumModel(getState().getModel().getAlbumToView());\r\n        this.setAlbumComponentData(albumModel);\r\n    }\r\n\r\n    private setAlbumComponentData(albumModel: ExpandedAlbumModel) {\r\n        let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n        albumComp.albumInfo = albumModel;\r\n        albumComp.streamInfo = undefined;\r\n        albumComp.setAttribute(\"img\", albumModel.album.imageUrl);\r\n        albumComp.setAttribute(\"name\", albumModel.meta?.albumTitle?? albumModel.album.albumInfo.name);\r\n        albumComp.dataset.albumUri = albumModel.album.albumInfo.uri;\r\n    }\r\n\r\n    private onAlbumPlayClick() {\r\n        let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n        getState().getController().playUri(albumComp.dataset.albumUri);\r\n\r\n    }\r\n\r\n    private onAlbumAddClick() {\r\n        let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n        getState().getController().addUri(albumComp.dataset.albumUri);\r\n    }\r\n\r\n    private async onBrowseResultDblClick(uri: string) {\r\n        await getState().getController().clearListAndPlay(uri);\r\n    }\r\n\r\n    private onBrowseResultClick(label: string, uri: AllUris, type: string) {\r\n        getState().getController().diveIntoBrowseResult(label, uri, type, true);\r\n    }\r\n\r\n    private onBreadcrumbClick(breadcrumbId: number) {\r\n        getState().getController().resetToBreadCrumb(breadcrumbId);\r\n    }\r\n\r\n    private onPlayTrackClicked(uri: string) {\r\n        getState().getController().playUri(uri);\r\n    }\r\n\r\n    private async onAddTrackClicked(uri: string) {\r\n        let trackModel = await getState().getController().getExpandedTrackModel(uri);\r\n        if(!isInstanceOfExpandedStreamModel(trackModel)) {\r\n            let res = await fetch(\"http://192.168.1.111:6680/eboback/data/path?uri=\" + trackModel.album.albumInfo.uri);\r\n            let text = await res.text();\r\n            console_yellow(text);\r\n        }\r\n    }\r\n}\r\n\r\n","import {EboComponent} from \"./EboComponent\";\r\nimport {EboButton, PressedChangeEvent} from \"./eboButton\";\r\n\r\nimport {AllUris, BreadCrumbBrowseFilter, BreadCrumbHome, BreadCrumbRef, BrowseFilter, FilterBreadCrumb} from \"../modelTypes\";\r\nimport {LIBRARY_PROTOCOL} from \"../controller\";\r\nimport {RefType, SearchResults} from \"../refs\";\r\nimport {BreadcrumbArgs, BrowseResultArgs, EboplayerEvent, EboplayerEvents, UriArgs} from \"../events\";\r\nimport models from \"../../js/mopidy\";\r\nimport ModelType = models.ModelType;\r\n\r\nexport class EboBrowseComp extends EboComponent {\r\n    static readonly tagName=  \"ebo-browse-view\";\r\n\r\n    get breadCrumbs(): FilterBreadCrumb[] {\r\n        return this._breadCrumbs;\r\n    }\r\n    set breadCrumbs(value: FilterBreadCrumb[]) {\r\n        this._breadCrumbs = value;\r\n        this.renderBreadCrumbs(); // don't render all, as user may be typing a search text.\r\n    }\r\n\r\n    private _breadCrumbs: FilterBreadCrumb[] = [];\r\n\r\n\r\n    get results(): SearchResults {\r\n        return this._results;\r\n    }\r\n\r\n    set results(value: SearchResults) {\r\n        this._results = value;\r\n        this.renderResults(); // don't render all, as user may be typing a search text.\r\n    }\r\n\r\n    private _results: SearchResults;\r\n\r\n    get browseFilter(): BrowseFilter {\r\n        return this._browseFilter;\r\n    }\r\n\r\n    set browseFilter(value: BrowseFilter) {\r\n        if(JSON.stringify(this._browseFilter) == JSON.stringify(value))\r\n            return;\r\n        this._browseFilter = value;\r\n        this.requestRender();\r\n    }\r\n\r\n    private _browseFilter: BrowseFilter;\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [];\r\n\r\n    private readonly browseFilterChangedEvent: CustomEvent<unknown>;\r\n\r\n    static styleText= `\r\n        <style>\r\n            :host { \r\n                display: flex;\r\n            } \r\n            #wrapper {\r\n                display: flex;\r\n                flex-direction: column;\r\n                width: 100%;\r\n                height: 100%;\r\n            }\r\n            #filterButtons {\r\n                margin-top: .3em;\r\n                display: flex;\r\n                flex-direction: row;\r\n            }\r\n            #searchBox {\r\n                display: flex;\r\n                flex-direction: row;\r\n                & input {\r\n                    flex-grow: 1;\r\n                    background-color: transparent;\r\n                    color: white;\r\n                    border: none;\r\n                    &:focus {\r\n                        outline: none;\r\n                    }\r\n                }\r\n            }\r\n            \r\n           #filterBox {\r\n                margin-block: .5rem;\r\n                padding:.3rem;\r\n                background-color: rgba(0,0,0,.5);\r\n                border-radius: .5rem;\r\n            }\r\n            .filterButton {\r\n                width: 2em;\r\n                height: 2em;\r\n                object-fit: contain;\r\n                margin-right: .5em;\r\n            }\r\n            #searchResultsTable {\r\n                width: 100%;\r\n                border-collapse: collapse;\r\n            }\r\n            #tableWrapper {\r\n                height: 100%;\r\n                width: 100%;\r\n                overflow: scroll;\r\n                scrollbar-width: none;\r\n                td {\r\n                    padding-top: .2em;\r\n                    padding-bottom: .2em;\r\n                }\r\n            }\r\n            #searchResults {\r\n                height: 100%;\r\n                display: flex;\r\n                flex-direction: column;\r\n            }\r\n            .breadcrumb {\r\n                background-color: var(--highlight-background);\r\n                border-radius: 1rem;\r\n                padding-inline-start: 0.5rem;\r\n                padding-inline-end: 0.6em;\r\n                corner-inline-end-shape: bevel;\r\n                .filterButton {\r\n                    filter: invert(100%) sepia(100%) saturate(0%) hue-rotate(350deg) brightness(104%) contrast(102%);\r\n                    height: 1rem;\r\n                    width: 1rem;\r\n                    position: relative;\r\n                    top: .1rem;\r\n                    margin-right: .2rem;\r\n                }\r\n            }\r\n        </style>\r\n        `;\r\n\r\n    // noinspection HtmlUnknownTarget\r\n    static htmlText = `\r\n<div id=\"wrapper\">\r\n    <div id=\"breadCrumbs\"></div>\r\n    <div id=\"filterBox\">\r\n        <div id=\"searchBox\">\r\n            <button id=\"headerSearchBtn\"><img src=\"images/icons/Magnifier.svg\" alt=\"\" class=\"filterButton whiteIconFilter\"></button>\r\n            <input id=\"searchText\" type=\"text\" autofocus>\r\n        </div>\r\n        <div id=\"filterButtons\">\r\n            <ebo-button id=\"filterAlbum\" img=\"images/icons/Album.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n            <ebo-button id=\"filterTrack\" img=\"images/icons/Track.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n            <ebo-button id=\"filterRadio\" img=\"images/icons/Radio.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n            <ebo-button id=\"filterArtist\" img=\"images/icons/Artist.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n            <ebo-button id=\"filterPlaylist\" img=\"images/icons/Playlist.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n            <ebo-button id=\"filterGenre\" img=\"images/icons/Genre.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n            <button> ALL </button>\r\n            <button> &nbsp;&nbsp;(?) </button>\r\n        </div>\r\n    </div>    \r\n    <div id=\"searchResults\">\r\n        <div id=\"searchInfo\">\r\n        </div>  \r\n        <div id=\"tableWrapper\" class=\"\">\r\n            <table id=\"searchResultsTable\">\r\n                <colgroup>\r\n                    <col span=\"1\" style=\"width: auto;\">\r\n                    <col span=\"1\" style=\"width: 1em;\">\r\n                </colgroup>\r\n                <tbody></tbody>\r\n            </table>\r\n        </div>\r\n    </div>\r\n</div>        \r\n        `;\r\n\r\n    constructor() {\r\n        super(EboBrowseComp.styleText, EboBrowseComp.htmlText);\r\n        this.browseFilterChangedEvent = new CustomEvent(\"browseFilterChanged\", {\r\n            bubbles: true,\r\n            cancelable: false,\r\n            composed: true, //needed to 'break' out of the shadow.\r\n            detail: \"todo\"\r\n        });\r\n        this._browseFilter = new BrowseFilter();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"stream_lines\":\r\n            case \"extra\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"enabled\":\r\n            case \"show_back\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.requestRender();\r\n        }\r\n\r\n    onConnected() {\r\n    }\r\n\r\n    setFocusAndSelect() {\r\n        let searchText = this.getShadow().getElementById(\"searchText\") as HTMLInputElement;\r\n        searchText?.focus();\r\n        searchText?.select();\r\n    }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        shadow.getElementById(\"headerSearchBtn\").addEventListener(\"click\", async (ev) => {\r\n            //todo: is this button even needed?\r\n        });\r\n        this.renderBrowseFilter(shadow);\r\n        this.renderBreadCrumbs();\r\n        this.renderResults();\r\n        this.requestUpdate();\r\n    }\r\n\r\n    private renderBrowseFilter(shadow: ShadowRoot) {\r\n        let inputElement = shadow.getElementById(\"searchText\") as HTMLInputElement;\r\n        inputElement.addEventListener(\"keyup\", (ev: KeyboardEvent) => {\r\n            this._browseFilter.searchText = inputElement.value;\r\n            this.dispatchEvent(this.browseFilterChangedEvent);\r\n        });\r\n        shadow.querySelectorAll(\"ebo-button\")\r\n            .forEach(btn => {\r\n                btn.addEventListener(\"pressedChange\", async (ev: PressedChangeEvent) => {\r\n                    this.onFilterButtonPress(ev);\r\n                });\r\n                btn.addEventListener(EboplayerEvents.longPress, (ev) => {\r\n                    this.onFilterButtonLongPress(ev);\r\n                });\r\n                btn.addEventListener(\"dblclick\", (ev) => {\r\n                    this.onFilterButtonDoubleClick(ev);\r\n                })\r\n            });\r\n    }\r\n\r\n    private onFilterButtonLongPress(ev: Event) {\r\n        this.setSingleButton(ev);\r\n    }\r\n\r\n    private onFilterButtonDoubleClick(ev: Event) {\r\n        this.setSingleButton(ev);\r\n    }\r\n\r\n    private setSingleButton(ev: Event) {\r\n        this.clearFilterButtons();\r\n        this.toggleFilterButton(ev.target as EboButton);\r\n        this.requestUpdate();\r\n    }\r\n\r\n    private clearFilterButtons() {\r\n        this.browseFilter.genre = false;\r\n        this.browseFilter.radio = false;\r\n        this.browseFilter.playlist = false;\r\n        this.browseFilter.album = false;\r\n        this.browseFilter.track = false;\r\n        this.browseFilter.artist = false;\r\n    }\r\n\r\n    private onFilterButtonPress(ev: PressedChangeEvent) {\r\n        let btn: EboButton = ev.target as EboButton;\r\n        this.toggleFilterButton(btn);\r\n    }\r\n\r\n    private toggleFilterButton(btn: EboButton) {\r\n        let propName = btn.id.replace(\"filter\", \"\");\r\n        propName = propName.charAt(0).toLowerCase() + propName.slice(1);\r\n        this.browseFilter[propName] = !this.browseFilter[propName];\r\n        this.dispatchEvent(this.browseFilterChangedEvent);\r\n    }\r\n\r\n    update(shadow:ShadowRoot) {\r\n        [...shadow.querySelectorAll(\"ebo-button\")]\r\n            .filter(el => el.id.startsWith(\"filter\"))\r\n            .forEach(btn =>\r\n                this.updateFilterButton(btn as HTMLButtonElement));\r\n        let inputElement = shadow.getElementById(\"searchText\") as HTMLInputElement;\r\n        inputElement.value = this._browseFilter.searchText;\r\n    }\r\n\r\n    private updateFilterButton(btn: HTMLButtonElement) {\r\n        let propName = btn.id\r\n                .replace(\"filter\", \"\").charAt(0).toLowerCase()\r\n               + btn.id.replace(\"filter\", \"\").slice(1) as RefType;\r\n        btn.setAttribute(\"pressed\", this._browseFilter[propName].toString());\r\n        btn.setAttribute(\"disabled\", (!this.results.availableRefTypes.has(propName)).toString());\r\n    }\r\n\r\n    setSearchInfo(text: string) {\r\n        let searchInfo = this.getShadow().getElementById(\"searchInfo\");\r\n        if(searchInfo)\r\n            searchInfo.innerHTML = text;\r\n    }\r\n\r\n    renderBreadCrumbs() {\r\n        if(!this.rendered) //may be called directly, before initialization.\r\n            return;\r\n        let breadCrumbsDiv = this.getShadow().getElementById(\"breadCrumbs\");\r\n        breadCrumbsDiv.innerHTML = this.breadCrumbs\r\n            .map(crumb => this.renderBreadcrumb(crumb))\r\n            .join(\" \");\r\n\r\n        breadCrumbsDiv.querySelectorAll(\"button\").forEach(btn => {\r\n            btn.addEventListener(\"click\", (ev)  => {\r\n                this.onBreadCrumbClicked(ev);\r\n            });\r\n        })\r\n    }\r\n\r\n    private renderBreadcrumb(crumb: FilterBreadCrumb) {\r\n        if(crumb instanceof BreadCrumbRef)\r\n            return `<button data-id=\"${crumb.id}\" class=\"breadcrumb uri\">${crumb.label}</button>`; //todo: have the type of uri and add a little icon?\r\n        else if(crumb instanceof BreadCrumbBrowseFilter) {\r\n            let selectedFilters = crumb.data.getSelectedFilters();\r\n            let imgTags = \"\";\r\n            let filterText = \"\";\r\n            imgTags = selectedFilters.map(filter => this.filterToImg(filter)).join(\"\");\r\n            if(crumb.data.searchText)\r\n                filterText = `\"${crumb.data.searchText}\"`;\r\n            return `<button data-id=\"${crumb.id}\" class=\"breadcrumb filter\">${imgTags}${filterText}</button>`;\r\n        }\r\n        else if(crumb instanceof BreadCrumbHome)\r\n            return `<button data-id=\"${crumb.id}\" class=\"breadcrumb filter\"><i class=\"fa fa-home\"></i></button>`;\r\n    }\r\n\r\n    private filterToImg(filter: string) {\r\n        let imgUrl = \"\";\r\n        switch (filter) {\r\n            case \"album\": imgUrl = \"images/icons/Album.svg\"; break;\r\n            case \"track\": imgUrl = \"images/icons/Track.svg\"; break;\r\n            case \"radio\": imgUrl = \"images/icons/Radio.svg\"; break;\r\n            case \"artist\": imgUrl = \"images/icons/Artist.svg\"; break;\r\n            case \"playlist\": imgUrl = \"images/icons/Playlist.svg\"; break;\r\n            case \"genre\": imgUrl = \"images/icons/Genre.svg\"; break;\r\n        }\r\n        return `<img class=\"filterButton\" src=\"${imgUrl}\" alt=\"\">`;\r\n    }\r\n    renderResults() {\r\n        if(!this.rendered) //may be called directly, before initialization.\r\n            return;\r\n        this.setSearchInfo(\"\");\r\n\r\n        let table = this.getShadow().getElementById(\"searchResultsTable\") as HTMLTableElement;\r\n        let body = table.tBodies[0];\r\n        body.innerHTML = \"\";\r\n\r\n        if(this.results.refs.length == 0)\r\n            return;\r\n\r\n        body.innerHTML = this.results.refs\r\n            .map(result => {\r\n                let refType = result.ref.type;\r\n                return `\r\n                    <tr data-uri=\"${result.ref.ref.uri}\" data-type=\"${refType}\">\r\n                    <td>${result.ref.ref.name}</td>\r\n                    <td>...</td>\r\n                    </tr>`;\r\n            })\r\n            .join(\"\\n\");\r\n        body.querySelectorAll(\"tr\").forEach(tr => {\r\n            tr.addEventListener(\"dblclick\", ev => {this.onRowDoubleClicked(ev).then(r => {})});\r\n            tr.addEventListener(\"click\", ev => {this.onRowClicked(ev)});\r\n        });\r\n        this.requestUpdate();\r\n    }\r\n\r\n    private onRowClicked(ev: MouseEvent) {\r\n        let row = ev.currentTarget as HTMLTableRowElement;\r\n        this.dispatchEvent(new CustomEvent<BrowseResultArgs>(EboplayerEvents.browseResultClick, {detail: {\"label\": row.cells[0].innerText, \"uri\": row.dataset.uri as AllUris, \"type\": row.dataset.type}}));\r\n    }\r\n\r\n    private async onRowDoubleClicked(ev: MouseEvent) {\r\n        let row = ev.currentTarget as HTMLTableRowElement;\r\n        this.dispatchEvent(new EboplayerEvent<UriArgs>(EboplayerEvents.browseResultDblClick, {uri: row.dataset.uri}));\r\n    }\r\n\r\n    private onBreadCrumbClicked(ev: MouseEvent) {\r\n        let btn = ev.currentTarget as HTMLButtonElement;\r\n        this.dispatchEvent(new EboplayerEvent<BreadcrumbArgs>(EboplayerEvents.breadCrumbClick, {breadcrumbId: parseInt(btn.dataset.id)}));\r\n    }\r\n\r\n}\r\n","const TIME_OUT_TIME = 500;\r\n\r\nexport class MouseTimer<Source> {\r\n    private activeTimer: number;\r\n    private source: Source;\r\n    private mouseUpCount = 0;\r\n    private isMouseDown = false;\r\n\r\n    private readonly onClick: (source: Source) => void = undefined;\r\n    private readonly onTimeOut: (source: Source) => void = undefined;\r\n    private readonly onMultiClick: (source: Source, clickCount: number) => void = undefined;\r\n\r\n    constructor(source: Source,\r\n                onClick: (source: Source) => void = undefined,\r\n                onMultiClick: (source: Source, clickCount: number) => void = undefined,\r\n                onTimeOut: (source: Source) => void = undefined\r\n    ) {\r\n        this.source = source;\r\n        this.onClick = onClick;\r\n        this.onMultiClick = onMultiClick;\r\n        this.onTimeOut = onTimeOut;\r\n    }\r\n\r\n    onMouseDown = (ev: MouseEvent) => {\r\n        this.isMouseDown = true;\r\n        if(this.activeTimer)\r\n            return;\r\n        this.startPressTimer(ev, () => {\r\n            this.doTimeOut();\r\n        });\r\n    };\r\n\r\n    onMouseUp = (ev: MouseEvent) => {\r\n        this.isMouseDown = false;\r\n        if(!this.activeTimer)\r\n            return;\r\n        this.mouseUpCount++;\r\n        if(this.mouseUpCount > 1) {\r\n            this.onMultiClick?.(this.source, this.mouseUpCount);\r\n            return;\r\n        }\r\n        this.onClick?.(this.source);\r\n    };\r\n\r\n    onMouseLeave = (ev: MouseEvent) => {\r\n        this.cancelPressTimer();\r\n    }\r\n\r\n    doTimeOut() {\r\n        this.cancelPressTimer();\r\n        if(!this.isMouseDown)\r\n            return;\r\n        this.onTimeOut?.(this.source);\r\n    }\r\n\r\n    private cancelPressTimer() {\r\n        if(this.activeTimer)\r\n            clearTimeout(this.activeTimer);\r\n        this.activeTimer = undefined;\r\n    }\r\n\r\n    private startPressTimer(ev: MouseEvent, onTimeOutCallback: (ev: MouseEvent) => void) {\r\n        this.mouseUpCount = 0;\r\n        this.activeTimer = window.setTimeout(() => { //use `window.` to avoid conflict with nodejs version of setTimeout.\r\n            if(this.activeTimer)\r\n                onTimeOutCallback(ev);\r\n            this.cancelPressTimer();\r\n        }, TIME_OUT_TIME);\r\n    }\r\n\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {MouseTimer} from \"../MouseTimer\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\nexport class PressedChangeEvent extends Event {\r\n    private _pressed: boolean;\r\n\r\n    constructor(pressed: boolean) {\r\n        super(\"pressedChange\");\r\n        this._pressed = pressed;\r\n    }\r\n\r\n    get pressed() {\r\n        return this._pressed;\r\n    }\r\n}\r\n\r\nexport class EboButton extends EboComponent {\r\n    static readonly tagName=  \"ebo-button\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"toggle\", \"img\", \"img_pressed\", \"pressed\", \"opacity_off\", \"click\", \"disabled\"];\r\n    private pressed: boolean = false;\r\n    private disabled: boolean = false;\r\n    private img: string;\r\n    private pressTimer: MouseTimer<EboButton>;\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n            img {\r\n                width: 100%;\r\n                opacity: 0.5;\r\n                &.pressed { \r\n                    opacity: 1; \r\n                    &.disabled { \r\n                        opacity: .2; /*if needed, set this too a lower value then when disabled+not pressed. */\r\n                    }\r\n                }\r\n                &.disabled { \r\n                    opacity: .2; \r\n                }\r\n            }\r\n        </style>\r\n    `;\r\n    //todo: make a html (or style) template literal function to inject opacity and such.\r\n    // > This function does NOT return a string, but the list of string fragments and placeholders.\r\n    // > The template is rendered later with `this` as the context.\r\n\r\n    static htmlText = `\r\n        <button>\r\n            <img id=\"image\" src=\"\" alt=\"Button image\">\r\n        </button>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboButton.styleText, EboButton.htmlText);\r\n        this.pressTimer = new MouseTimer<EboButton>(\r\n            this,\r\n            (source) => this.onClick(source),\r\n            (source, clickCount) => this.onMultiClick(source, clickCount),\r\n            (source) => this.onFilterButtonTimeOut(source)\r\n        );\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"pressed\":\r\n            case \"disabled\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.requestRender();\r\n        }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        let imgTag = shadow.getElementById(\"image\") as HTMLImageElement;\r\n        this.setClassFromBoolAttribute(imgTag, \"pressed\");\r\n        this.setClassFromBoolAttribute(imgTag, \"disabled\");\r\n        imgTag.src = this.img ?? \"\";\r\n        let button = shadow.querySelector(\"button\");\r\n        button.addEventListener(\"mousedown\", (ev) => {\r\n            this.pressTimer.onMouseDown(ev);\r\n        });\r\n        button.addEventListener(\"mouseup\", (ev) => {\r\n            this.pressTimer.onMouseUp(ev);\r\n        });\r\n        button.addEventListener(\"mouseleave\", (ev) => {\r\n            this.pressTimer.onMouseLeave(ev);\r\n        });\r\n    }\r\n\r\n    private onClick(eboButton: EboButton) {\r\n        if(this.disabled) return;\r\n        let button = this.getShadow().querySelector(\"button\");\r\n        this.pressed = !this.pressed;\r\n        this.setClassFromBoolAttribute(button, \"pressed\");\r\n        this.setAttribute(\"pressed\", this.pressed.toString());\r\n        let event = new PressedChangeEvent(this.pressed);\r\n        this.dispatchEvent(event);\r\n    }\r\n\r\n    onFilterButtonTimeOut(source: EboButton) {\r\n        this.dispatchEvent(new Event(EboplayerEvents.longPress, {bubbles: true, composed: true}));\r\n    }\r\n\r\n    private onMultiClick(eboButton: EboButton, clickCount: number) {\r\n        if(this.disabled) return;\r\n        this.dispatchEvent(new Event(\"dblclick\", {bubbles: true, composed: true}));\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {EboAlbumTracksComp} from \"./eboAlbumTracksComp\";\r\nimport {ExpandedAlbumModel, ExpandedStreamModel} from \"../modelTypes\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\n\r\nexport class EboBigAlbumComp extends EboComponent {\r\n    get activeTrackUri(): string | null {\r\n        return this._activeTrackUri;\r\n    }\r\n    set activeTrackUri(value: string | null) {\r\n        this._activeTrackUri = value;\r\n        this.onActiveTrackChanged();\r\n    }\r\n    get albumInfo() {\r\n        return this._albumInfo;\r\n    }\r\n\r\n    set albumInfo(value: ExpandedAlbumModel) {\r\n        this._albumInfo = value;\r\n        this.requestUpdate();\r\n    }\r\n\r\n    private _streamInfo?: ExpandedStreamModel;\r\n    get streamInfo(): ExpandedStreamModel {\r\n        return this._streamInfo;\r\n    }\r\n    set streamInfo(value: ExpandedStreamModel) {\r\n        this._streamInfo = value;\r\n        this.requestUpdate();\r\n    }\r\n\r\n    private _activeTrackUri: string | null = null;\r\n    static readonly tagName=  \"ebo-big-album-view\";\r\n    static progressBarAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"name\", \"extra\", \"img\", \"disabled\"\r\n    ];\r\n    private name: string = \"\";\r\n    private extra: string = \"\";\r\n    private img: string  = \"\";\r\n    private albumClickEvent: CustomEvent<unknown>;\r\n    private _albumInfo: ExpandedAlbumModel;\r\n\r\n    static styleText= `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                } \r\n                h3 {\r\n                    margin-block-start: .5em;\r\n                    margin-block-end: .5em;\r\n                }\r\n                .albumCoverContainer {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    align-content: center;\r\n                    overflow: hidden;\r\n                    flex-wrap: wrap;\r\n                }\r\n                img {\r\n                    width: 90vw;\r\n                    height: 45vh;\r\n                    object-fit: contain;\r\n                    background-image: radial-gradient(circle, rgba(255,255,255, .5) 0%, transparent 100%);\r\n                }\r\n                ebo-progressbar {\r\n                    margin-top: .5em;\r\n                }\r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    height: 100%;\r\n                    width: 100%;\r\n                    #bottom {\r\n                        overflow: hidden;\r\n                    }\r\n                }\r\n                #wrapper.front {\r\n                    #back {\r\n                        display: none;\r\n                    }                \r\n                }\r\n                #wrapper.back {\r\n                    #front {\r\n                        position: absolute;\r\n                        display: none;\r\n                    }                \r\n                }\r\n                .info {\r\n                    font-size: .7em;\r\n                }\r\n                #albumTableWrapper {\r\n                    height: 100%;\r\n                }\r\n                ebo-album-tracks-view {\r\n                    height: 100%;\r\n                }\r\n            </style>\r\n        `;\r\n\r\n    // noinspection HtmlUnknownTarget\r\n    static htmlText = `\r\n            <div id=\"wrapper\" class=\"front\">\r\n                <div id=\"top\">\r\n                    <div class=\"albumCoverContainer\">\r\n                        <img id=\"image\" src=\"\" alt=\"Album cover\"/>\r\n                    </div>\r\n        \r\n                    <div id=\"info\">\r\n                        <h3 id=\"text\" class=\"selectable\"></h3>\r\n                        <h3 id=\"name\" class=\"selectable\"></h3>\r\n                        <div id=\"stream_lines\" class=\"selectable info\"></div>\r\n                        <div id=\"extra\" class=\"selectable info\"></div>\r\n                    </div>\r\n                    <ebo-list-button-bar></ebo-list-button-bar>\r\n                </div>\r\n                <div id=\"bottom\">\r\n                    <div id=\"albumTableWrapper\">\r\n                        <ebo-album-tracks-view img=\"\" ></ebo-album-tracks-view>\r\n                    </div>\r\n                </div>\r\n            </div>        \r\n        `;\r\n\r\n    constructor() {\r\n        super(EboBigAlbumComp.styleText, EboBigAlbumComp.htmlText);\r\n        this.albumInfo = undefined;\r\n        this.albumClickEvent = new CustomEvent(\"albumClick\", {\r\n            bubbles: true,\r\n            cancelable: false,\r\n            composed: true, //needed to 'break' out of the shadow.\r\n            detail: \"todo: tadaaa!\"\r\n        });\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        if(EboBigAlbumComp.progressBarAttributes.includes(name)) {\r\n            this[name] = newValue;\r\n            return;\r\n        }\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"extra\":\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n        }\r\n        this.requestUpdate();\r\n        }\r\n\r\n    override update(shadow:ShadowRoot) {\r\n        [\"name\", \"extra\"].forEach(attName => {\r\n            shadow.getElementById(attName).innerHTML = this[attName];\r\n        });\r\n        let tracksComp = shadow.querySelector(\"ebo-album-tracks-view\") as EboAlbumTracksComp;\r\n        tracksComp.albumInfo = this.albumInfo;\r\n        tracksComp.streamInfo = this.streamInfo;\r\n        let img = shadow.getElementById(\"image\") as HTMLImageElement;\r\n        if(this.img != \"\") {\r\n            img.style.visibility = \"\";\r\n            img.src = this.img;\r\n        } else\r\n            img.style.visibility = \"hidden\";\r\n    }\r\n\r\n    override render(shadow:ShadowRoot) {\r\n    }\r\n\r\n    private onActiveTrackChanged() {\r\n        let tracksComp = this.getShadow().querySelector(\"ebo-album-tracks-view\") as EboAlbumTracksComp;\r\n        tracksComp.activeTrackUri = this.activeTrackUri;\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {ExpandedFileTrackModel, ItemType, TrackModel} from \"../modelTypes\";\r\nimport {console_yellow, inverseQuadratic100, quadratic100} from \"../global\";\r\nimport {EboplayerEvents} from \"../events\";\r\n\r\nexport class EboButtonBar extends EboComponent {\r\n    static readonly tagName=  \"ebo-button-bar\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"play_state\", \"image_url\", \"show_info\", \"volume\", \"allow_play\", \"allow_prev\", \"allow_next\", \"text\", \"stop_or_pause\"];\r\n    private play_state: string;\r\n    private show_info: boolean = false;\r\n    private isVolumeSliding: boolean = false;\r\n    private volume: number = 0;\r\n    private allow_play: boolean = true;\r\n    private allow_prev: boolean = true;\r\n    private allow_next: boolean = true;\r\n    private text: string = \"\";\r\n    private image_url: string = \"\";\r\n    private stop_or_pause: string;\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n            img {\r\n                width: 2em;\r\n                height: 2em;\r\n                margin-right: 1em;\r\n            }\r\n        \r\n            .playing {\r\n                background-color: var(--highlight-background);\r\n            }\r\n            #buttonBar  {\r\n                display: flex;\r\n                justify-content: center;\r\n                flex-wrap: wrap;\r\n                align-items: center;\r\n                align-content: center;\r\n            \r\n                & button {\r\n                    padding-left: .5ch;\r\n                    padding-right: .5ch;\r\n                }\r\n            }\r\n            #buttonBar {\r\n                display: flex;\r\n                justify-content: center;\r\n                align-items: center;\r\n            }\r\n            #volumeSlider {\r\n                width: 100px;\r\n            }\r\n            input[type='range'] {\r\n                & {\r\n                    margin: 10px 5px;\r\n                    height: 2px;\r\n                    background-color: gray;\r\n                    -webkit-appearance: none;\r\n                }\r\n            \r\n                &::-webkit-slider-thumb {\r\n                    padding: 0;\r\n            \r\n                    width: 7px;\r\n                    appearance: none;\r\n                    height: 7px;\r\n                    background: white;\r\n                    color: white;\r\n                    border-color: white;\r\n                    border-style: solid;\r\n                    border-width:7px;\r\n                    border-radius: 7px;\r\n                }\r\n            }\r\n            #wrapper {\r\n                width: 100%;\r\n                display: flex;\r\n                flex-direction: column;\r\n                justify-content: center;\r\n                align-items: center;\r\n                padding-top: .5em;\r\n                padding-bottom: .5em;\r\n            }\r\n            #text {\r\n                font-size: .7em;\r\n                text-align: center;\r\n                display: block;\r\n            }\r\n        </style>\r\n    `;\r\n    //todo: make a html (or style) template literal function to inject opacity and such.\r\n    // > This function does NOT return a string, but the list of string fragments and placeholders.\r\n    // > The template is rendered later with `this` as the context.\r\n\r\n    static htmlText = `\r\n        <div id=\"wrapper\">\r\n            <div id=\"info\">\r\n                <span id=\"text\" class=\"selectable\">sdfsdf sdfsdf </span>\r\n            </div>\r\n            <div id=\"buttonBar\">\r\n                <img id=\"buttonBarImg\" src=\"images/default_cover.png\" alt=\"Album cover\"/>\r\n                <div id=\"buttonBar\">\r\n                    <button id=\"btnPrev\" title=\"Previous\"><i class=\"fa fa-fast-backward\"></i></button>\r\n                    <button id=\"btnPlay\" title=\"Play\"><i class=\"fa fa-play\"></i></button>\r\n                    <button id=\"btnNext\" title=\"Next\"><i class=\"fa fa-fast-forward\"></i></button>\r\n                    <input id=\"volumeSlider\" data-highlight=\"true\" name=\"volumeSlider\" data-mini=\"true\" type=\"range\" min=\"0\" value=\"0\" max=\"100\"/>\r\n                    <button id=\"btnMore\" style=\"margin-left: 1em;\" title=\"Next\"><i class=\"fa fa-ellipsis-h\"></i></button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboButtonBar.styleText, EboButtonBar.htmlText);\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"image_url\":\r\n            case \"text\":\r\n            case \"play_state\":\r\n            case \"stop_or_pause\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"volume\":\r\n                this.volume = parseInt(newValue);\r\n                break;\r\n            case \"show_info\":\r\n            case \"allow_play\":\r\n            case \"allow_prev\":\r\n            case \"allow_next\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.requestUpdate();\r\n        }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        let slider = shadow.getElementById(\"volumeSlider\") as HTMLInputElement;\r\n        slider.oninput = (ev) => {\r\n            this.isVolumeSliding = true;\r\n            this.volume = quadratic100(parseInt(slider.value));\r\n            this.dispatchEvent(new CustomEvent(EboplayerEvents.changingVolume, {bubbles: true, composed: true, detail: {volume: this.volume}}));\r\n        };\r\n        slider.onmousedown = slider.ontouchstart = () => { this.isVolumeSliding = true;};\r\n        slider.onmouseup = slider.ontouchend = () => { this.isVolumeSliding = false;};\r\n\r\n        let btnPlay = shadow.getElementById('btnPlay');\r\n        btnPlay.addEventListener(\"click\", (ev) => {\r\n            let title = btnPlay.querySelector('i').title;\r\n            let eventName: EboplayerEvents;\r\n            switch (title) {\r\n                case \"Play\": eventName = EboplayerEvents.playPressed; break;\r\n                case \"Pause\": eventName = EboplayerEvents.pausePressed; break;\r\n                case \"Stop\": eventName = EboplayerEvents.stopPressed; break;\r\n            }\r\n            this.dispatchEvent(new CustomEvent(eventName, {bubbles: true, composed: true}));\r\n        });\r\n        let imgTag = shadow.getElementById(\"buttonBarImg\") as HTMLImageElement;\r\n        imgTag.addEventListener(\"click\", (ev) => {\r\n            this.dispatchEvent(new Event(EboplayerEvents.buttonBarAlbumImgClicked));\r\n        });\r\n    }\r\n\r\n    update(shadow:ShadowRoot) {\r\n        switch(this.play_state) {\r\n            case \"playing\":\r\n                if(this.stop_or_pause == \"pause\")\r\n                    this.setPlayButton('Pause', 'fa-pause');\r\n                else\r\n                    this.setPlayButton('Stop', 'fa-stop');\r\n                break;\r\n            case \"stopped\":\r\n            case \"paused\":\r\n                this.setPlayButton('Play', 'fa-play');\r\n                break;\r\n        }\r\n        shadow.getElementById(\"btnNext\").style.opacity = this.allow_next ? \"1\" : \"0.5\" ;\r\n        shadow.getElementById(\"btnPrev\").style.opacity = this.allow_prev ? \"1\" : \"0.5\";\r\n        shadow.getElementById(\"btnPlay\").style.opacity = this.allow_play ? \"1\" : \"0.5\";\r\n\r\n        let titleEl = shadow.getElementById(\"text\");\r\n        let img = shadow.querySelector(\"img\") as HTMLImageElement;\r\n        titleEl.style.display = this.show_info ? \"\" : \"none\";\r\n        if(this.image_url) {\r\n            img.style.visibility =  this.show_info ? \"visible\" : \"hidden\";\r\n            img.setAttribute(\"src\", this.image_url);\r\n        }\r\n        else\r\n            img.style.visibility = \"hidden\";\r\n        if(!this.isVolumeSliding) {\r\n            let slider = shadow.getElementById(\"volumeSlider\") as HTMLInputElement;\r\n            let visualVolume = inverseQuadratic100(this.volume);\r\n            slider.value = Math.floor(visualVolume).toString();\r\n        }\r\n        let wrapper = shadow.getElementById(\"wrapper\");\r\n        wrapper.classList.toggle(\"playing\", this.play_state == \"playing\");\r\n        titleEl.innerHTML = this.text.replaceAll(\"\\n\", \"<br/>\");\r\n    }\r\n\r\n    private setPlayButton(title: string, addClass: string) {\r\n        let btnPlayIcon = this.getShadow().getElementById('btnPlay').querySelector('i');\r\n        btnPlayIcon.classList.remove(\"fa-play\", \"fa-pause\", \"fa-stop\" );\r\n        btnPlayIcon.classList.add(addClass);\r\n        btnPlayIcon.setAttribute('title', title);\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\n\r\nexport class EboMenuButton extends EboComponent {\r\n    static readonly tagName=  \"ebo-menu-button\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [];\r\n    //todo: put all global css files in the same cache as the local ones<\r\n    // make sure they aren't added twice: once from the global specs and once from the indivicual components.\r\n    // noinspection JSUnusedGlobalSymbols\r\n    // cssNeeded = [\"vendors/font_awesome/css/font-awesome.css\"];\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n            .menuButton {\r\n                padding: 0;\r\n                border-radius: 100vw;\r\n                aspect-ratio: 1;\r\n                \r\n                anchor-name: --popup-button;\r\n            }\r\n            \r\n            .popupMenu {\r\n                border: solid white 1px;\r\n                border-radius: 20px 20px 0px 20px;\r\n                xposition: absolute;\r\n                position-anchor: --popup-button;\r\n                margin: 0;\r\n                inset: auto;\r\n                bottom: anchor(top);\r\n                right: anchor(right);\r\n                opacity: 0;\r\n                margin-left: 0.25rem;\r\n                background-color: var(--body-background);\r\n                \r\n                &:popover-open {\r\n                    xdisplay: grid;\r\n                    opacity: 1;\r\n                }\r\n            }\r\n            \r\n            .trackButton {\r\n                border-color: gray;\r\n                text-align: left;\r\n                & i {\r\n                    position: relative;\r\n                    top: 2px;\r\n                }\r\n            }\r\n      </style>\r\n    `;\r\n\r\n    static htmlText = `\r\n        <button class=\"menuButton\" popovertarget=\"menu\">\r\n            ...\r\n        </button>\r\n        <div popover id=\"menu\" class=\"popupMenu\">\r\n            <slot></slot>\r\n        </div>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboMenuButton.styleText, EboMenuButton.htmlText);\r\n    }\r\n\r\n    onConnected() {\r\n        super.onConnected();\r\n        this.requestRender();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"pressed\": //todo: generalize capture of attributes.\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.requestRender();\r\n        }\r\n\r\n    render() {\r\n    }\r\n\r\n    closeMenu() {\r\n        (this.getShadow().getElementById(\"menu\") as HTMLElement).hidePopover();\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {MouseTimer} from \"../MouseTimer\";\r\nimport {EboplayerEvent, EboplayerEvents, UriArgs} from \"../events\";\r\nimport {EboAlbumTracksComp} from \"./eboAlbumTracksComp\";\r\n\r\nexport class EboListButtonBar extends EboComponent {\r\n    static readonly tagName=  \"ebo-list-button-bar\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"show_add_btn\", \"show_play_btn\"];\r\n    show_add_btn: boolean;\r\n    show_play_btn: boolean;\r\n    static styleText = `\r\n        <style>\r\n            #buttons {\r\n                display: flex;\r\n                flex-direction: row;\r\n                margin-bottom: .5em;\r\n            }\r\n        </style>\r\n    `;\r\n    static htmlText = `\r\n        <div id=\"buttons\">\r\n            <button id=\"btnPlay\" class=\"roundBorder\">Play</button>\r\n            <button id=\"btnAdd\" class=\"roundBorder\">Add</button>\r\n        </div>                   \r\n    `;\r\n\r\n    constructor() {\r\n        super(EboListButtonBar.styleText, EboListButtonBar.htmlText);\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"show_add_btn\":\r\n            case \"show_play_btn\":\r\n                this.updateBoolAtrribute(newValue, name);\r\n                break;\r\n        }\r\n        this.requestRender();\r\n        }\r\n\r\n    private updateBoolAtrribute(newValue: string, name: string) { //todo: move to base class. Perhaps return true if value actually changed, so a re-render or update could be avoided.\r\n        if (![\"true\", \"false\"].includes(newValue))\r\n            throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n        this[name] = newValue == \"true\";\r\n    }\r\n\r\n    render(shadow:ShadowRoot) {\r\n        this.addShadowEventListener(\"btnPlay\", \"click\", (ev) => {\r\n            this.dispatchEvent(new EboplayerEvent<UriArgs>(EboplayerEvents.playListClicked)); //todo: override dispatchEvent to make it tied to EboplayerEvent?\r\n        });\r\n        this.addShadowEventListener(\"btnAdd\", \"click\", (ev) => {\r\n            this.dispatchEvent(new EboplayerEvent<UriArgs>(EboplayerEvents.addAlbumClicked));\r\n        });\r\n        this.requestUpdate();\r\n    }\r\n}","import {Mopidy, Options} from \"../js/mopidy\";\r\nimport {SyncedProgressTimer} from \"./synced_timer\";\r\nimport getState, {setState, State} from \"./playerState\";\r\nimport {Model} from \"./model\";\r\nimport {HeaderView} from \"./views/headerView\";\r\nimport {Controller} from \"./controller\";\r\nimport {ButtonBarView} from \"./views/buttonBarView\";\r\nimport {EboProgressBar} from \"./components/eboProgressBar\";\r\nimport {TimelineView} from \"./views/timelineView\";\r\nimport {EboBigTrackComp} from \"./components/eboBigTrackComp\";\r\nimport {BigTrackViewCurrentOrSelectedAdapter} from \"./views/bigTrackViewCurrentOrSelectedAdapter\";\r\nimport {EboAlbumTracksComp} from \"./components/eboAlbumTracksComp\";\r\nimport {EboComponent} from \"./components/EboComponent\";\r\nimport {MainView} from \"./views/mainView\";\r\nimport {EboBrowseComp} from \"./components/eboBrowseComp\";\r\nimport {EboButton} from \"./components/eboButton\";\r\nimport {getHostAndPort} from \"./global\";\r\nimport {JsonRpcController} from \"./jsonRpcController\";\r\nimport {EboBigAlbumComp} from \"./components/eboBigAlbumComp\";\r\nimport {EboButtonBar} from \"./components/eboButtonBarComp\";\r\nimport {Views} from \"./modelTypes\";\r\nimport {EboMenuButton} from \"./components/eboMenuButton\";\r\nimport {EboListButtonBar} from \"./components/eboListButtonBar\";\r\n\r\nexport function getWebSocketUrl() {\r\n    let webSocketUrl = document.body.dataset.websocketUrl;\r\n    if (webSocketUrl.startsWith(\"{{\"))\r\n        webSocketUrl = `ws://${getHostAndPort()}/mopidy/ws`;\r\n    return webSocketUrl;\r\n}\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\",function () {\r\n    Promise.all([\r\n        fetch(`${rootDir}css/global.css`).then(res => res.text()),\r\n        fetch(`${rootDir}vendors/font_awesome/css/font-awesome.css`).then(res => res.text()),\r\n    ])\r\n        .then(texts => {\r\n            EboComponent.setGlobalCss(texts);\r\n\r\n            EboComponent.define(EboProgressBar);\r\n            EboComponent.define(EboBigTrackComp);\r\n            EboComponent.define(EboAlbumTracksComp);\r\n            EboComponent.define(EboBrowseComp);\r\n            EboComponent.define(EboButton);\r\n            EboComponent.define(EboBigAlbumComp);\r\n            EboComponent.define(EboButtonBar);\r\n            EboComponent.define(EboMenuButton);\r\n            EboComponent.define(EboListButtonBar);\r\n\r\n            setupStuff();\r\n        });\r\n});\r\n\r\nfunction setupStuff() {\r\n    let webSocketUrl = getWebSocketUrl();\r\n    let connectOptions: Options = {\r\n        webSocketUrl,\r\n        autoConnect: false //important: delay connection until all bindings, listeners and dependencies are setup.\r\n    };\r\n    let mopidy = new Mopidy(connectOptions);\r\n    let wsUrl = \"ws://192.168.1.111:6680/eboplayer2/ws/\"; //iris socket: ws://192.168.1.111:6680/iris/ws/\r\n    let eboWebSocketCtrl = new JsonRpcController(wsUrl, 1000, 64000);\r\n    let timer = new SyncedProgressTimer(8, mopidy);\r\n    let model = new Model();\r\n\r\n    let controller = new Controller(model, mopidy, eboWebSocketCtrl);\r\n\r\n    controller.initSocketevents();\r\n\r\n    let state = new State(mopidy, timer, model, controller);\r\n    setState(state);\r\n\r\n    let mainView = new MainView();\r\n    let headerView = new HeaderView();\r\n    let currentTrackView = new BigTrackViewCurrentOrSelectedAdapter(\"currentTrackBigView\");\r\n    let buttonBarView = new ButtonBarView(\"buttonBar\", mainView);\r\n    let historyView = new TimelineView();\r\n    getState().addViews(mainView, headerView, currentTrackView, buttonBarView, historyView);\r\n\r\n    if(location.hash == Views.Browse)\r\n        controller.setView(Views.Browse);\r\n    else\r\n        controller.setView(Views.NowPlaying);\r\n\r\n    mopidy.connect();\r\n    eboWebSocketCtrl.connect();\r\n}\r\n\r\nfunction updateDocumentTitle (headline) {\r\n    headline = headline || document.getElementById('contentHeadline').textContent;\r\n    document.title = headline + ' | ' + document.body.dataset.title;\r\n}\r\n\r\n//intellij live preview hack because they don't allow to set a root folder for the built-in server:\r\nlet rootDir = document.location.pathname.replace(\"index.html\", \"\");\r\n\r\n"],"mappings":"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"}