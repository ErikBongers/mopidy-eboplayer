{"version":3,"file":"bundle.js","names":["state","state: State","AlbumNone: AlbumDataNone","state","getState","array: any[]","model: FileTrackModel","getState","state","historyObject: Object","dict: LibraryDict","getState","streamTitles: StreamTitles","state","radioStreams: models.Ref[]","grouped","getState","text","getState","allLookups: Promise<void>[]","tr","getState","position: string","button: string","getState","selectedTrackUri: string","getState","btn: EboButton","getState","eventName: EboplayerEvents","title: string","EboBrowseComp","connectOptions: Options","state"],"sources":["../typescript/eventEmitter.ts","../typescript/jsonRpcController.ts","../js/mopidy.ts","../typescript/timer.ts","../typescript/synced_timer.ts","../typescript/playerState.ts","../typescript/breadCrumb.ts","../typescript/modelTypes.ts","../typescript/model.ts","../typescript/views/dataRequester.ts","../typescript/views/view.ts","../typescript/views/headerView.ts","../typescript/functionsvars.ts","../typescript/library.ts","../typescript/global.ts","../typescript/process_ws.ts","../typescript/commands.ts","../typescript/proxies/mopidyProxy.ts","../typescript/proxies/localStorageProxy.ts","../typescript/refs.ts","../typescript/proxies/webProxy.ts","../typescript/controller.ts","../typescript/views/buttonBarView.ts","../typescript/components/EboComponent.ts","../typescript/components/eboProgressBar.ts","../typescript/views/timelineView.ts","../typescript/components/eboBigTrackComp.ts","../typescript/views/componentViewAdapter.ts","../typescript/views/bigTrackViewUriAdapter.ts","../typescript/views/bigTrackViewCurrentOrSelectedAdapter.ts","../typescript/components/eboAlbumTracksComp.ts","../typescript/views/mainView.ts","../typescript/components/eboBrowseComp.ts","../typescript/MouseTimer.ts","../typescript/components/eboButton.ts","../typescript/components/eboBigAlbumComp.ts","../typescript/components/eboButtonBarComp.ts","../typescript/gui.ts"],"sourcesContent":["//todo: use this one instead?\r\n// https://javascript.plainenglish.io/building-a-simple-event-emitter-in-javascript-f82f68c214ad\r\nexport class EventEmitter {\r\n    listeners = [];\r\n    supervisors = [];\r\n\r\n    emit(eventName: string, ...data) {\r\n        this.listeners.filter(({name}) => name === eventName)\r\n            .forEach(({callback}) => {\r\n                setTimeout(() => callback.call(this, ...data), 0);\r\n            });\r\n        this.supervisors.forEach(callback => {\r\n            setTimeout(() => callback.call(this, ...data), 0);\r\n        });\r\n    }\r\n\r\n    on(name: string | Function, callback?: any) { //todo: make callback type more specific?\r\n        if (typeof name === 'string' && typeof callback === 'function') {\r\n            this.listeners.push({name, callback});\r\n            return;\r\n        }\r\n        if (typeof name === 'function') {\r\n            this.supervisors.push(name);\r\n        }\r\n    }\r\n\r\n    off(eventName: string, callback: any) {\r\n        this.removeListener(eventName, callback);\r\n    }\r\n\r\n    destroy() {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    removeAllListeners(eventName?: string) {\r\n        if (!eventName) {\r\n            this.listeners.length = 0;\r\n            return;\r\n        }\r\n        this.listeners = this.listeners.filter(listener => !(listener.name === eventName));\r\n    }\r\n\r\n    removeListener(eventName: string, callback: any) {\r\n        this.listeners = this.listeners.filter(listener =>\r\n            !(listener.name === eventName &&\r\n                listener.callback === callback)\r\n        );\r\n    }\r\n}","import {EventEmitter} from \"./eventEmitter\";\r\n\r\nfunction snakeToCamel(name: string) {\r\n    return name.replace(/(_[a-z])/g, (match) =>\r\n        match.toUpperCase().replace(\"_\", \"\")\r\n    );\r\n}\r\n\r\nexport class JsonRpcController extends EventEmitter {\r\n    private readonly _pendingRequests: {}; //this initialization gets stripped by rolldown!\r\n    private _webSocket: WebSocket;\r\n    private readonly webSocketUrl: string;\r\n\r\n    constructor(webSocketUrl: string) {\r\n        super();\r\n        this.webSocketUrl = webSocketUrl;\r\n        this._pendingRequests = {};\r\n        this._webSocket = null;\r\n        this.hookUpEvents();\r\n        //this.connect(); //todo: connect AFTER construction!  > To allow for other events to hook up.\r\n    }\r\n\r\n    private hookUpEvents() {\r\n        this.on(\"websocket:close\", this.cleanup);\r\n        this.on(\"websocket:error\", this.handleWebSocketError);\r\n        this.on(\"websocket:incomingMessage\", this.handleMessage);\r\n    }\r\n\r\n    connect() {\r\n        if (this._webSocket) {\r\n            if (this._webSocket.readyState === WebSocket.OPEN) {\r\n                return;\r\n            }\r\n            this._webSocket.close();\r\n        }\r\n\r\n        this._webSocket = new WebSocket(this.webSocketUrl);\r\n\r\n        this._webSocket.onclose = (close) => {\r\n            this.emit(\"websocket:close\", close);\r\n        };\r\n        this._webSocket.onerror = (error) => {\r\n            this.emit(\"websocket:error\", error);\r\n        };\r\n        this._webSocket.onopen = () => {\r\n            this.emit(\"websocket:open\");\r\n        };\r\n        this._webSocket.onmessage = (message) => {\r\n            this.emit(\"websocket:incomingMessage\", message);\r\n        };\r\n    }\r\n\r\n    private cleanup(closeEvent: any) {\r\n        Object.keys(this._pendingRequests).forEach((requestId) => {\r\n            const {reject} = this._pendingRequests[requestId];\r\n            delete this._pendingRequests[requestId];\r\n            const error = new ConnectionError(\"WebSocket closed\");\r\n            error.closeEvent = closeEvent;\r\n            reject(error);\r\n        });\r\n    }\r\n\r\n    close() {\r\n        if (this._webSocket) {\r\n            this._webSocket.close();\r\n        }\r\n    }\r\n\r\n    private handleWebSocketError(error: any) {\r\n        console.warn(\"WebSocket error:\", error.stack || error);\r\n    }\r\n\r\n    send(message: Object) {\r\n        switch (this._webSocket.readyState) {\r\n            case WebSocket.CONNECTING:\r\n                return Promise.reject(\r\n                    new ConnectionError(\"WebSocket is still connecting\")\r\n                );\r\n            case WebSocket.CLOSING:\r\n                return Promise.reject(\r\n                    new ConnectionError(\"WebSocket is closing\")\r\n                );\r\n            case WebSocket.CLOSED:\r\n                return Promise.reject(\r\n                    new ConnectionError(\"WebSocket is closed\")\r\n                );\r\n            default:\r\n                return new Promise((resolve, reject) => {\r\n                    const jsonRpcMessage = {\r\n                        ...message,\r\n                        jsonrpc: \"2.0\",\r\n                        id: this._nextRequestId(),\r\n                    };\r\n                    this._pendingRequests[jsonRpcMessage.id] = {resolve, reject};\r\n                    this._webSocket.send(JSON.stringify(jsonRpcMessage));\r\n                    this.emit(\"websocket:outgoingMessage\", jsonRpcMessage);\r\n                });\r\n        }\r\n    }\r\n\r\n    private handleMessage(message) {\r\n        try {\r\n            const data = JSON.parse(message.data);\r\n            if (Object.hasOwnProperty.call(data, \"id\")) {\r\n                this.handleRpcResponse(data);\r\n            } else if (Object.hasOwnProperty.call(data, \"event\")) {\r\n                this.handleEvent(data);\r\n            } else {\r\n                console.warn(\r\n                    `Unknown message type received. Message was: ${message.data}`\r\n                );\r\n            }\r\n        } catch (error) {\r\n            if (error instanceof SyntaxError) {\r\n                console.warn(\r\n                    `WebSocket message parsing failed. Message was: ${message.data}`\r\n                );\r\n            } else {\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleRpcResponse(responseMessage) {\r\n        if (\r\n            !Object.hasOwnProperty.call(this._pendingRequests, responseMessage.id)\r\n        ) {\r\n            console.warn(\r\n                \"Unexpected response received. Message was:\",\r\n                responseMessage\r\n            );\r\n            return;\r\n        }\r\n        const {resolve, reject} = this._pendingRequests[responseMessage.id];\r\n        delete this._pendingRequests[responseMessage.id];\r\n        if (Object.hasOwnProperty.call(responseMessage, \"result\")) {\r\n            resolve(responseMessage.result);\r\n        } else if (Object.hasOwnProperty.call(responseMessage, \"error\")) {\r\n            const error = new ServerError(responseMessage.error.message);\r\n            error.code = responseMessage.error.code;\r\n            error.data = responseMessage.error.data;\r\n            reject(error);\r\n            console.warn(\"Server returned error:\", responseMessage.error);\r\n        } else {\r\n            const error = new OtherError(\"Response without 'result' or 'error' received\");\r\n            error.data = {response: responseMessage};\r\n            reject(error);\r\n            console.warn(\r\n                \"Response without 'result' or 'error' received. Message was:\",\r\n                responseMessage\r\n            );\r\n        }\r\n    }\r\n\r\n    private handleEvent(eventMessage) {\r\n        const data = {...eventMessage};\r\n        delete data.event;\r\n        const eventName = `event:${snakeToCamel(eventMessage.event)}`;\r\n        this.emit(\"event\", [eventName, data]);\r\n        this.emit(eventName, data);\r\n    }\r\n\r\n    static idCounter = -1;\r\n\r\n    _nextRequestId() {\r\n        return ++JsonRpcController.idCounter;\r\n    }\r\n}\r\n\r\nclass ConnectionError extends Error {\r\n    closeEvent?: any;\r\n\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"ConnectionError\";\r\n    }\r\n}\r\n\r\nclass ServerError extends Error {\r\n    code: any;\r\n    data: any;\r\n\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"ServerError\";\r\n    }\r\n}\r\n\r\nclass OtherError extends Error {\r\n    data: any;\r\n\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"OtherError\";\r\n    }\r\n}","// Type definitions for js v1.2.0, Mopidy v3.0.2 WebSocket API\r\n\r\nimport {JsonRpcController} from \"../typescript/jsonRpcController\";\r\nimport MopidyEventName = core.MopidyEventName;\r\n\r\nexport interface Options {\r\n    /**\r\n     * URL used when creating new WebSocket objects.\r\n     *\r\n     * In a browser environment, it defaults to\r\n     * ws://${document.location.host}/mopidy/ws. If the current page is served\r\n     * over HTTPS, it defaults to using wss:// instead of ws://.\r\n     *\r\n     * In a non-browser environment, where document.location isn't available, it\r\n     * defaults to ws://localhost/mopidy/ws.\r\n     */\r\n    webSocketUrl: string;\r\n    /**\r\n     * Whether or not to connect to the WebSocket on instance creation. Defaults\r\n     * to true.\r\n     */\r\n    autoConnect?: boolean;\r\n    /**\r\n     * The minimum number of milliseconds to wait after a connection error before\r\n     * we try to reconnect. For every failed attempt, the backoff delay is doubled\r\n     * until it reaches backoffDelayMax. Defaults to 1000.\r\n     */\r\n    backoffDelayMin?: number;\r\n    /**\r\n     * The maximum number of milliseconds to wait after a connection error before\r\n     * we try to reconnect. Defaults to 64000.\r\n     */\r\n    backoffDelayMax?: number;\r\n    /**\r\n     * If set, this object will be used to log errors from Mopidy.js. This is\r\n     * mostly useful for testing Mopidy.js. Defaults to console.\r\n     */\r\n}\r\n\r\ntype URI = string;\r\n\r\nnamespace models {\r\n    export type ModelType = \"album\" | \"artist\" | \"directory\" | \"playlist\" | \"track\";\r\n\r\n    export class TlTrack {\r\n        readonly tlid: number;\r\n        readonly track: Track;\r\n    }\r\n    export class Track {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly artists: Artist[];\r\n        readonly album: Album;\r\n        readonly composers: Artist[];\r\n        readonly performers: Artist[];\r\n        readonly genre: string;\r\n        readonly track_no: number;\r\n        readonly disc_no: number;\r\n        readonly date: string;\r\n        readonly length: number;\r\n        readonly bitrate: string;\r\n        readonly comment: string;\r\n        readonly musicbrainz_id: string;\r\n        readonly last_modified: number;\r\n    }\r\n    class SearchResult {\r\n        readonly uri: URI;\r\n        readonly tracks: Track[];\r\n        readonly artists: Artist[];\r\n        readonly albums: Album[];\r\n    }\r\n\r\n    class Artist {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly sortname: string;\r\n        readonly musicbrainz_id: string;\r\n    }\r\n\r\n    export class Album {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly artists: Artist[];\r\n        readonly num_tracks: number;\r\n        readonly num_discs: number;\r\n        readonly date: string;\r\n        readonly musicbrainz_id: string;\r\n    }\r\n\r\n    class Image {\r\n        readonly uri: URI;\r\n        readonly width: number;\r\n        readonly height: number;\r\n    }\r\n\r\n    export class Playlist {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly tracks: Track[];\r\n        readonly last_modified: number;\r\n        readonly length: number;\r\n    }\r\n\r\n    export class Ref {\r\n        readonly uri: URI;\r\n        name?: string;\r\n        readonly type: ModelType;\r\n    }\r\n}\r\nexport default models\r\n\r\nexport namespace core {\r\n    export type PlaybackState = \"playing\" | \"paused\" | \"stopped\";\r\n    type QueryField =\r\n        | \"uri\"\r\n        | \"track_name\"\r\n        | \"album\"\r\n        | \"artist\"\r\n        | \"albumartist\"\r\n        | \"composer\"\r\n        | \"performer\"\r\n        | \"track_no\"\r\n        | \"genre\"\r\n        | \"date\"\r\n        | \"comment\"\r\n        | \"any\";\r\n    type Query = { [key in QueryField]?: string[] };\r\n\r\n    export type MopidyEventName =\r\n        | \"event:trackPlaybackStarted\"\r\n        | \"event:trackPlaybackResumed\"\r\n        | \"state:online\"\r\n        | \"state:offline\"\r\n        | \"event:optionsChanged\"\r\n        | \"event:playlistChanged\"\r\n        | \"event:playlistDeleted\"\r\n        | \"event:volumeChanged\"\r\n        | \"event:muteChanged\"\r\n        | \"event:streamTitleChanged\"\r\n        | \"event:playbackStateChanged\"\r\n        | \"event:optionsValidationError\"\r\n        | \"event:tracklistChanged\"\r\n        | \"event:seeked\"\r\n        | \"event:playlistsLoaded\"\r\n        ;\r\n\r\n}\r\n\r\nexport class Mopidy {\r\n    _options: Options;\r\n    private _backoffDelay: number;\r\n    private rpcController: JsonRpcController;\r\n    constructor(options: Options) {\r\n        const defaultOptions = {\r\n            backoffDelayMin: 1000,\r\n                backoffDelayMax: 64000,\r\n            autoConnect: true,\r\n            webSocketUrl: ''\r\n        };\r\n        this._options = this._configure({...defaultOptions, ...options});\r\n        this._backoffDelay = this._options.backoffDelayMin;\r\n        this.rpcController = new JsonRpcController(this._options.webSocketUrl);\r\n        this._delegateEvents();\r\n        if (this._options.autoConnect) {\r\n            this.connect();\r\n        }\r\n    }\r\n\r\n    connect() {\r\n        this.rpcController.connect();\r\n    }\r\n\r\n    on(name: MopidyEventName | Function, callback?: any) {\r\n        this.rpcController?.on(name, callback);\r\n    }\r\n\r\n    private _configure(options: Options) {\r\n        if(options.webSocketUrl)\r\n            return options;\r\n\r\n        let protocol =\r\n            typeof document !== \"undefined\" && document.location.protocol === \"https:\"\r\n                ? \"wss://\"\r\n                : \"ws://\";\r\n        let currentHost =\r\n            (typeof document !== \"undefined\" && document.location.host) ||\r\n            \"localhost\";\r\n        options.webSocketUrl = `${protocol}${currentHost}/mopidy/ws`;\r\n        return options;\r\n    }\r\n\r\n  _delegateEvents() {\r\n    this.rpcController.on(\"websocket:close\", (closeEvent: any) => this._cleanup(closeEvent));\r\n    this.rpcController.on(\"websocket:open\", () => this._resetBackoffDelay());\r\n    this.rpcController.on(\"websocket:open\", () => this._onWebsocketOpen());\r\n    this.rpcController.on(\"state:offline\", () => this._reconnect());\r\n  }\r\n\r\n  eventOff(eventName?: string, callback?: any) {\r\n    if (!eventName) {\r\n      this.rpcController.removeAllListeners();\r\n      return;\r\n    }\r\n    if (!callback) {\r\n        this.rpcController.removeAllListeners(eventName);\r\n        return;\r\n    }\r\n  this.rpcController.removeListener(eventName, callback);\r\n  }\r\n\r\n  _cleanup(closeEvent) {\r\n    this.rpcController.emit(\"state\", \"state:offline\");\r\n    this.rpcController.emit(\"state:offline\");\r\n  }\r\n\r\n  _reconnect() {\r\n    // We asynchronously process the reconnect because we don't want to start\r\n    // emitting \"reconnectionPending\" events before we've finished handling the\r\n    // \"state:offline\" event, which would lead to emitting the events to\r\n    // listeners in the wrong order.\r\n    setTimeout(() => {\r\n      this.rpcController.emit(\"state\", [\r\n          \"reconnectionPending\",\r\n          { timeToAttempt: this._backoffDelay}\r\n      ]);\r\n      this.rpcController.emit(\"reconnectionPending\", {\r\n        timeToAttempt: this._backoffDelay,\r\n      });\r\n      setTimeout(() => {\r\n        this.rpcController.emit(\"state\", \"reconnecting\");\r\n        this.rpcController.emit(\"reconnecting\");\r\n        this.rpcController.connect();\r\n      }, this._backoffDelay);\r\n      this._backoffDelay *= 2;\r\n      if (this._backoffDelay > this._options.backoffDelayMax) {\r\n        this._backoffDelay = this._options.backoffDelayMax;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  _resetBackoffDelay() {\r\n    this._backoffDelay = this._options.backoffDelayMin;\r\n  }\r\n\r\n  close() {\r\n    this.eventOff(\"state:offline\", this._reconnect);\r\n    if (this.rpcController) {\r\n      this.rpcController.close();\r\n    }\r\n  }\r\n\r\n  send(message: Object) {\r\n      return this.rpcController?.send(message);\r\n  }\r\n\r\n  _onWebsocketOpen() {\r\n    this.rpcController.emit(\"state\", \"state:online\");\r\n    this.rpcController.emit(\"state:online\");\r\n  }\r\n}\r\n\r\n","// Helper function to provide a reference time in milliseconds.\r\nlet now = /* Sinon does not currently support faking `window.performance`\r\n             (see https://github.com/sinonjs/sinon/issues/803).\r\n             Changing this to only rely on `new Date().getTime()\r\n             in the interim in order to allow testing of the\r\n             progress timer from MMW.\r\n\r\n             typeof window.performance !== 'undefined' &&\r\n             typeof window.performance.now !== 'undefined' &&\r\n             window.performance.now.bind(window.performance) || Date.now ||*/\r\n    function () {\r\n        return new Date().getTime();\r\n    };\r\n\r\ninterface TimerOptions {\r\n    // Your callback for updating UI state, required.\r\n    callback: (position:number, duration: number) => void,\r\n    // Target frame rate when using legacy setTimeout fallback, default: 30.\r\n    fallbackTargetFrameRate: number,\r\n    // Force legacy setTimeout fallback for testing, default: false.\r\n    disableRequestAnimationFrame: boolean\r\n}\r\n\r\ntype TimerCallback = (position:number, duration:number)=> void;\r\n\r\n// Creates a new timer object, works with both 'new ProgressTimer(options)'\r\n// and just 'ProgressTimer(options). Optionally the timer can also be\r\n// called with only the callback instead of options.\r\nexport class ProgressTimer {\r\n    callback: TimerCallback;\r\n    // Target frame rate when using legacy setTimeout fallback, default: 30.\r\n    fallbackTargetFrameRate = 30;\r\n    // Force legacy setTimeout fallback for testing, default: false.\r\n    disableRequestAnimationFrame = false;\r\n\r\n    _updateId = null;\r\n    _state = null;  // Gets initialized by the set() call.\r\n    private readonly _schedule: (timestamp: number) => number;\r\n    private readonly _cancel: any;\r\n\r\n    constructor(options: TimerOptions | TimerCallback) {\r\n        if (typeof options === 'function') {\r\n            this.callback = options;\r\n        } else {\r\n            this.callback = options.callback;\r\n            this.fallbackTargetFrameRate = options.fallbackTargetFrameRate;\r\n            this.disableRequestAnimationFrame = options.disableRequestAnimationFrame;\r\n        }\r\n\r\n        this._updateId = null;\r\n        this._state = null;  // Gets initialized by the set() call.\r\n\r\n        let frameDuration = 1000 / this.fallbackTargetFrameRate;\r\n\r\n        let useFallback = (\r\n            typeof window.requestAnimationFrame === 'undefined' ||\r\n            typeof window.cancelAnimationFrame === 'undefined' ||\r\n            options['disableRequestAnimationFrame'] || false);\r\n\r\n        // Make sure this works in _update.\r\n        let update = this._update.bind(this);\r\n\r\n        if (useFallback) {\r\n            this._schedule = function (timestamp: number) {\r\n                let timeout = Math.max(timestamp + frameDuration - now(), 0);\r\n                return window.setTimeout(update, Math.floor(timeout));\r\n            };\r\n            this._cancel = window.clearTimeout.bind(window);\r\n        } else {\r\n            this._schedule = window.requestAnimationFrame.bind(window, update);\r\n            this._cancel = window.cancelAnimationFrame.bind(window);\r\n        }\r\n\r\n        this.reset(); // Reuse reset code to ensure we start in the same state.\r\n    }\r\n\r\n// If called with one argument the previous duration is preserved. Note\r\n// that the position can be changed while the timer is running.\r\n    set(position: number, duration: number = undefined) {\r\n        if (!duration) {\r\n            // Fallback to previous duration, whatever that was.\r\n            duration = this._state.duration;\r\n        }\r\n\r\n        // Round down and make sure zero and null are treated as inf.\r\n        duration = Math.floor(Math.max(\r\n            duration === null ? Infinity : duration || Infinity, 0));\r\n\r\n        // Make sure '0 <= position <= duration' always holds.\r\n        position = Math.floor(Math.min(Math.max(position || 0, 0), duration));\r\n\r\n        this._state = {\r\n            initialTimestamp: null,\r\n            initialPosition: position,\r\n            position: position,\r\n            duration: duration\r\n        };\r\n\r\n        // Update right away if we don't have anything running.\r\n        if (this._updateId === null) {\r\n            // TODO: Consider wrapping this in a try/catch?\r\n            this.callback(position, duration);\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Start the timer if it is not already running.\r\n    start() {\r\n        if (this._updateId === null) {\r\n            this._updateId = this._schedule(0);\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Cancel the timer if it us currently tracking progress.\r\n    stop() {\r\n        if (this._updateId !== null) {\r\n            this._cancel(this._updateId);\r\n\r\n            // Ensure we correctly reset the initial position and timestamp.\r\n            this.set(this._state.position, this._state.duration);\r\n            this._updateId = null;  // Last step to avoid callback in set()\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Marks the timer as stopped, sets position to zero and duration to inf.\r\n    reset() {\r\n        return this.stop().set(0, Infinity);\r\n    };\r\n\r\n// Calls the user callback with the current position/duration and then\r\n// schedules the next update run via _schedule if we haven't finished.\r\n    _update(timestamp: number) {\r\n        let state = this._state;  // We refer a lot to state, this is shorter.\r\n\r\n        // Make sure setTimeout has a timestamp and store first reference time.\r\n        timestamp = timestamp || now();\r\n        state.initialTimestamp = state.initialTimestamp || timestamp;\r\n\r\n        // Recalculate position according to start location and reference.\r\n        state.position = (\r\n            state.initialPosition + timestamp - state.initialTimestamp);\r\n\r\n        // Ensure callback gets an integer and that 'position <= duration'.\r\n        let userPosisition = Math.min(\r\n            Math.floor(state.position), state.duration);\r\n\r\n        // TODO: Consider wrapping this in a try/catch?\r\n        this.callback(userPosisition, state.duration);\r\n        // Workaround for https://github.com/adamcik/media-progress-timer/issues/3\r\n        // Mopidy <= 1.1.2 does not always return the correct track position as\r\n        // track changes are being done, which can cause the timer to die unexpectedly.\r\n        //if (state.position < state.duration) {\r\n        this._updateId = this._schedule(timestamp);  // Schedule update.\r\n        //} else {\r\n        //    this._updateId = null;  // Unset since we didn't reschedule.\r\n        //}\r\n    }\r\n}\r\n","import {ProgressTimer} from \"./timer\";\r\nimport {Mopidy} from \"../js/mopidy\";\r\n\r\nfunction delay_exponential (base: number | 'rand', growthFactor: number, attempts: number) {\r\n    /* Calculate number of beats between syncs based on exponential function.\r\n    The format is::\r\n\r\n        base * growthFactor ^ (attempts - 1)\r\n\r\n    If ``base`` is set to 'rand' then a random number between\r\n    0 and 1 will be used as the base.\r\n    Base must be greater than 0.\r\n    */\r\n    if (base === 'rand') {\r\n        base = Math.random()\r\n    }\r\n    // console.log(base + ' * (Math.pow(' + growthFactor + ', (' + attempts + ' - 1)) = ' + base * (Math.pow(growthFactor, (attempts - 1))))\r\n    return base * (Math.pow(growthFactor, (attempts - 1)))\r\n}\r\n\r\nenum SYNC_STATE {\r\n    NOT_SYNCED=0,\r\n    SYNCING= 1,\r\n    SYNCED= 2\r\n}\r\n\r\nexport class SyncedProgressTimer {\r\n    _maxAttempts: number;\r\n    _mopidy: Mopidy;\r\n    syncState = SYNC_STATE.NOT_SYNCED;\r\n    _isSyncScheduled = false;\r\n    _scheduleID = null;\r\n    _syncAttemptsRemaining: number ;\r\n    _previousSyncPosition = null;\r\n    _duration = null;\r\n    _isConnected = false;\r\n    positionNode: Text;\r\n    durationNode: Text;\r\n    private _progressTimer: ProgressTimer;\r\n\r\n    constructor(maxAttempts: number, mopidy: Mopidy) {\r\n        this._maxAttempts = maxAttempts;\r\n        this._mopidy = mopidy;\r\n        this._syncAttemptsRemaining = this._maxAttempts;\r\n\r\n        this.positionNode = document.createTextNode('');\r\n        this.durationNode = document.createTextNode('');\r\n        //todo\r\n        // $('#songelapsed').empty().append(this.positionNode)\r\n        // $('#songlength').empty().append(this.durationNode)\r\n\r\n        this._progressTimer = new ProgressTimer( (position: number, duration: number) => {\r\n            this.timerCallback(position, duration);\r\n            }\r\n        );\r\n\r\n        //todo\r\n        // this._mopidy.on('state:online', $.proxy(function () { this._isConnected = true }), this)\r\n        // this._mopidy.on('state:offline', $.proxy(function () { this._isConnected = false }), this)\r\n    }\r\n\r\n\r\n    static format(milliseconds: number) {\r\n        if (milliseconds === Infinity) {\r\n            return '';\r\n        } else if (milliseconds === 0) {\r\n            return '0:00';\r\n        }\r\n\r\n        let seconds = Math.floor(milliseconds / 1000);\r\n        const minutes = Math.floor(seconds / 60);\r\n        seconds = seconds % 60;\r\n\r\n        let secondString = seconds < 10 ? '0' + seconds : seconds.toString();\r\n        return minutes + ':' + secondString;\r\n    }\r\n\r\n    timerCallback(position: number, duration: number) {\r\n        this._update(position);\r\n        if (this._isSyncScheduled && this._isConnected) {\r\n            this._doSync(position, duration)\r\n        }\r\n    }\r\n\r\n    _update(position: number) {\r\n        switch (this.syncState) {\r\n            case SYNC_STATE.NOT_SYNCED:\r\n                // Waiting for Mopidy to provide a target position.\r\n                this.positionNode.nodeValue = '(wait)'\r\n                break\r\n            case SYNC_STATE.SYNCING:\r\n                // Busy seeking to new target position.\r\n                this.positionNode.nodeValue = '(sync)'\r\n                break\r\n            case SYNC_STATE.SYNCED:\r\n                this._previousSyncPosition = position\r\n                this.positionNode.nodeValue = SyncedProgressTimer.format(position)\r\n                //todo: document.getElementById('trackslider').val(position).slider('refresh')\r\n                break\r\n        }\r\n    }\r\n\r\n    _scheduleSync(milliseconds: number) {\r\n        // Use an anonymous callback to set a boolean value, which should be faster to\r\n        // check in the timeout callback than doing another function call.\r\n        clearTimeout(this._scheduleID)\r\n        this._isSyncScheduled = false\r\n        if (milliseconds >= 0) {\r\n            this._scheduleID = setTimeout(() => {\r\n                this._isSyncScheduled = true;\r\n            }, milliseconds);\r\n        }\r\n    }\r\n\r\n    _doSync(position: number, duration: number) {\r\n        // let ready = !(duration === Infinity && position === 0);  // Timer has been properly initialized.\r\n        // if (!ready) {\r\n        //     // Don't try to sync if progress timer has not been initialized yet.\r\n        //     return;\r\n        // }\r\n        //\r\n        // this._scheduleSync(-1); // Ensure that only one sync process is active at a time.\r\n        //\r\n        // let _this = this;\r\n        // _this.commands.core.playback.getTimePosition().then(function (targetPosition: number) {\r\n        //     if (_this.syncState === SYNC_STATE.NOT_SYNCED) {\r\n        //         _this.syncState = SYNC_STATE.SYNCING;\r\n        //     }\r\n        //     if (Math.abs(targetPosition - position) <= 500) {\r\n        //         // Less than 500ms == in sync.\r\n        //         _this._syncAttemptsRemaining = Math.max(_this._syncAttemptsRemaining - 1, 0);\r\n        //         if (_this._syncAttemptsRemaining < _this._maxAttempts - 1 && _this._previousSyncPosition !== targetPosition) {\r\n        //             // Need at least two consecutive syncs to know that Mopidy\r\n        //             // is progressing playback and we are in sync.\r\n        //             _this.syncState = SYNC_STATE.SYNCED;\r\n        //         }\r\n        //         _this._previousSyncPosition = targetPosition;\r\n        //         // Step back exponentially while increasing number of callbacks.\r\n        //         _this._scheduleSync(delay_exponential(0.25, 2, _this._maxAttempts - _this._syncAttemptsRemaining) * 1000);\r\n        //     } else {\r\n        //         // Drift is too large, re-sync with Mopidy.\r\n        //         _this.syncState = SYNC_STATE.SYNCING;\r\n        //         _this._syncAttemptsRemaining = _this._maxAttempts;\r\n        //         _this._previousSyncPosition = null;\r\n        //         _this._scheduleSync(1000);\r\n        //         _this._progressTimer.set(targetPosition);\r\n        //     }\r\n        // });\r\n    }\r\n\r\n    set(position: number, duration: number = undefined) {\r\n        this.syncState = SYNC_STATE.NOT_SYNCED;\r\n        this._syncAttemptsRemaining = this._maxAttempts;\r\n        // Workaround for https://github.com/adamcik/media-progress-timer/issues/3\r\n        // This causes the timer to die unexpectedly if the position exceeds\r\n        // the duration slightly.\r\n        if (this._duration && this._duration < position) {\r\n            position = this._duration - 1\r\n        }\r\n        if (arguments.length === 1) {\r\n            this._progressTimer.set(position)\r\n        } else {\r\n            this._duration = duration\r\n            this._progressTimer.set(position, duration)\r\n            this.durationNode.nodeValue = SyncedProgressTimer.format(duration)\r\n        }\r\n\r\n        this.updatePosition(position);\r\n        //todo document.getElementById('trackslider').val(position).slider('refresh')\r\n\r\n        return this\r\n    }\r\n\r\n    start() {\r\n        this.syncState = SYNC_STATE.NOT_SYNCED\r\n        this._scheduleSync(0)\r\n        this._progressTimer.start()\r\n        return this\r\n    }\r\n\r\n    stop() {\r\n        this._progressTimer.stop()\r\n        this._scheduleSync(-1)\r\n        if (this.syncState !== SYNC_STATE.SYNCED && this._previousSyncPosition) {\r\n            // Timer was busy trying to sync when it was stopped, fallback to displaying the last synced position on screen.\r\n            this.positionNode.nodeValue = SyncedProgressTimer.format(this._previousSyncPosition)\r\n        }\r\n        return this\r\n    }\r\n\r\n    reset() {\r\n        this.stop()\r\n        this.set(0, Infinity)\r\n\r\n        return this\r\n    }\r\n\r\n    updatePosition(position: number) {\r\n        if (!(this._duration === Infinity && position === 0)) {\r\n            this.positionNode.nodeValue = SyncedProgressTimer.format(position)\r\n        } else {\r\n            this.positionNode.nodeValue = ''\r\n        }\r\n    }\r\n}","import models, {Mopidy} from \"../js/mopidy\";\r\nimport {SyncedProgressTimer} from \"./synced_timer\";\r\nimport {ViewModel} from \"./model\";\r\nimport {EboPlayerDataType, View} from \"./views/view\";\r\nimport {Controller} from \"./controller\";\r\n\r\nimport {DeepReadonly} from \"./modelTypes\";\r\n\r\nexport class State {\r\n    mopidy: Mopidy;\r\n    syncedProgressTimer: SyncedProgressTimer;\r\n\r\n    // values for controls\r\n    play: boolean = false;\r\n    random: boolean = false;\r\n    repeat: boolean = false;\r\n    consume: boolean = false;\r\n    single: boolean = false;\r\n    mute: boolean = false;\r\n    positionChanging: boolean = false;\r\n    popupData = {};  // TODO: Refactor into one shared cache,\r\n    songlength: number = 0;\r\n\r\n    streamUris = {}; //TODO: EBO added this to make gui.ts compile.\r\n\r\n    // array of cached playlists (not only user-playlists, also search, artist, album-playlists)\r\n    playlists = {};  // TODO: Refactor into one shared cache,\r\n    customTracklists =  [];  // TODO: Refactor into one shared cache,\r\n\r\n    private readonly model: ViewModel;\r\n    private readonly controller: Controller;\r\n\r\n    constructor(mopidy: Mopidy, syncedProgressTimer: SyncedProgressTimer, model: ViewModel, controller: Controller) {\r\n        this.mopidy = mopidy;\r\n        this.syncedProgressTimer = syncedProgressTimer;\r\n        this.model = model;\r\n        this.controller = controller;\r\n    }\r\n    views: View[] = [];\r\n    getModel = (): DeepReadonly<ViewModel> => this.model;\r\n    getController = () => this.controller;\r\n\r\n    addViews(...views:View[]) {\r\n        this.views.push(...views);\r\n        views.forEach(v => v.bindRecursive());\r\n    }\r\n\r\n    async getRequiredData()  {\r\n        let requiredData = new Set<EboPlayerDataType>();\r\n        this.views.forEach(v => {\r\n            v.getRequiredDataTypesRecursive().forEach((dataType: EboPlayerDataType) => requiredData.add(dataType));\r\n        });\r\n        this.controller.getRequiredDataTypesRecursive().forEach((dataType => requiredData.add(dataType)));\r\n\r\n        for (const dataType of requiredData) {\r\n            await this.controller.mopidyProxy.fetchRequiredData(dataType);\r\n            await this.controller.webProxy.fetchRequiredData(dataType);\r\n        }\r\n\r\n        await this.controller.fetchAllAlbums();\r\n        this.controller.localStorageProxy.loadCurrentBrowseFilter();\r\n        this.controller.localStorageProxy.loadBrowseFiltersBreadCrumbs();\r\n        this.controller.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n            this.controller.filterBrowseResults();\r\n        });\r\n    }\r\n}\r\n\r\nlet state: State = undefined; //todo: assuming here that all calls to getState() will receive a valid state object.\r\n\r\nexport function setState(newState: State) { state = newState; }\r\nconst getState = () => state;\r\n\r\nexport default getState;","import {FilterBreadCrumbType} from \"./modelTypes\";\r\n\r\nexport class BreadCrumb<T> {\r\n    id: number;\r\n    label: string;\r\n    data: T;\r\n    type: string\r\n\r\n    private static nextId = 1;\r\n\r\n    constructor(label: string, value: T, type: string) {\r\n        this.label = label;\r\n        this.data = value;\r\n        this.id = BreadCrumb.nextId++;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport class BreadCrumbStack<T extends BreadCrumb<any>> { //todo: use extends Array<BreadCrumb<T>>?\r\n    private breadCrumbStack: T[] = [];\r\n\r\n    push(crumb: T) {\r\n        this.breadCrumbStack.push(crumb);\r\n    }\r\n\r\n    pop() {\r\n        return this.breadCrumbStack.pop();\r\n    }\r\n    list = () => this.breadCrumbStack;\r\n\r\n    resetTo(id: number) {\r\n        let index = this.breadCrumbStack.findIndex((breadCrumb, index, obj) => {\r\n            return breadCrumb.id == id;\r\n        });\r\n        this.breadCrumbStack = this.breadCrumbStack.slice(0, index+1);\r\n    }\r\n\r\n    clear() {\r\n        this.breadCrumbStack = [];\r\n    }\r\n\r\n    getLast(): T | undefined {\r\n        if(this.breadCrumbStack.length == 0)\r\n            return undefined;\r\n        return this.breadCrumbStack[this.breadCrumbStack.length-1];\r\n    }\r\n\r\n    get(id: number): T | undefined {\r\n        return this.breadCrumbStack.find(crumb => crumb.id == id);\r\n    }\r\n\r\n    setArray(breadCrumbsArray: T[]) {\r\n        this.breadCrumbStack = breadCrumbsArray;\r\n    }\r\n}","import models from \"../js/mopidy\";\r\nimport {BreadCrumb} from \"./breadCrumb\";\r\nimport Ref = models.Ref;\r\nimport Track = models.Track;\r\n\r\nexport enum TrackType { None, File, Stream}\r\n\r\nexport type Uri = string;\r\nexport class BreadCrumbBrowseFilter extends BreadCrumb<BrowseFilter> {\r\n    constructor(label: string, filter: BrowseFilter) {\r\n        super(label, filter, \"browseFilter\");\r\n    }\r\n}\r\nexport class BreadCrumbRef extends BreadCrumb<Ref> {\r\n    constructor(label: string, ref: Ref) {\r\n        super(label, ref, \"ref\");\r\n    }\r\n}\r\nexport type FilterBreadCrumbType = BreadCrumbRef | BreadCrumbBrowseFilter;\r\n\r\nexport class BrowseFilter {\r\n    searchText: string;\r\n    album: boolean;\r\n    track: boolean;\r\n    radio: boolean;\r\n    artist: boolean;\r\n    playlist: boolean;\r\n    genre: boolean;\r\n\r\n    constructor() {\r\n        this.searchText = \"\";\r\n        this.track = false;\r\n        this.artist = false;\r\n        this.genre = false;\r\n        this.radio = false;\r\n        this.playlist = false;\r\n        this.album = false;\r\n    }\r\n\r\n    isNoTypeSelected(): boolean {\r\n        return !(this.album || this.track || this.radio || this.artist || this.playlist || this.genre);\r\n    }\r\n}\r\n\r\nexport interface FileTrackModel {\r\n    type: TrackType.File;\r\n    track: models.Track;\r\n    title: string,\r\n    composer?: string,\r\n    performer: string,\r\n    songlenght: number,\r\n    //...more properties?\r\n}\r\n\r\nexport interface StreamTrackModel {\r\n    type: TrackType.Stream;\r\n    track: models.Track;\r\n    name: string,\r\n    infoLines: string[]\r\n}\r\n\r\nexport interface NoneTrackModel {\r\n    type: TrackType.None;\r\n}\r\n\r\nexport enum EboplayerEvents {\r\n    volumeChanged = \"eboplayer.volumeChanged\",\r\n    connectionChanged = \"eboplayer.connectionChanged\",\r\n    playStateChanged = \"eboplayer.playbackStateChanged\",\r\n    messageChanged = \"eboplayer.messageChanged\",\r\n    currentTrackChanged = \"eboplayer.currentTrackChanged\",\r\n    selectedTrackChanged = \"eboplayer.selectedTrackChanged\",\r\n    activeStreamLinesChanged = \"eboplayer.activeStreamLinesChanged\",\r\n    historyChanged = \"eboplayer.historyChanged\",\r\n    trackListChanged = \"eboplayer.trackListChanged\",\r\n    browseFilterChanged = \"eboplayer.browseFilterChanged\",\r\n    currentRefsLoaded = \"eboplayer.currentRefsLoaded\",\r\n    refsFiltered = \"eboplayer.refsFiltered\",\r\n    longPress = \"eboplayer.longPress\",\r\n    breadCrumbsChanged = \"eboplayer.breadCrumbsChanged\",\r\n    playPressed = \"eboplayer.playPressed\",\r\n    pausePressed = \"eboplayer.pausePressed\",\r\n    stopPressed = \"eboplayer.stopPressed\",\r\n    changingVolume = \"eboplayer.changingVolume\",\r\n    viewChanged = \"eboplayer.viewChanged\",\r\n    albumToViewChanged = \"eboplayer.albumToViewChanged\",\r\n}\r\n\r\nexport type TrackModel = NoneTrackModel | FileTrackModel | StreamTrackModel;\r\nexport type DeepReadonly<T> = T extends Function ? T :\r\n    T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } :\r\n        T;\r\n\r\nexport enum ConnectionState {Offline, Online}\r\n\r\nexport enum MessageType { None, Info, Warning, Error}\r\n\r\nexport interface Message {\r\n    type: MessageType,\r\n    message: string\r\n}\r\n\r\nexport interface PlaybackModesState {\r\n    repeat: boolean,\r\n    random: boolean,\r\n    consume: boolean,\r\n    single: boolean\r\n}\r\n\r\nexport enum PlayState {\r\n    stopped = \"stopped\",\r\n    playing = \"playing\",\r\n    paused = \"paused\"\r\n}\r\n\r\nexport interface HistoryRef {\r\n    __model__: string,\r\n    name: string;\r\n    type: string;\r\n    uri: string;\r\n}\r\n\r\nexport interface HistoryLine {\r\n    timestamp: number;\r\n    ref: HistoryRef;\r\n}\r\n\r\nexport type LibraryItem = models.Track[];\r\nexport type LibraryDict = { [index: string]: LibraryItem };\r\n\r\nexport interface StreamTitles {\r\n    uri: string;\r\n    active_titles: string[]\r\n}\r\n\r\nexport enum AlbumDataType {\r\n    None,\r\n    Loading,\r\n    Loaded,\r\n    StreamLinesLoaded\r\n}\r\n\r\ninterface AlbumDataNone {\r\n    type: AlbumDataType.None;\r\n}\r\n\r\ninterface AlbumDataLoading {\r\n    type: AlbumDataType.Loading;\r\n}\r\n\r\nexport interface AlbumDataLoaded {\r\n    type: AlbumDataType.Loaded;\r\n    tracks: Track[];\r\n    albumTrack?: models.Track;\r\n    albumInfo: models.Album;\r\n}\r\n\r\nexport interface AlbumStreamLinesLoaded {\r\n    type: AlbumDataType.StreamLinesLoaded;\r\n    lines: string[][];\r\n    albumTrack: models.Track;\r\n}\r\n\r\nexport const AlbumNone: AlbumDataNone = {\r\n    type: AlbumDataType.None\r\n}\r\nconst AlbumLoading: AlbumDataLoading = {\r\n    type: AlbumDataType.Loading\r\n}\r\nexport type AlbumData = AlbumDataLoaded | AlbumDataNone | AlbumDataLoading | AlbumStreamLinesLoaded;\r\n\r\nexport enum Views {\r\n    NowPlaying = \"#NowPlaying\",\r\n    Browse = \"#Browse\",\r\n    Album = \"#Album\"\r\n}","import models from \"../js/mopidy\";\r\nimport {AllRefs, Refs, SearchResult} from \"./refs\";\r\nimport {BrowseFilter, ConnectionState, EboplayerEvents, FilterBreadCrumbType, HistoryLine, LibraryDict, LibraryItem, Message, MessageType, NoneTrackModel, PlaybackModesState, PlayState, StreamTitles, TrackModel, TrackType, Views} from \"./modelTypes\";\r\nimport TlTrack = models.TlTrack;\r\nimport Ref = models.Ref;\r\nimport {BreadCrumb, BreadCrumbStack} from \"./breadCrumb\";\r\n\r\nexport interface ViewModel extends EventTarget {\r\n    getConnectionState: () => ConnectionState;\r\n    getCurrentTrack: () => string;\r\n    getSelectedTrack: () => string | undefined;\r\n    getCurrentMessage: () => Message;\r\n    getVolume: () => number;\r\n    getPlayState: () => PlayState;\r\n    getActiveStreamLines: () => StreamTitles;\r\n    getHistory: () => HistoryLine[];\r\n    getTrackInfo(uri: string): LibraryItem;\r\n    getCurrentBrowseFilter: () => BrowseFilter;\r\n    getCurrentSearchResults(): SearchResult[];\r\n    getTrackList(): TlTrack[];\r\n    getBreadCrumbs(): BrowseFilterBreadCrumbs;\r\n    getView(): Views;\r\n    getAlbumToView(): string;\r\n}\r\n\r\nexport type BrowseFilterBreadCrumbs = BreadCrumbStack<FilterBreadCrumbType>;\r\n\r\n// Model contains the data to be viewed and informs the view of changes through events.\r\n// Views should not update the model directly. See ViewModel for that.\r\nexport class Model extends EventTarget implements ViewModel {\r\n    static NoTrack: TrackModel = { type: TrackType.None } as NoneTrackModel;\r\n    currentTrack: string;\r\n    //note that selectedTrack is not part of the mopidy server.\r\n    //don't set selectedTrack to currentTrack unless you want it displayed\r\n    selectedTrack?: string;\r\n    volume: number;\r\n    connectionState: ConnectionState = ConnectionState.Offline;\r\n    currentMessage: Message = {\r\n        type: MessageType.None,\r\n        message: \"\"\r\n    };\r\n\r\n    playbackModesState: PlaybackModesState = {\r\n        repeat: false,\r\n        random: false,\r\n        consume: false,\r\n        single: false\r\n    }\r\n    private playState: PlayState;\r\n    private activeStreamLines: StreamTitles;\r\n    private history: HistoryLine[];\r\n    private trackList: TlTrack[] = [];\r\n    private libraryCache: Map<string, LibraryItem> = new Map();\r\n    private currentBrowseFilter= new BrowseFilter();\r\n    private filterBreadCrumbStack: BreadCrumbStack<FilterBreadCrumbType> = new BreadCrumbStack<FilterBreadCrumbType>();\r\n\r\n    private allRefs?: Refs;\r\n    private currentRefs?: Refs;\r\n    private view: Views = Views.NowPlaying;\r\n    private albumToViewUri: string;\r\n    // private albumCache: Set<LibraryItem> = new Map();\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    pushBreadCrumb(crumb: BreadCrumb<any>) {\r\n        this.filterBreadCrumbStack.push(crumb);\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n    popBreadCrumb() {\r\n        let crumb = this.filterBreadCrumbStack.pop();\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n        return crumb;\r\n    }\r\n\r\n    getBreadCrumbs = () => this.filterBreadCrumbStack;\r\n\r\n    resetBreadCrumbsTo(id: number) {\r\n        this.filterBreadCrumbStack.resetTo(id);\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n\r\n    clearBreadCrumbs() {\r\n        this.filterBreadCrumbStack.clear();\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n\r\n    setAllRefs(refs: Refs) {\r\n        this.allRefs = refs;\r\n    }\r\n\r\n    getCurrentSearchResults(): SearchResult[] {\r\n        return this.currentRefs?.getSearchResults() ?? [] as SearchResult[];\r\n    }\r\n\r\n    getAllRefs = () => this.allRefs;\r\n\r\n    filterCurrentRefs(){\r\n        if(!this.currentRefs)\r\n            return;\r\n        this.currentRefs.browseFilter = this.currentBrowseFilter;\r\n        this.currentRefs.filter();\r\n        this.dispatchEvent(new Event(EboplayerEvents.refsFiltered));\r\n    }\r\n    setConnectionState(state: ConnectionState) {\r\n        this.connectionState  = state;\r\n        if(this.connectionState == ConnectionState.Online)\r\n            this.clearMessage();\r\n        else\r\n            this.setErrorMessage(\"Offline\");\r\n        this.dispatchEvent(new Event(EboplayerEvents.connectionChanged));\r\n    }\r\n\r\n    getConnectionState = () => this.connectionState;\r\n\r\n    getTrackInfo(uri: string): LibraryItem {\r\n        return this.libraryCache.get(uri);\r\n    }\r\n\r\n    getCurrentBrowseFilter = () => this.currentBrowseFilter;\r\n    setCurrentBrowseFilter(browseFilter: BrowseFilter) {\r\n        this.currentBrowseFilter = browseFilter;\r\n        this.dispatchEvent(new Event(EboplayerEvents.browseFilterChanged));\r\n    }\r\n\r\n    setBrowseFilterBreadCrumbs(breadCrumbStack: BreadCrumbStack<FilterBreadCrumbType>) {\r\n        this.filterBreadCrumbStack = breadCrumbStack;\r\n        this.dispatchEvent(new Event(EboplayerEvents.breadCrumbsChanged));\r\n    }\r\n\r\n    getCurrentTrack(): string {\r\n        return this.currentTrack;\r\n    }\r\n\r\n    setCurrentTrack(track: TrackModel) {\r\n        if(track.type == TrackType.None) {\r\n            this.currentTrack = undefined;\r\n            return;\r\n        }\r\n        this.currentTrack = track.track.uri;\r\n        this.addToLibraryCache(this.currentTrack, [track.track]);\r\n        this.dispatchEvent(new Event(EboplayerEvents.currentTrackChanged));\r\n    }\r\n\r\n    getSelectedTrack = () => this.selectedTrack;\r\n\r\n    setSelectedTrack(uri?: string) {\r\n        if(uri == \"\")\r\n            this.selectedTrack = undefined;\r\n        else\r\n            this.selectedTrack = uri;\r\n        this.dispatchEvent(new Event(EboplayerEvents.selectedTrackChanged));\r\n    }\r\n\r\n    setVolume(volume: number) {\r\n        this.volume = volume;\r\n        this.dispatchEvent(new Event(EboplayerEvents.volumeChanged));\r\n    }\r\n\r\n    private setMessage(message: Message) {\r\n        this.currentMessage = message;\r\n        this.dispatchEvent(new Event(EboplayerEvents.messageChanged));\r\n    }\r\n\r\n    getCurrentMessage = () => this.currentMessage;\r\n\r\n    clearMessage() {\r\n        this.setMessage( { type: MessageType.None, message: \"\"});\r\n    }\r\n    setInfoMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Info, message});\r\n    }\r\n    setWarningMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Warning, message});\r\n    }\r\n    setErrorMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Error, message});\r\n    }\r\n\r\n    setPlaybackState(state: PlaybackModesState) {\r\n        this.playbackModesState = {...state};\r\n        this.dispatchEvent(new Event(EboplayerEvents.playStateChanged));\r\n    }\r\n\r\n    getVolume = () => this.volume;\r\n\r\n    getPlayState(): PlayState {\r\n        return this.playState;\r\n    }\r\n\r\n    setPlayState(state: PlayState) {\r\n        this.playState = state;\r\n        this.dispatchEvent(new Event(EboplayerEvents.playStateChanged));\r\n    }\r\n\r\n    setActiveStreamLinesHistory(streamTitles: StreamTitles) {\r\n        if(!streamTitles) //todo: why can this be empty (at PC startup?)\r\n            return;\r\n        streamTitles.active_titles = Object.values<string>(streamTitles.active_titles); //todo: this really is a hack. Can't python return an array, like normal people?\r\n        this.activeStreamLines = streamTitles;\r\n        this.dispatchEvent(new Event(EboplayerEvents.activeStreamLinesChanged));\r\n    }\r\n\r\n    getActiveStreamLines = () => this.activeStreamLines;\r\n\r\n    setHistory(history: HistoryLine[]) {\r\n        this.history = history;\r\n        this.dispatchEvent(new Event(EboplayerEvents.historyChanged));\r\n    }\r\n\r\n    getHistory = () => this.history;\r\n\r\n    setTrackList(trackList: TlTrack[]) {\r\n        this.trackList = trackList;\r\n        this.dispatchEvent(new Event(EboplayerEvents.trackListChanged));\r\n    }\r\n    getTrackList = () => this.trackList;\r\n\r\n    //Doesn't overwrite\r\n    addToLibraryCache(uri: string, item: LibraryItem) {\r\n        if(!this.libraryCache.has(uri))\r\n        this.libraryCache.set(uri, item);\r\n    }\r\n\r\n    updateLibraryCache(uri: string, item: LibraryItem) {\r\n        this.libraryCache.set(uri, item);\r\n    }\r\n\r\n    //Overwrites!\r\n    addDictToLibraryCache(dict: LibraryDict) {\r\n        for(let key in dict) {\r\n            this.updateLibraryCache(key, dict[key]);\r\n        }\r\n    }\r\n\r\n    getTrackFromCache(uri: string): LibraryItem | undefined {\r\n        return this.libraryCache.get(uri);\r\n    }\r\n\r\n    setCurrentRefs(refs: Refs) {\r\n        this.currentRefs = refs;\r\n        this.dispatchEvent(new Event(EboplayerEvents.currentRefsLoaded));\r\n    }\r\n\r\n    setView(view: Views) {\r\n        this.view = view;\r\n        this.dispatchEvent(new Event(EboplayerEvents.viewChanged));\r\n    }\r\n    getView = () => this.view;\r\n\r\n    setAlbumToView(uri: string) {\r\n        this.albumToViewUri = uri;\r\n        this.dispatchEvent(new Event(EboplayerEvents.albumToViewChanged));\r\n    }\r\n    getAlbumToView = () => this.albumToViewUri;\r\n}\r\n","import {EboPlayerDataType} from \"./view\";\r\n\r\nexport interface Parent<Child> {\r\n    addChildren(...children: Child[]): void;\r\n\r\n    get children(): Child[];\r\n}\r\n\r\nexport interface DataRequester {\r\n    getRequiredDataTypes(): EboPlayerDataType[];\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[];\r\n}\r\n\r\nexport abstract class NestedDataRequester<T extends NestedDataRequester<T>> implements Parent<T>, DataRequester {\r\n    private _children: T[] = [];\r\n\r\n    abstract getRequiredDataTypes(): EboPlayerDataType[];\r\n\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[] {\r\n        return [...this.getRequiredDataTypes(), ...this._children.map(child => child.getRequiredDataTypesRecursive()).flat()];\r\n    }\r\n\r\n    addChildren(...children: T[]) {\r\n        this._children.push(...children);\r\n    }\r\n\r\n    get children(): T[] {\r\n        return this._children;\r\n    }\r\n}","import {NestedDataRequester} from \"./dataRequester\";\r\n\r\nexport enum EboPlayerDataType {\r\n    Volume,\r\n    CurrentTrack,\r\n    PlayState,\r\n    StreamLines,\r\n    TrackList,\r\n}\r\n\r\nexport abstract class View extends NestedDataRequester<View> {\r\n    abstract bind(): void;\r\n    static getSubId(parentId: string, subId: string) {\r\n        return document.getElementById(`${parentId}.${subId}`);\r\n    }\r\n\r\n    bindRecursive() {\r\n        this.children.forEach(child => child.bindRecursive());\r\n        this.bind();\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {EboplayerEvents, MessageType} from \"../modelTypes\";\r\n\r\nexport class HeaderView extends View {\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.messageChanged, () => {\r\n            this.onMessageChanged();\r\n        });\r\n    }\r\n\r\n    private onMessageChanged() {\r\n        let msg = getState().getModel().getCurrentMessage();\r\n        let headerSpan = document.getElementById(\"contentHeadline\");\r\n        headerSpan.innerText = msg.message;\r\n        switch (msg.type) {\r\n            case MessageType.Error:\r\n                headerSpan.classList.add(\"warning\");\r\n                break;\r\n            default:\r\n                headerSpan.classList.remove(\"warning\", \"error\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [];\r\n    }\r\n}","// import * as controls from \"./controls\";\r\nimport getState from \"./playerState\";\r\nimport models from \"../js/mopidy\";\r\nimport TlTrack = models.TlTrack;\r\n\r\n// interface ArtistInfo {\r\n//     name: string;\r\n//     uri: string;\r\n// }\r\n//\r\n// interface AlbumInfo {\r\n//     name: string;\r\n//     uri: string;\r\n// }\r\n//\r\n// interface TrackInfo {\r\n//     name: string;\r\n//     artists: ArtistInfo[];\r\n//     length: number;\r\n//     uri: string;\r\n//     album: AlbumInfo;\r\n// }\r\n\r\ninterface StreamInfo {\r\n    tlid: number;\r\n    track: TlTrack;\r\n    stream: string;\r\n}\r\n\r\n\r\n// constants\r\nexport const STREAMS_PLAYLIST_NAME = '[Radio Streams]';\r\nexport const STREAMS_PLAYLIST_SCHEME = 'm3u';\r\nexport const HOSTNAME = document.body.dataset.hostname;\r\nexport const ARTIST_TABLE = '#artiststable';\r\nexport const ALBUM_TABLE = '#albumstable';\r\nexport const BROWSE_TABLE = '#browsetable';\r\nexport const PLAYLIST_TABLE = '#playlisttracks';\r\nexport const CURRENT_PLAYLIST_TABLE = '#currenttable';\r\nexport const SEARCH_ALL_TABLE = '#allresulttable';\r\nexport const SEARCH_ALBUM_TABLE = '#albumresulttable';\r\nexport const SEARCH_ARTIST_TABLE = '#artistresulttable';\r\nexport const SEARCH_TRACK_TABLE = '#trackresulttable';\r\n\r\nconst URI_SCHEME = 'mbw';\r\n\r\nexport enum TRACK_ACTIONS {\r\n    UNDEFINED = -1,\r\n    PLAY_NOW = 0,\r\n    PLAY_NEXT = 1,\r\n    ADD_THIS_BOTTOM = 2,\r\n    ADD_ALL_BOTTOM = 3,\r\n    PLAY_ALL = 4,\r\n    DYNAMIC = 5,\r\n    INSERT_AT_INDEX = 6,\r\n}\r\n\r\n// the first part of Mopidy extensions which serve radio streams\r\nlet radioExtensionsList = ['somafm', 'tunein', 'dirble', 'audioaddict']\r\n\r\nlet uriClassList = [\r\n    ['spotify', 'fa-spotify'],\r\n    ['spotifytunigo', 'fa-spotify'],\r\n    ['spotifyweb', 'fa-spotify'],\r\n    ['local', 'fa-file-sound-o'],\r\n    ['file', 'fa-file-sound-o'],\r\n    ['m3u', 'fa-file-sound-o'],\r\n    ['podcast', 'fa-rss-square'],\r\n    ['podcast+file', 'fa-rss-square'],\r\n    ['podcast+itunes', 'fa-apple'],\r\n    ['dirble', 'fa-microphone'],\r\n    ['tunein', 'fa-headphones'],\r\n    ['soundcloud', 'fa-soundcloud'],\r\n    ['sc', 'fa-soundcloud'],\r\n    ['gmusic', 'fa-google'],\r\n    ['internetarchive', 'fa-university'],\r\n    ['somafm', 'fa-flask'],\r\n    ['youtube', 'fa-youtube'],\r\n    ['yt', 'fa-youtube'],\r\n    ['audioaddict', 'fa-bullhorn'],\r\n    ['subsonic', 'fa-folder-open']\r\n]\r\n\r\n// TODO: It should be possible to retrieve a user-friendly name for a given Mopidy scheme dynamically by\r\n//       calling mopidy.library.browse() on the root dir:\r\n//       1. each backend contained in the result will have a 'name' attribute that can be shown as-is in the UI.\r\n//       2. the URI prefix of the backend result should === mopidy.getUriSchemes(), which can be used for the mapping.\r\n//       3. only backends that cannot be 'browsed' (e.g. youtube) should have a static mapping defined here.\r\nlet uriHumanList = [\r\n    ['spotify', 'Spotify'],\r\n    ['spotifytunigo', 'Spotify browse'],\r\n    ['spotifyweb', 'Spotify browse'],\r\n    ['local', 'Local media'],\r\n    ['m3u', 'Local playlists'],\r\n    ['podcast', 'Podcasts'],\r\n    ['podcast+itunes', 'iTunes Store: Podcasts'],\r\n    ['dirble', 'Dirble'],\r\n    ['tunein', 'TuneIn'],\r\n    ['soundcloud', 'SoundCloud'],\r\n    ['gmusic', 'Google Music'],\r\n    ['internetarchive', 'Internet Archive'],\r\n    ['somafm', 'Soma FM'],\r\n    ['youtube', 'YouTube'],\r\n    ['audioaddict', 'AudioAddict'],\r\n    ['subsonic', 'Subsonic']\r\n]\r\n\r\n// List of Mopidy URI schemes that should not be searched directly.\r\n// Also blacklists 'yt' in favour of using the other 'youtube' supported scheme.\r\nexport const searchBlacklist = [\r\n    'file',\r\n    'http',\r\n    'https',\r\n    'mms',\r\n    'rtmp',\r\n    'rtmps',\r\n    'rtsp',\r\n    'yt'\r\n]\r\n\r\n// List of known audio file extensions\r\n// TODO: consider querying GStreamer for supported audio formats - see:https://discuss.mopidy.com/t/supported-codecs-file-formats/473\r\nconst VALID_AUDIO_EXT = [\r\n    'aa', 'aax',  // Audible.com\r\n    'aac',  // Advanced Audio Coding format\r\n    'aiff',  // Apple\r\n    'au',  // Sun Microsystems\r\n    'flac',  // Free Lossless Audio Codec\r\n    'gsm',\r\n    'iklax',\r\n    'ivs',\r\n    'm4a',\r\n    'm4b',\r\n    'm4p',\r\n    'mp3',\r\n    'mpc',  // Musepack\r\n    'ogg', 'oga', 'mogg',  // Ogg-Vorbis\r\n    'opus',  // Internet Engineering Task Force (IETF)\r\n    'ra', 'rm',  // RealAudio\r\n    'raw',\r\n    'tta',  // True Audio\r\n    'vox',\r\n    'wav',\r\n    'wma',  // Microsoft\r\n    'wv',\r\n    'webm'  // HTML5 video\r\n]\r\n\r\nfunction scrollToTop () {\r\n    //todo\r\n    // $('body,html').animate({\r\n    //     scrollTop: 0\r\n    // }, 250)\r\n}\r\n\r\nexport function scrollToTracklist () {\r\n    //todo\r\n    // let divtop = $('#playlisttracksdiv').offset().top - 120\r\n    // $('body,html').animate({\r\n    //     scrollTop: divtop\r\n    // }, 250)\r\n}\r\n\r\n// A hack to find the name of the first artist of a playlist. this is not yet returned by mopidy\r\n// does not work wel with multiple artists of course\r\nexport function getArtist (pl) {\r\n    for (let i = 0; i < pl.length; i++) {\r\n        for (let j = 0; j < pl[i].artists.length; j++) {\r\n            if (pl[i].artists[j].name !== '') {\r\n                return pl[i].artists[j].name\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// A hack to find the first album of a playlist. this is not yet returned by mopidy\r\nexport function getAlbum (pl) {\r\n    for (let i = 0; i < pl.length; i++) {\r\n        if (pl[i].album.name !== '') {\r\n            return pl[i].album.name\r\n        }\r\n    }\r\n}\r\n\r\nexport function artistsToString (artists, max = 3) {\r\n    let result = '';\r\n    if (artists && artists.length > 0) {\r\n        for (let i = 0; i < artists.length && i < max; i++) {\r\n            if (artists[i].name) {\r\n                if (i > 0) {\r\n                    result += ', ';\r\n                }\r\n                result += artists[i].name;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/** ******************************************************\r\n * break up results and put them in album tables\r\n *********************************************************/\r\nexport function albumTracksToTable (pl, target, uri) {\r\n    let track, previousTrack, nextTrack;\r\n    let html = '';\r\n    document.querySelector(target).innerHTML = \"\";\r\n    document.querySelector(target).attr('data', uri);\r\n    for (let i = 0; i < pl.length; i++) {\r\n        previousTrack = track || undefined;\r\n        nextTrack = i < pl.length - 1 ? pl[i + 1] : undefined;\r\n        track = pl[i];\r\n        getState().popupData[track.uri] = track;\r\n        html += renderSongLi(previousTrack, track, nextTrack, uri, '', target, i, pl.length);\r\n    }\r\n    document.querySelector(target).append(html);\r\n    // updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction());\r\n}\r\n\r\nexport function renderSongLi (previousTrack, track, nextTrack, uri, tlid, target, currentIndex, listLength) {\r\n    let tlidParameter = '';\r\n    let onClick = '';\r\n    let html = '';\r\n    track.name = validateTrackName(track, currentIndex);\r\n    // Streams\r\n    if (track.length === -1) {\r\n        html += '<li class=\"albumli\"><a href=\"#\"><h1><i class=\"' + getMediaClass(track) + '\"></i> ' + track.name + ' [Stream]</h1></a></li>';\r\n        return html;\r\n    }\r\n\r\n    if (target === CURRENT_PLAYLIST_TABLE && typeof tlid === 'number' && tlid >= 0) {  // Current queue: Show popup menu icon. onClick plays track.\r\n        tlidParameter = '\\',\\'' + tlid;\r\n        onClick = 'return controls.playQueueTrack(' + tlid + ');';\r\n    } else {  // All other tracklist: Show default action icon. onClick performs default action\r\n        onClick = 'return controls.playTracks(\\'\\', mopidy, \\'' + track.uri + '\\', \\'' + uri + '\\');';\r\n    }\r\n\r\n    html += '<li class=\"song albumli\" id=\"' + getUniqueId(target, track.uri) + '\" tlid=\"' + tlid + '\">';\r\n    if (isPlayable(track)) {\r\n        // Show popup icon for audio files or 'tracks' of other scheme types\r\n        html += '<a href=\"#\" class=\"moreBtn\" onclick=\"return popupTracks(event, \\'' + uri + '\\',\\'' + track.uri + tlidParameter + '\\');\">' +\r\n        '<i class=\"fa fa-play-circle-o\"></i></a>';\r\n    }\r\n    html += '<a href=\"#\" onclick=\"' + onClick + '\"><h1><i class=\"' + getMediaClass(track) + '\"></i> ' + track.name + '</h1>';\r\n\r\n    if (listLength === 1 || (!hasSameAlbum(previousTrack, track) && !hasSameAlbum(track, nextTrack))) {\r\n        html += renderSongLiAlbumInfo(track);\r\n    }\r\n    html += '</a></li>';\r\n    return html;\r\n}\r\n\r\n/* Tracklist renderer for track artist and album name. */\r\nexport function renderSongLiAlbumInfo (track, target: string = undefined) {\r\n    let html = renderSongLiTrackArtists(track);\r\n    if (track.album && track.album.name) {\r\n        html += ' - <em>' + track.album.name + '</em></p>';\r\n    }\r\n    if (typeof target !== 'undefined' && target.length > 0) {\r\n        target = getUniqueId(target, track.uri, true);\r\n        document.querySelector(target).querySelectorAll('a')[1].append(html);\r\n    }\r\n    return html;\r\n}\r\n\r\n/* Tracklist renderer for track artist information. */\r\nfunction renderSongLiTrackArtists (track) {\r\n    let html = ''\r\n    if (track.artists) {\r\n        for (let i = 0; i < track.artists.length; i++) {\r\n            html += track.artists[i].name\r\n            html += (i === track.artists.length - 1) ? '' : ' / '\r\n            // Stop after 3\r\n            if (i > 2) {\r\n                html += '...'\r\n                break\r\n            }\r\n        }\r\n    }\r\n    return html\r\n}\r\n\r\n/* Tracklist renderer to insert dividers between albums. */\r\nexport function renderSongLiDivider (previousTrack, track, nextTrack, target) {\r\n    // let html = ''\r\n    // let imageID\r\n    // // Render differently if part of an album.\r\n    // if (!hasSameAlbum(previousTrack, track) && hasSameAlbum(track, nextTrack)) {\r\n    //     // Large divider with album cover.\r\n    //     let showAlbum = '';\r\n    //     if (typeof track.album.uri !== 'undefined') {\r\n    //         showAlbum = 'onclick=\"return library.showAlbum(\\'' + track.album.uri + '\\', mopidy);\"'\r\n    //     }\r\n    //     html +=\r\n    //         '<li class=\"albumdivider\"><a href=\"#\" ' + showAlbum + '>' +\r\n    //         '<img id=\"' + getUniqueId(target + '-cover', track.uri) + '\" class=\"artistcover\" width=\"30\" height=\"30\"/>' +\r\n    //         '<h1>' + track.album.name + '</h1><p>' +\r\n    //         renderSongLiTrackArtists(track) + '</p></a></li>'\r\n    //     // The element ID to populate with an album cover.\r\n    //     imageID = getUniqueId(target + '-cover', track.uri, true)\r\n    // } else if (previousTrack && !hasSameAlbum(previousTrack, track)) {\r\n    //     // Small divider\r\n    //     html += '<li class=\"smalldivider\"> &nbsp;</li>'\r\n    // }\r\n    // if (html.length > 0 && typeof target !== 'undefined' && target.length > 0) {\r\n    //     target = getUniqueId(target, track.uri, true)\r\n    //     document.querySelector(target).before(html);\r\n    // }\r\n    // return [html, imageID];\r\n}\r\n\r\nexport function renderSongLiBackButton (results, target, onClick, optional = undefined) {\r\n    if (onClick && onClick.length > 0) {\r\n        if (!results || results.length === 0) {\r\n            document.querySelector(target).innerHTML= \"\";\r\n            document.querySelector(target).append(\r\n                '<li class=\"song albumli\"><a href=\"#\" onclick=\"' + onClick + '\"><h1><i></i>No tracks found...</h1></a></li>'\r\n            );\r\n        }\r\n        let opt = '';\r\n        if (optional) {\r\n            opt = ' backnav-optional';\r\n        }\r\n        document.querySelector(target).prepend(\r\n            '<li class=\"backnav' + opt + '\"><a href=\"#\" onclick=\"' + onClick + '\"><h1><i class=\"fa fa-arrow-circle-left\"></i> Back</h1></a></li>'\r\n        );\r\n    }\r\n}\r\n\r\nexport function hasSameAlbum (track1, track2) {\r\n    // 'true' if album for each track exists and has the same name\r\n    let name1 = track1 ? (track1.album ? track1.album.name : undefined) : undefined\r\n    let name2 = track2 ? (track2.album ? track2.album.name : undefined) : undefined\r\n    return name1 && name2 && (name1 === name2)\r\n}\r\n\r\nfunction validateTrackName (track, trackNumber) {\r\n    // Create name if there is none\r\n    let name = ''\r\n    if (!track.name || track.name === '') {\r\n        name = track.uri.split('/')\r\n        name = decodeURI(name[name.length - 1]) || 'Track ' + String(trackNumber)\r\n    } else {\r\n        name = track.name\r\n    }\r\n    return name\r\n}\r\n\r\nexport function resultsToTables (results, target: string, uri: string = undefined, onClickBack = undefined, backIsOptional = undefined) {\r\n    // document.querySelector(target).innerHTML = \"\";\r\n    // renderSongLiBackButton(results, target, onClickBack, backIsOptional)\r\n    // if (!results || results.length === 0) {\r\n    //     return;\r\n    // }\r\n    // document.querySelector(target).setAttribute('data', uri);\r\n    //\r\n    // let track, previousTrack, nextTrack, tlid;\r\n    // let html = '';\r\n    // let requiredImages = {};\r\n    //\r\n    // // Break into albums and put in tables\r\n    // for (let i = 0; i < results.length; i++) {\r\n    //     previousTrack = track || undefined;\r\n    //     nextTrack = i < results.length - 1 ? results[i + 1] : undefined;\r\n    //     track = results[i];\r\n    //     if (track) {\r\n    //         if ('tlid' in track) {\r\n    //             // Get track information from TlTrack instance\r\n    //             tlid = track.tlid;\r\n    //             track = track.track;\r\n    //             nextTrack = nextTrack ? nextTrack.track : undefined;\r\n    //         }\r\n    //         getState().popupData[track.uri] = track;\r\n    //         let divider = renderSongLiDivider(previousTrack, track, nextTrack, target);\r\n    //         html += divider[0] + renderSongLi(previousTrack, track, nextTrack, uri, tlid, target, i, results.length);\r\n    //         requiredImages[track.uri] = divider[1];\r\n    //     }\r\n    // }\r\n    // document.querySelector(target).append(html);\r\n    // updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction())\r\n    // images.setImages(requiredImages, getState().mopidy, 'small');\r\n}\r\n\r\nfunction getUris (tracks) {\r\n    let results = []\r\n    for (let i = 0; i < tracks.length; i++) {\r\n        results.push(tracks[i].uri)\r\n    }\r\n    return results\r\n}\r\n\r\nexport function getTracksFromUri (uri, full_track_data) {\r\n    let returnTracksOrUris = function (tracks) {\r\n        return full_track_data ? tracks : getUris(tracks)\r\n    }\r\n    if (getState().customTracklists[uri]) {\r\n        return returnTracksOrUris(getState().customTracklists[uri])\r\n    } else if (getState().playlists[uri] && getState().playlists[uri].tracks) {\r\n        return returnTracksOrUris(getState().playlists[uri].tracks)\r\n    }\r\n    return []\r\n}\r\n\r\n// convert time to human readable format\r\nfunction timeFromSeconds (length) {\r\n    let d = Number(length);\r\n    let h = Math.floor(d / 3600);\r\n    let m = Math.floor(d % 3600 / 60);\r\n    let s = Math.floor(d % 3600 % 60);\r\n    return ((h > 0 ? h + ':' : '') + (m > 0 ? (h > 0 && m < 10 ? '0' : '') + m + ':' : '0:') + (s < 10 ? '0' : '') + s);\r\n}\r\n\r\n/** ***** Toast ***/\r\nfunction toast (message, delay, textOnly) {\r\n    //todo\r\n    // let textOnl = textOnly || false;\r\n    // message = message || 'Loading...'\r\n    // delay = delay || 1000\r\n    // $.mobile.loading('show', {\r\n    //     text: message,\r\n    //     textVisible: true,\r\n    //     theme: 'a',\r\n    //     textonly: textOnl\r\n    // })\r\n    // if (delay > 0) {\r\n    //     setTimeout(function () {\r\n    //         $.mobile.loading('hide')\r\n    //     }, delay)\r\n    // }\r\n}\r\n\r\n/** ****************\r\n * Modal dialogs  *\r\n ******************/\r\nexport function showLoading (on) {\r\n    //todo\r\n    // if (on) {\r\n    //     document.body.classList.add('cursor', 'progress');\r\n    //     $.mobile.loading('show', {\r\n    //         text: 'Loading data from ' + HOSTNAME + '. Please wait...',\r\n    //         textVisible: true,\r\n    //         theme: 'a'\r\n    //     })\r\n    // } else {\r\n    //     $('body').css('cursor', 'default')\r\n    //     $.mobile.loading('hide')\r\n    // }\r\n}\r\n\r\n// from http://dzone.com/snippets/validate-url-regexp\r\nexport function validUri (uri: string) {\r\n    let regexp = /^(http|https|mms|rtmp|rtmps|rtsp):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?/;\r\n    return regexp.test(uri);\r\n}\r\n\r\nfunction validServiceUri (str: string) {\r\n    return validUri(str) || isServiceUri(str);\r\n}\r\n\r\nexport function getScheme (uri: string) {\r\n    return uri.split(':')[0].toLowerCase();\r\n}\r\n\r\nfunction isPlayable (track) {\r\n    if (typeof track.type === 'undefined' || track.type === 'track') {\r\n        if (track.uri && getScheme(track.uri) === 'file') {\r\n            let ext = track.uri.split('.').pop().toLowerCase();\r\n            // Files must have the correct extension\r\n            return VALID_AUDIO_EXT.includes(ext);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function isStreamUri (uri) {\r\n    return validUri(uri) || radioExtensionsList.indexOf(getScheme(uri)) >= 0\r\n}\r\n\r\nexport function getMediaClass (track) {\r\n    let defaultIcon = 'fa-file-sound-o'\r\n    let type = track.type\r\n    if (typeof type === 'undefined' || type === 'track') {\r\n        if (!isPlayable(track)) {\r\n            return 'fa fa-file-o'  // Unplayable file\r\n        } else if (isStreamUri(track.uri)) {\r\n            return 'fa fa-rss'  // Stream\r\n        }\r\n    } else if (type === 'directory') {\r\n        return 'fa fa-folder-o'\r\n    } else if (type === 'album') {\r\n        // return 'fa fa-bullseye'  // Album\r\n        defaultIcon = 'fa-folder-o'\r\n    } else if (type === 'artist') {\r\n        // return 'fa fa-user-circle-o'  // Artist\r\n        defaultIcon = 'fa-folder-o'\r\n    } else if (type === 'playlist') {\r\n        // return 'fa fa-star'  // Playlist\r\n    }\r\n    if (track.uri) {\r\n        let scheme = getScheme(track.uri)\r\n        for (let i = 0; i < uriClassList.length; i++) {\r\n            if (scheme === uriClassList[i][0]) {\r\n                return 'fa ' + uriClassList[i][1]\r\n            }\r\n        }\r\n        return 'fa ' + defaultIcon\r\n    }\r\n    return ''\r\n}\r\n\r\nfunction getMediaHuman (uri) {\r\n    let scheme = getScheme(uri)\r\n    for (let i = 0; i < uriHumanList.length; i++) {\r\n        if (scheme.toLowerCase() === uriHumanList[i][0].toLowerCase()) {\r\n            return uriHumanList[i][1]\r\n        }\r\n    }\r\n    return ''\r\n}\r\n\r\nfunction isServiceUri (uri) {\r\n    let scheme = getScheme(uri)\r\n    let i = 0\r\n    for (i = 0; i < uriClassList.length; i++) {\r\n        if (scheme === uriClassList[i][0]) {\r\n            return true\r\n        }\r\n    }\r\n    for (i = 0; i < radioExtensionsList.length; i++) {\r\n        if (scheme === radioExtensionsList[i]) {\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function isFavouritesPlaylist (playlist) {\r\n    return (playlist.name === STREAMS_PLAYLIST_NAME &&\r\n            getScheme(playlist.uri) === STREAMS_PLAYLIST_SCHEME)\r\n}\r\n\r\n// Returns a string where {x} in template is replaced by tokens[x].\r\nfunction stringFromTemplate (template, tokens) {\r\n    return template.replace(/{[^}]+}/g, function (match) {\r\n        return tokens[match.slice(1, -1)]\r\n    })\r\n}\r\n\r\n/**\r\n * Converts a URI to a jQuery-safe identifier. jQuery identifiers need to be\r\n * unique per page and cannot contain special characters.\r\n *\r\n * @param {string} identifier - Identifier string to prefix to the URI. Can\r\n * be used to ensure that the generated ID will be unique for the page that\r\n * it will be included on. Also accepts jQuery identifiers starting with '#'.\r\n *\r\n * @param {string} uri - URI to encode, usually the URI of a Mopidy track.\r\n *\r\n * @param {boolean} includePrefix - Will prefix the generated identifier\r\n * with the '#' character if set to 'true', ready to be passed to $() or\r\n * jQuery().\r\n *\r\n * @return {string} - a string in the format '[#]identifier-encodedURI' that\r\n * is safe to use as a jQuery identifier.\r\n */\r\nexport function getUniqueId (identifier: string, uri: string, includePrefix: boolean = false) {\r\n    if (identifier.charAt(0) === '#' && !includePrefix) {\r\n        identifier = identifier.substring(1);\r\n    } else if (identifier.charAt(0) !== '#' && includePrefix) {\r\n        identifier = '#' + identifier\r\n    }\r\n    return identifier + '-' + fixedEncodeURIComponent(uri).replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '')  // eslint-disable-line no-useless-escape\r\n}\r\n\r\n// Strict URI encoding as per https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\r\nfunction fixedEncodeURIComponent (str) {\r\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\r\n        return '%' + c.charCodeAt(0).toString(16)\r\n    })\r\n}\r\n\r\nexport function updatePlayIcons(uri: string, tlid: number, popupMenuIcon) {\r\n    // Update styles of listviews\r\n    let listviews = [PLAYLIST_TABLE, SEARCH_TRACK_TABLE, ARTIST_TABLE, ALBUM_TABLE, BROWSE_TABLE];\r\n    let target = CURRENT_PLAYLIST_TABLE.substring(1);\r\n    if (uri && typeof tlid === 'number' && tlid >= 0) {\r\n        document.querySelector(CURRENT_PLAYLIST_TABLE).querySelectorAll('li.song.albumli').forEach((el) => {\r\n            let eachTlid = parseInt(el.getAttribute('tlid'));\r\n            if (this.id === getUniqueId(target, uri) && eachTlid === tlid) {\r\n                if (!el.classList.contains('currenttrack')) {\r\n                    el.classList.add('currenttrack');\r\n                }\r\n            } else if (el.classList.contains('currenttrack')) {\r\n                el.classList.remove('currenttrack');\r\n            }\r\n        })\r\n    }\r\n\r\n    let popupElement;\r\n\r\n    for (let i = 0; i < listviews.length; i++) {\r\n        target = listviews[i].substring(1)\r\n        document.querySelector(listviews[i]).querySelectorAll('li.song.albumli').forEach((el) => {\r\n            if (uri) {\r\n                if (this.id === getUniqueId(target, uri)) {\r\n                    el.classList.add('currenttrack2');\r\n                } else {\r\n                    el.classList.remove('currenttrack2');\r\n                }\r\n            }\r\n            if (popupMenuIcon) {\r\n                popupElement = el.querySelector('a.moreBtn').querySelectorAll('i').item(0);\r\n                if (!popupElement.hasClass(popupMenuIcon)) {\r\n                    popupElement.removeClass()\r\n                    popupElement.addClass(popupMenuIcon)\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport function switchContent(divid: string, uri: string = undefined) {\r\n    let hash = divid;\r\n    if (uri) {\r\n        hash += '?' + uri\r\n    }\r\n    location.hash = '#' + hash\r\n}\r\n\r\nexport function jsonParse<T>(data: string, defaultValue: T): T {\r\n    try {\r\n        return JSON.parse(data);\r\n    } catch (e) {\r\n        console.error(e);\r\n        return defaultValue;\r\n    }\r\n}","import getState from \"./playerState\";\r\nimport {processCurrentPlaylist, processGetPlaylists} from \"./process_ws\";\r\n\r\nexport let library = {\r\n\r\n    /** *******************************\r\n     * Search\r\n     *********************************/\r\n    searchPressed: function (key) {\r\n        // var value = document.getElementById('searchinput').val();\r\n        // switchContent('search');\r\n        //\r\n        // if (key === 13) {\r\n        //     library.initSearch()\r\n        //     return false\r\n        // }\r\n        return true\r\n    },\r\n\r\n    // init search\r\n    initSearch: function () {\r\n        // let value = document.getElementById('searchinput').val();\r\n        // let searchService = document.getElementById(#selectSearchService').val();\r\n        // // $.cookie('searchScheme', searchService, {expires: 365})\r\n        //\r\n        // if ((value.length < 100) && (value.length > 0)) {\r\n        //     showLoading(true)\r\n        //     // hide ios/android keyboard\r\n        //     document.activeElement.blur()\r\n        //     $('input').blur()\r\n        //\r\n        //     delete customTracklists[URI_SCHEME + ':trackresultscache']\r\n        //     document.getElementById(#searchartists').hide()\r\n        //     document.getElementById(#searchalbums').hide()\r\n        //     document.getElementById(#searchtracks').hide()\r\n        //\r\n        //     if (searchService !== 'all') {\r\n        //         mopidy.library.search({'query': {any: [value]}, 'uris': [searchService + ':']}).then(library.processSearchResults, console.error)\r\n        //     } else {\r\n        //         mopidy.getUriSchemes().then(function (schemes) {\r\n        //             var query = {}\r\n        //             var uris = []\r\n        //\r\n        //             var regexp = $.map(schemes, function (scheme) {\r\n        //                 return '^' + scheme + ':'\r\n        //             }).join('|')\r\n        //\r\n        //             var match = value.match(regexp)\r\n        //             if (match) {\r\n        //                 var scheme = match[0]\r\n        //                 query = {uri: [value]}\r\n        //                 uris = [scheme]\r\n        //             } else {\r\n        //                 query = {any: [value]}\r\n        //             }\r\n        //             mopidy.library.search({'query': query, 'uris': uris}).then(library.processSearchResults, console.error)\r\n        //         })\r\n        //     }\r\n        // }\r\n    },\r\n\r\n    /** ******************************************************\r\n     * process results of a search\r\n     *********************************************************/\r\n    processSearchResults: function (resultArr) {\r\n        // $(SEARCH_TRACK_TABLE).empty()\r\n        // $(SEARCH_ARTIST_TABLE).empty()\r\n        // $(SEARCH_ALBUM_TABLE).empty()\r\n        //\r\n        // // Merge results from different backends.\r\n        // // TODO  should of coures have multiple tables\r\n        // var results = {'tracks': [], 'artists': [], 'albums': []}\r\n        // var i, j\r\n        // var emptyResult = true\r\n        //\r\n        // for (i = 0; i < resultArr.length; i++) {\r\n        //     if (resultArr[i].tracks) {\r\n        //         for (j = 0; j < resultArr[i].tracks.length; j++) {\r\n        //             results.tracks.push(resultArr[i].tracks[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        //     if (resultArr[i].artists) {\r\n        //         for (j = 0; j < resultArr[i].artists.length; j++) {\r\n        //             results.artists.push(resultArr[i].artists[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        //     if (resultArr[i].albums) {\r\n        //         for (j = 0; j < resultArr[i].albums.length; j++) {\r\n        //             results.albums.push(resultArr[i].albums[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        // }\r\n        //\r\n        // customTracklists[URI_SCHEME + ':trackresultscache'] = results.tracks\r\n        //\r\n        // if (emptyResult) {\r\n        //     document.getElementById(#searchtracks').show()\r\n        //     $(SEARCH_TRACK_TABLE).append(\r\n        //         '<li class=\"song albumli\"><a href=\"#\"><h1><i></i>No tracks found...</h1></a></li>'\r\n        //     )\r\n        //     toast('No results')\r\n        //     showLoading(false)\r\n        //     return false\r\n        // }\r\n        //\r\n        // if (results.artists.length > 0) {\r\n        //     document.getElementById(#searchartists').show()\r\n        // }\r\n        //\r\n        // if (results.albums.length > 0) {\r\n        //     document.getElementById(#searchalbums').show()\r\n        // }\r\n        //\r\n        // if (results.tracks.length > 0) {\r\n        //     document.getElementById(#searchtracks').show()\r\n        // }\r\n        //\r\n        // // 'Show more' template\r\n        // var showMoreTemplate = '<li onclick=\"$(this).hide().siblings().show(); return false;\"><a>Show {count} more</a></li>'\r\n        //\r\n        // // Artist results\r\n        // var child = ''\r\n        // var template = '<li><a href=\"#\" onclick=\"return library.showArtist(this.id, mopidy)\" id={id}><i class=\"{class}\"></i> <strong>{name}</strong></a></li>'\r\n        // var tokens\r\n        //\r\n        // for (i = 0; i < results.artists.length; i++) {\r\n        //     tokens = {\r\n        //         'id': results.artists[i].uri,\r\n        //         'name': results.artists[i].name,\r\n        //         'class': getMediaClass(results.artists[i])\r\n        //     }\r\n        //\r\n        //     // Add 'Show all' item after a certain number of hits.\r\n        //     if (i === 4 && results.artists.length > 5) {\r\n        //         child += stringFromTemplate(showMoreTemplate, {'count': results.artists.length - i})\r\n        //         template = template.replace('<li>', '<li class=\"overflow\">')\r\n        //     }\r\n        //\r\n        //     child += stringFromTemplate(template, tokens)\r\n        // }\r\n        //\r\n        // // Inject list items, refresh listview and hide superfluous items.\r\n        // $(SEARCH_ARTIST_TABLE).html(child).listview('refresh').find('.overflow').hide()\r\n        //\r\n        // // Album results\r\n        // child = ''\r\n        // template = '<li><a href=\"#\" onclick=\"return library.showAlbum(this.id, mopidy)\" id=\"{albumId}\">'\r\n        // template += '<h5 data-role=\"heading\"><i class=\"{class}\"></i> {albumName}</h5>'\r\n        // template += '<p data-role=\"desc\">{artistName}</p>'\r\n        // template += '</a></li>'\r\n        //\r\n        // for (i = 0; i < results.albums.length; i++) {\r\n        //     tokens = {\r\n        //         'albumId': results.albums[i].uri,\r\n        //         'albumName': results.albums[i].name,\r\n        //         'artistName': '',\r\n        //         'albumYear': results.albums[i].date,\r\n        //         'class': getMediaClass(results.albums[i])\r\n        //     }\r\n        //     if (results.albums[i].artists) {\r\n        //         for (j = 0; j < results.albums[i].artists.length; j++) {\r\n        //             if (results.albums[i].artists[j].name) {\r\n        //                 tokens.artistName += results.albums[i].artists[j].name + ' '\r\n        //             }\r\n        //         }\r\n        //     }\r\n        //     if (tokens.albumYear) {\r\n        //         tokens.artistName += '(' + tokens.albumYear + ')'\r\n        //     }\r\n        //     // Add 'Show all' item after a certain number of hits.\r\n        //     if (i === 4 && results.albums.length > 5) {\r\n        //         child += stringFromTemplate(showMoreTemplate, {'count': results.albums.length - i})\r\n        //         template = template.replace('<li>', '<li class=\"overflow\">')\r\n        //     }\r\n        //\r\n        //     child += stringFromTemplate(template, tokens)\r\n        // }\r\n        // // Inject list items, refresh listview and hide superfluous items.\r\n        // $(SEARCH_ALBUM_TABLE).html(child).listview('refresh').find('.overflow').hide()\r\n        //\r\n        // // Track results\r\n        // resultsToTables(results.tracks, SEARCH_TRACK_TABLE, URI_SCHEME + ':trackresultscache')\r\n        //\r\n        // showLoading(false)\r\n    },\r\n\r\n    /** *******************************\r\n     * Playlists & Browse\r\n     *********************************/\r\n    getPlaylists: function () {\r\n        //  get playlists without tracks\r\n        // getState().commands.core.playlists.asList().then(processGetPlaylists, console.error)\r\n    },\r\n\r\n    getBrowseDir: function (rootdir: string | undefined) {\r\n        // //  get directory to browse\r\n        // showLoading(true)\r\n        // if (!rootdir) {\r\n        //     browseStack.pop()\r\n        //     if (browseStack.length > 0) {\r\n        //         rootdir = browseStack[browseStack.length - 1].uri  // Navigated one level up\r\n        //     } else {\r\n        //         rootdir = null  // Navigated to top of library\r\n        //     }\r\n        // } else if (browseStack.length === 0 || rootdir !== browseStack[browseStack.length - 1].uri) {\r\n        //     browseStack.push({'uri': rootdir, 'scrollPos': 0})  // Navigated one level down\r\n        // }\r\n        // mopidy.library.browse({'uri': rootdir}).then(function (resultArr) {\r\n        //     processBrowseDir(resultArr)\r\n        //     if (rootdir === null) {\r\n        //         $('.refreshLibraryBtnDiv').hide()  // Mopidy does not support refreshing list of backends.\r\n        //     } else {\r\n        //         $('.refreshLibraryBtnDiv').show()\r\n        //         document.getElementById(#refreshLibraryBtn').data('url', rootdir)\r\n        //         document.getElementById(#refreshLibraryBtn').off('click')\r\n        //         document.getElementById(#refreshLibraryBtn').one('click', controls.refreshLibrary)\r\n        //     }\r\n        // }, console.error)\r\n    },\r\n\r\n    /** ******************************************************\r\n     * Show tracks of playlist\r\n     ********************************************************/\r\n    togglePlaylists: function () {\r\n        // if (window.innerWidth <= 960) {\r\n        //     document.getElementById('playlisttracksdiv').toggle();\r\n        //     // Hide other div\r\n        //     (document.getElementById('playlisttracksdiv').is(':visible')) ? document.getElementById('playlistslistdiv').hide() : document.getElementById('playlistslistdiv').show()\r\n        // } else {\r\n        //     document.getElementById('playlisttracksdiv').show()\r\n        //     document.getElementById('playlistslistdiv').show()\r\n        // }\r\n        return true\r\n    },\r\n\r\n    /** **********\r\n     * Lookups\r\n     ************/\r\n    showTracklist: function (uri) {\r\n        // showLoading(true)\r\n        // $(PLAYLIST_TABLE).empty()\r\n        // library.togglePlaylists()\r\n        // var tracks = getPlaylistTracks(uri).then(function (tracks) {\r\n        //     resultsToTables(tracks, PLAYLIST_TABLE, uri, 'return library.togglePlaylists();', true)\r\n        //     showLoading(false)\r\n        // })\r\n        // updatePlayIcons(uri, '', controls.getIconForAction())\r\n        // document.getElementById('playlistslist li a').each(function () {\r\n        //     $(this).removeClass('playlistactive')\r\n        //     if (this.id === uri) {\r\n        //         $(this).addClass('playlistactive')\r\n        //     }\r\n        // })\r\n        return false\r\n    },\r\n\r\n    showArtist: function (nwuri, mopidy) {\r\n        // document.getElementById('popupQueue').popup('close')\r\n        // document.getElementById('popupTracks').popup('close')\r\n        // document.getElementById('controlsmodal').popup('close')\r\n        // $(ARTIST_TABLE).empty()\r\n        //\r\n        // if (!nwuri.length || nwuri === 'undefined') {\r\n        //     return false\r\n        // }\r\n        //\r\n        // // TODO cache\r\n        //\r\n        // document.getElementById('h_artistname').html('')\r\n        // showLoading(true)\r\n        // mopidy.library.lookup({'uris': [nwuri]}).then(function (resultDict) {\r\n        //     var resultArr = resultDict[nwuri]\r\n        //     resultArr.uri = nwuri\r\n        //     processArtistResults(resultArr)\r\n        // }, console.error)\r\n        // switchContent('artists', nwuri)\r\n        // scrollToTop()\r\n        return false\r\n    },\r\n\r\n    showAlbum: function (uri, mopidy) {\r\n        // document.getElementById('popupQueue').popup('close')\r\n        // document.getElementById('popupTracks').popup('close')\r\n        // document.getElementById('controlsmodal').popup('close')\r\n        // $(ALBUM_TABLE).empty()\r\n        //\r\n        // if (!uri.length || uri === 'undefined') {\r\n        //     return false\r\n        // }\r\n        //\r\n        // // fill from cache\r\n        // var pl = getTracksFromUri(uri, true)\r\n        // if (pl.length > 0) {\r\n        //     albumTracksToTable(pl, ALBUM_TABLE, uri)\r\n        //     var albumname = getAlbum(pl)\r\n        //     var artistname = getArtist(pl)\r\n        //     document.getElementById('h_albumname').html(albumname)\r\n        //     document.getElementById('h_albumartist').html(artistname)\r\n        //     document.getElementById('coverpopupalbumname').html(albumname)\r\n        //     document.getElementById('coverpopupartist').html(artistname)\r\n        //     showLoading(false)\r\n        //     mopidy.library.lookup({'uris': [uri]}).then(function (resultDict) {\r\n        //         var resultArr = resultDict[uri]\r\n        //         resultArr.uri = uri\r\n        //         processAlbumResults(resultArr)\r\n        //     }, console.error)\r\n        // } else {\r\n        //     showLoading(true)\r\n        //     document.getElementById('h_albumname').html('')\r\n        //     document.getElementById('h_albumartist').html('')\r\n        //     mopidy.library.lookup({'uris': [uri]}).then(function (resultDict) {\r\n        //         var resultArr = resultDict[uri]\r\n        //         resultArr.uri = uri\r\n        //         processAlbumResults(resultArr)\r\n        //     }, console.error)\r\n        // }\r\n        // // show page\r\n        // switchContent('albums', uri)\r\n        // scrollToTop()\r\n        // return false\r\n    },\r\n\r\n    getSearchSchemes: function (searchBlacklist, mopidy) {\r\n        // var backendName\r\n        // var searchScheme = $.cookie('searchScheme')\r\n        // if (searchScheme) {\r\n        //     searchScheme = searchScheme.replace(/\"/g, '')\r\n        // } else {\r\n        //     searchScheme = 'all'\r\n        // }\r\n        // document.getElementById('selectSearchService').empty()\r\n        // document.getElementById('selectSearchService').append(new Option('All services', 'all'))\r\n        // mopidy.getUriSchemes().then(function (schemesArray) {\r\n        //     schemesArray = schemesArray.filter(function (el) {\r\n        //         return searchBlacklist.indexOf(el) < 0\r\n        //     })\r\n        //     for (var i = 0; i < schemesArray.length; i++) {\r\n        //         backendName = getMediaHuman(schemesArray[i])\r\n        //         if (!backendName) {\r\n        //             // No mapping defined, revert to just showing the scheme with first letter capitalized.\r\n        //             backendName = schemesArray[i].charAt(0).toUpperCase() + schemesArray[i].slice(1)\r\n        //         }\r\n        //         document.getElementById('selectSearchService').append(new Option(backendName, schemesArray[i]))\r\n        //     }\r\n        //     document.getElementById('selectSearchService').val(searchScheme)\r\n        //     document.getElementById('selectSearchService').selectmenu('refresh', true)\r\n        // }, console.error)\r\n    }\r\n};\r\n","import models from \"../js/mopidy\";\r\nimport {validUri} from \"./functionsvars\";\r\nimport getState from \"./playerState\";\r\nimport {FileTrackModel, LibraryItem, NoneTrackModel, StreamTrackModel, TrackModel, TrackType} from \"./modelTypes\";\r\n\r\nexport function quadratic100(x: number) {\r\n    return (x * x) / 100;\r\n}\r\n\r\nexport function inverseQuadratic100(y: number) {\r\n    return Math.floor(Math.sqrt(y * 100));\r\n}\r\n\r\n// noinspection JSUnusedLocalSymbols\r\nexport function cubic100(x: number) {\r\n    return (x * x * x) / 10000;\r\n}\r\n\r\nexport function numberedDictToArray<T>(dict: Object, converter?: (object: any) => T): T[] {\r\n    let length = dict[\"length\"];\r\n    let array: any[] = [];\r\n    for (let index = 0; index < length; index++) {\r\n        let line = dict[index.toString()];\r\n        array.push(line);\r\n    }\r\n    if (!converter)\r\n        return array;\r\n    return array.map(converter);\r\n}\r\n\r\nexport function getHostAndPort() {\r\n    let hostName = document.body.dataset.hostname;\r\n    if (!hostName.startsWith(\"{{\"))\r\n        return hostName;\r\n\r\n    hostName = localStorage.getItem(\"eboplayer.hostName\");\r\n    if (hostName)\r\n        return hostName;\r\n    return document.location.host;\r\n}\r\n\r\nexport function isStream(track: models.Track) {\r\n    return track?.track_no == undefined;\r\n}\r\n\r\nexport function transformTrackDataToModel(track: (models.Track | undefined)): TrackModel {\r\n    if (!track) {\r\n        // noinspection UnnecessaryLocalVariableJS\r\n        let model: NoneTrackModel = {\r\n            type: TrackType.None\r\n        };\r\n        return model;\r\n    }\r\n    if (isStream(track)) {\r\n        // noinspection UnnecessaryLocalVariableJS\r\n        let model: StreamTrackModel = {\r\n            type: TrackType.Stream,\r\n            track,\r\n            name: track.name,\r\n            infoLines: []\r\n        };\r\n        return model;\r\n    }\r\n    //for now, assume it's a file track\r\n    let model: FileTrackModel = {\r\n        type: TrackType.File,\r\n        composer: \"\",\r\n        track,\r\n        title: track.name,\r\n        performer: \"\",\r\n        songlenght: 0\r\n    };\r\n    if (!track.name || track.name === '') {\r\n        let parts = track.uri.split('/');\r\n        model.title = decodeURI(parts[parts.length - 1])\r\n    }\r\n\r\n    if (validUri(track.name)) {\r\n        for (let key in getState().streamUris) {\r\n            let rs = getState().streamUris[key]\r\n            if (rs && rs[1] === track.name) {\r\n                model.title = (rs[0] || rs[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!track.length || track.length === 0) {\r\n        model.songlenght = getState().songlength = Infinity;\r\n    } else {\r\n        model.songlenght = getState().songlength = track.length;\r\n    }\r\n\r\n    //todo: fetch the image, set it in the model and the model should send an event: eboplayer:imageLoaded with the id of the track\r\n    // images.fetchAlbumImage(track.uri, ['infocover', 'albumCoverImg'], getState().mopidy);\r\n\r\n    return model;\r\n}\r\n\r\nexport function transformLibraryItem(item: LibraryItem) {\r\n    if (item.length == 1)\r\n        return transformTrackDataToModel(item[0]);\r\n}\r\n\r\nexport function console_yellow(msg: string) {\r\n    console.log(`%c${msg}`, 'background-color: yellow');\r\n}","// import * as controls from \"./controls\";\r\nimport {ALBUM_TABLE, albumTracksToTable, ARTIST_TABLE, getAlbum, getArtist, getMediaClass, isFavouritesPlaylist, resultsToTables, scrollToTracklist, showLoading} from \"./functionsvars\";\r\nimport * as images from \"./images\";\r\nimport models from \"../js/mopidy\";\r\nimport getState from \"./playerState\";\r\nimport TlTrack = models.TlTrack;\r\nimport {transformTrackDataToModel} from \"./global\";\r\n\r\nimport {TrackModel} from \"./modelTypes\";\r\n\r\nexport function transformTlTrackDataToModel(tlTrack: (TlTrack | null)): TrackModel {\r\n    return transformTrackDataToModel(tlTrack?.track);\r\n}\r\n\r\nexport function processVolume (data: number | null) {\r\n    getState().getController().setVolume(data);\r\n}\r\n\r\nexport function processMute (data: boolean | null) {\r\n    // controls.setMute(data);\r\n}\r\n\r\nexport function processCurrentposition (data) {\r\n    // controls.setPosition(parseInt(data))\r\n}\r\n\r\nexport function processPlaystate (data) {\r\n    if (data === 'playing') {\r\n        // controls.setPlayState(true)\r\n    } else {\r\n        // controls.setPlayState(false)\r\n    }\r\n}\r\n\r\nfunction processBrowseDir (resultArr: string | any[]) {\r\n//     document.querySelector(BROWSE_TABLE).innerHTML = \"\";\r\n//     if (getState().browseStack.length > 0) {\r\n//         renderSongLiBackButton(resultArr, BROWSE_TABLE, 'return library.getBrowseDir();');\r\n//     }\r\n//     if (!resultArr || resultArr.length === 0) {\r\n//         showLoading(false);\r\n//         return;\r\n//     }\r\n//     let uris = [];\r\n//     let ref, previousRef, nextRef;\r\n//     let uri = resultArr[0].uri;\r\n//     let length = 0 || resultArr.length;\r\n//     getState().customTracklists[BROWSE_TABLE] = [];\r\n//     let html = '';\r\n//\r\n//     // Render list of tracks\r\n//     for (let i = 0, index = 0; i < resultArr.length; i++) {\r\n//         if (resultArr[i].type === 'track') {\r\n//             previousRef = ref || undefined;\r\n//             nextRef = i < resultArr.length - 1 ? resultArr[i + 1] : undefined;\r\n//             ref = resultArr[i];\r\n//             // TODO: consolidate usage of various arrays for caching URIs, Refs, and Tracks\r\n//             getState().popupData[ref.uri] = ref;\r\n//             getState().customTracklists[BROWSE_TABLE].push(ref);\r\n//             uris.push(ref.uri);\r\n//\r\n//             html += renderSongLi(previousRef, ref, nextRef, BROWSE_TABLE, '', BROWSE_TABLE, index, resultArr.length);\r\n//\r\n//             index++;\r\n//         } else {\r\n//             html += '<li><a href=\"#\" onclick=\"return library.getBrowseDir(this.id);\" id=\"' + resultArr[i].uri + '\">' +\r\n//                     '<h1><i class=\"' + getMediaClass(resultArr[i]) + '\"></i> ' + resultArr[i].name + '</h1></a></li>';\r\n//         }\r\n//     }\r\n//\r\n//     document.querySelector(BROWSE_TABLE).append(html);\r\n//     if (getState().browseStack.length > 0) {\r\n//         window.scrollTo(0, getState().browseStack[getState().browseStack.length - 1].scrollPos || 0)  // Restore scroll position\r\n//     }\r\n//\r\n//     updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction())\r\n//\r\n//     // Look up track details and add album headers\r\n// ;    if (uris.length > 0) {\r\n//         getState().commands.core.library.lookup(uris).then(function (resultDict) {\r\n//             // Break into albums and put in tables\r\n//             let requiredImages = {};\r\n//             let track, previousTrack, nextTrack, uri;\r\n//             for (let i = 0, index = 0; i < resultArr.length; i++) {\r\n//                 if (resultArr[i].type === 'track') {\r\n//                     previousTrack = track || undefined\r\n//                     if (i < resultArr.length - 1 && resultDict[resultArr[i + 1].uri]) {\r\n//                         nextTrack = resultDict[resultArr[i + 1].uri][0]\r\n//                     } else {\r\n//                         nextTrack = undefined\r\n//                     }\r\n//                     track = resultDict[resultArr[i].uri][0]\r\n//                         getState().popupData[track.uri] = track  // Need full track info in popups in order to display albums and artists.\r\n//                     if (uris.length === 1 || (previousTrack && !hasSameAlbum(previousTrack, track) && !hasSameAlbum(track, nextTrack))) {\r\n//                         renderSongLiAlbumInfo(track, BROWSE_TABLE)\r\n//                     }\r\n//                     requiredImages[track.uri] = renderSongLiDivider(previousTrack, track, nextTrack, BROWSE_TABLE)[1]\r\n//                 }\r\n//             }\r\n//             showLoading(false)\r\n//             images.setImages(requiredImages, getState().mopidy, 'small')\r\n//         }, console.error)\r\n//     } else {\r\n//         showLoading(false)\r\n//     }\r\n}\r\n\r\nexport function processGetPlaylists (resultArr) {\r\n    if ((!resultArr) || (resultArr === '')) {\r\n        document.getElementById('playlistslist').innerHTML = \"\";\r\n        return\r\n    }\r\n    let tmp = '';\r\n    let favourites = '';\r\n    let starred = '';\r\n\r\n    for (let i = 0; i < resultArr.length; i++) {\r\n        let li_html = '<li><a href=\"#\" onclick=\"return library.showTracklist(this.id);\" id=\"' + resultArr[i].uri + '\">'\r\n        if (isFavouritesPlaylist(resultArr[i])) {\r\n            favourites = li_html + '&hearts; Musicbox Favourites</a></li>';\r\n        } else {\r\n            tmp = tmp + li_html + '<i class=\"' + getMediaClass(resultArr[i]) + '\"></i> ' + resultArr[i].name + '</a></li>';\r\n        }\r\n    }\r\n    // Prepend the user's Spotify \"Starred\" playlist and favourites to the results. (like Spotify official client).\r\n    tmp = favourites + starred + tmp;\r\n    document.getElementById('playlistslist').innerHTML = tmp;\r\n    scrollToTracklist();\r\n    showLoading(false);\r\n}\r\n\r\n/** ******************************************************\r\n * process results of a returned list of playlist track refs\r\n *********************************************************/\r\nexport function processPlaylistItems (resultDict) {\r\n    // var playlist = resultDict.playlist\r\n    // if (!playlist || playlist === '') {\r\n    //     console.log('Playlist', resultDict.uri, 'is invalid')\r\n    //     showLoading(false)\r\n    //     return\r\n    // }\r\n    // let playlistUri = resultDict.uri;\r\n    // getState().playlists[playlistUri] = {'uri': playlistUri, 'tracks': []}\r\n    // if (playlistUri.startsWith('m3u')) {\r\n    //     console.log('Playlist', playlistUri, 'requires tracks lookup');\r\n    //     let trackUris = [];\r\n    //     for (let i = 0; i < playlist.tracks.length; i++) {\r\n    //         trackUris.push(playlist.tracks[i].uri)\r\n    //     }\r\n    //     return getState().commands.core.library.lookup(trackUris).then(function (tracks) {\r\n    //         for (let i = 0; i < trackUris.length; i++) {\r\n    //             let track = tracks[trackUris[i]][0] || playlist.tracks[i];  // Fall back to using track Ref if lookup failed.\r\n    //             getState().playlists[playlistUri].tracks.push(track);\r\n    //         }\r\n    //         showLoading(false);\r\n    //         return getState().playlists[playlistUri].tracks;\r\n    //     })\r\n    // } else {\r\n    //     for (let i = 0; i < playlist.tracks.length; i++) {\r\n    //         let track = playlist.tracks[i];\r\n    //         getState().playlists[playlistUri].tracks.push(track);\r\n    //     }\r\n    //     showLoading(false);\r\n    //     return getState().playlists[playlistUri].tracks;\r\n    // }\r\n}\r\n\r\n/** ******************************************************\r\n * process results of the queue, the current playlist\r\n *********************************************************/\r\nexport function processCurrentPlaylist (resultArr) {\r\n}\r\n\r\n/** ******************************************************\r\n * process results of an artist lookup\r\n *********************************************************/\r\nfunction processArtistResults (resultArr) {\r\n    if (!resultArr || (resultArr.length === 0)) {\r\n        document.getElementById('h_artistname').textContent = 'Artist not found...';\r\n        images.fetchAlbumImage('', ['artistviewimage', 'artistpopupimage'], getState().mopidy);\r\n        showLoading(false);\r\n        return;\r\n    }\r\n    getState().customTracklists[resultArr.uri] = resultArr\r\n\r\n    resultsToTables(resultArr, ARTIST_TABLE, resultArr.uri)\r\n    let artistname = getArtist(resultArr);\r\n    document.getElementById('h_artistname').innerHTML = artistname;\r\n    document.getElementById('artistpopupname').innerHTML = artistname;\r\n    images.setArtistImage(resultArr.uri, resultArr[0].uri, '#artistviewimage, #artistpopupimage', getState().mopidy);\r\n    showLoading(false)\r\n}\r\n\r\n/** ******************************************************\r\n * process results of an album lookup\r\n *********************************************************/\r\nfunction processAlbumResults (resultArr) {\r\n    if (!resultArr || (resultArr.length === 0)) {\r\n        document.getElementById('h_albumname').textContent = 'Album not found...';\r\n        images.fetchAlbumImage('', ['albumviewcover', 'coverpopupimage'], getState().mopidy);\r\n        showLoading(false)\r\n        return\r\n    }\r\n    getState().customTracklists[resultArr.uri] = resultArr;\r\n\r\n    albumTracksToTable(resultArr, ALBUM_TABLE, resultArr.uri);\r\n    let albumname = getAlbum(resultArr);\r\n    let artistname = getArtist(resultArr);\r\n    document.getElementById('h_albumname').innerHTML = albumname;\r\n    document.getElementById('h_albumartist').innerHTML = artistname;\r\n    document.getElementById('coverpopupalbumname').innerHTML = albumname;\r\n    document.getElementById('coverpopupartist').innerHTML = artistname;\r\n    images.fetchAlbumImage(resultArr[0].uri, ['albumviewcover', 'coverpopupimage'], getState().mopidy);\r\n    showLoading(false);\r\n}\r\n","//GENERATED by build_commands.ts (although probably customized, so do a diff when regenerating).\nimport models, {core, Mopidy} from \"../js/mopidy\";\nimport TlTrack = models.TlTrack;\nimport PlaybackState = core.PlaybackState;\nimport Playlist = models.Playlist;\n\nexport class Commands {\n    protected mopidy: Mopidy;\n    \n    constructor(mopidy: Mopidy) {\n        this.mopidy = mopidy;\n        this.core.commands = this;\n        this.core.history.commands = this;\n        this.core.library.commands = this;\n        this.core.mixer.commands = this;\n        this.core.playback.commands = this;\n        this.core.playlists.commands = this;\n        this.core.tracklist.commands = this;\n\n    }\n    \n    send(method: string, params: Object) {\n        if(params)\n            return this.mopidy.send({method, params});\n        else\n            return this.mopidy.send({method});\n    }\n    core = {\n        commands: undefined as Commands,\n\n            //Get list of URI schemes we can handle\n        getUriSchemes() {\n            return this.commands.send(\"core.get_uri_schemes\");\n        },\n            //Get version of the Mopidy core API\n        getVersion() {\n            return this.commands.send(\"core.get_version\");\n        },\n        history: {\n            commands: undefined as Commands,\n                //Get the track history.\n                //\n                //The timestamps are milliseconds since epoch.\n                //\n                //:returns: the track history\n                //:rtype: list of (timestamp, :class:`mopidy.models.Ref`) tuples\n            getHistory() {\n                return this.commands.send(\"core.history.get_history\");\n            },\n                //Get the number of tracks in the history.\n                //\n                //:returns: the history length\n                //:rtype: int\n            getLength() {\n                return this.commands.send(\"core.history.get_length\");\n            },\n        },\n        library: {\n            commands: undefined as Commands,\n                //Browse directories and tracks at the given ``uri``.\n                //\n                //``uri`` is a string which represents some directory belonging to a\n                //backend. To get the intial root directories for backends pass\n                //:class:`None` as the URI.\n                //\n                //Returns a list of :class:`mopidy.models.Ref` objects for the\n                //directories and tracks at the given ``uri``.\n                //\n                //The :class:`~mopidy.models.Ref` objects representing tracks keep the\n                //track's original URI. A matching pair of objects can look like this::\n                //\n                //    Track(uri='dummy:/foo.mp3', name='foo', artists=..., album=...)\n                //    Ref.track(uri='dummy:/foo.mp3', name='foo')\n                //\n                //The :class:`~mopidy.models.Ref` objects representing directories have\n                //backend specific URIs. These are opaque values, so no one but the\n                //backend that created them should try and derive any meaning from them.\n                //The only valid exception to this is checking the scheme, as it is used\n                //to route browse requests to the correct backend.\n                //\n                //For example, the dummy library's ``/bar`` directory could be returned\n                //like this::\n                //\n                //    Ref.directory(uri='dummy:directory:/bar', name='bar')\n                //\n                //:param string uri: URI to browse\n                //:rtype: list of :class:`mopidy.models.Ref`\n                //\n                //.. versionadded:: 0.18\n            browse(uri: string) {\n                return this.commands.send(\"core.library.browse\", {uri});\n            },\n                //List distinct values for a given field from the library.\n                //\n                //This has mainly been added to support the list commands the MPD\n                //protocol supports in a more sane fashion. Other frontends are not\n                //recommended to use this method.\n                //\n                //:param string field: Any one of ``uri``, ``track_name``, ``album``,\n                //    ``artist``, ``albumartist``, ``composer``, ``performer``,\n                //    ``track_no``, ``genre``, ``date``, ``comment``, ``disc_no``,\n                //    ``musicbrainz_albumid``, ``musicbrainz_artistid``, or\n                //    ``musicbrainz_trackid``.\n                //:param dict query: Query to use for limiting results, see\n                //    :meth:`search` for details about the query format.\n                //:rtype: set of values corresponding to the requested field type.\n                //\n                //.. versionadded:: 1.0\n            getDistinct(field: string, query: Object) {\n                return this.commands.send(\"core.library.get_distinct\", {field, query});\n            },\n                //Lookup the images for the given URIs\n                //\n                //Backends can use this to return image URIs for any URI they know about\n                //be it tracks, albums, playlists. The lookup result is a dictionary\n                //mapping the provided URIs to lists of images.\n                //\n                //Unknown URIs or URIs the corresponding backend couldn't find anything\n                //for will simply return an empty list for that URI.\n                //\n                //:param uris: list of URIs to find images for\n                //:type uris: list of string\n                //:rtype: {uri: tuple of :class:`mopidy.models.Image`}\n                //\n                //.. versionadded:: 1.0\n            getImages(uris: string[]) {\n                return this.commands.send(\"core.library.get_images\", {uris});\n            },\n                //Lookup the given URIs.\n                //\n                //If the URI expands to multiple tracks, the returned list will contain\n                //them all.\n                //\n                //:param uris: track URIs\n                //:type uris: list of string\n                //:rtype: {uri: list of :class:`mopidy.models.Track`}\n            lookup(uris: string[]) {\n                return this.commands.send(\"core.library.lookup\", {uris});\n            },\n                //Refresh library. Limit to URI and below if an URI is given.\n                //\n                //:param uri: directory or track URI\n                //:type uri: string\n            refresh(uri: string) {\n                return this.commands.send(\"core.library.refresh\", {uri});\n            },\n                //Search the library for tracks where ``field`` contains ``values``.\n                //\n                //``field`` can be one of ``uri``, ``track_name``, ``album``, ``artist``,\n                //``albumartist``, ``composer``, ``performer``, ``track_no``, ``genre``,\n                //``date``, ``comment``, ``disc_no``, ``musicbrainz_albumid``,\n                //``musicbrainz_artistid``, ``musicbrainz_trackid`` or ``any``.\n                //\n                //If ``uris`` is given, the search is limited to results from within the\n                //URI roots. For example passing ``uris=['file:']`` will limit the search\n                //to the local backend.\n                //\n                //Examples::\n                //\n                //    # Returns results matching 'a' in any backend\n                //    search({'any': ['a']})\n                //\n                //    # Returns results matching artist 'xyz' in any backend\n                //    search({'artist': ['xyz']})\n                //\n                //    # Returns results matching 'a' and 'b' and artist 'xyz' in any\n                //    # backend\n                //    search({'any': ['a', 'b'], 'artist': ['xyz']})\n                //\n                //    # Returns results matching 'a' if within the given URI roots\n                //    # \"file:///media/music\" and \"spotify:\"\n                //    search({'any': ['a']}, uris=['file:///media/music', 'spotify:'])\n                //\n                //    # Returns results matching artist 'xyz' and 'abc' in any backend\n                //    search({'artist': ['xyz', 'abc']})\n                //\n                //:param query: one or more queries to search for\n                //:type query: dict\n                //:param uris: zero or more URI roots to limit the search to\n                //:type uris: list of string or :class:`None`\n                //:param exact: if the search should use exact matching\n                //:type exact: :class:`bool`\n                //:rtype: list of :class:`mopidy.models.SearchResult`\n                //\n                //.. versionadded:: 1.0\n                //    The ``exact`` keyword argument.\n            search(query: Object, uris?: string[], exact: boolean = false) {\n                return this.commands.send(\"core.library.search\", {query, uris, exact});\n            },\n        },\n        mixer: {\n            commands: undefined as Commands,\n                //Get mute state.\n                //\n                //:class:`True` if muted, :class:`False` unmuted, :class:`None` if\n                //unknown.\n            getMute() {\n                return this.commands.send(\"core.mixer.get_mute\");\n            },\n                //Get the volume.\n                //\n                //Integer in range [0..100] or :class:`None` if unknown.\n                //\n                //The volume scale is linear.\n            getVolume() {\n                return this.commands.send(\"core.mixer.get_volume\");\n            },\n                //Set mute state.\n                //\n                //:class:`True` to mute, :class:`False` to unmute.\n                //\n                //Returns :class:`True` if call is successful, otherwise :class:`False`.\n            setMute(mute: boolean) {\n                return this.commands.send(\"core.mixer.set_mute\", {mute});\n            },\n                //Set the volume.\n                //\n                //The volume is defined as an integer in range [0..100].\n                //\n                //The volume scale is linear.\n                //\n                //Returns :class:`True` if call is successful, otherwise :class:`False`.\n            setVolume(volume: number) {\n                return this.commands.send(\"core.mixer.set_volume\", {volume});\n            },\n        },\n        playback: {\n            commands: undefined as Commands,\n                //Get the currently playing or selected track.\n                //\n                //Returns a :class:`mopidy.models.TlTrack` or :class:`None`.\n            getCurrentTlTrack() {\n                return this.commands.send(\"core.playback.get_current_tl_track\");\n            },\n                //Get the currently playing or selected TLID.\n                //\n                //Extracted from :meth:`get_current_tl_track` for convenience.\n                //\n                //Returns a :class:`int` or :class:`None`.\n                //\n                //.. versionadded:: 1.1\n            getCurrentTlid() {\n                return this.commands.send(\"core.playback.get_current_tlid\");\n            },\n                //Get the currently playing or selected track.\n                //\n                //Extracted from :meth:`get_current_tl_track` for convenience.\n                //\n                //Returns a :class:`mopidy.models.Track` or :class:`None`.\n            getCurrentTrack() {\n                return this.commands.send(\"core.playback.get_current_track\");\n            },\n                //Get The playback state.\n            getState() {\n                return this.commands.send(\"core.playback.get_state\");\n            },\n                //Get the current stream title or :class:`None`.\n            getStreamTitle() {\n                return this.commands.send(\"core.playback.get_stream_title\");\n            },\n                //Get time position in milliseconds.\n            getTimePosition() {\n                return this.commands.send(\"core.playback.get_time_position\");\n            },\n                //Change to the next track.\n                //\n                //The current playback state will be kept. If it was playing, playing\n                //will continue. If it was paused, it will still be paused, etc.\n            next() {\n                return this.commands.send(\"core.playback.next\");\n            },\n                //Pause playback.\n            pause() {\n                return this.commands.send(\"core.playback.pause\");\n            },\n                //Play the given track, or if the given tl_track and tlid is\n                //:class:`None`, play the currently active track.\n                //\n                //Note that the track **must** already be in the tracklist.\n                //\n                //.. deprecated:: 3.0\n                //    The ``tl_track`` argument. Use ``tlid`` instead.\n                //\n                //:param tl_track: track to play\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:param tlid: TLID of the track to play\n                //:type tlid: :class:`int` or :class:`None`\n            play(tl_track?: TlTrack, tlid?: number) {\n                return this.commands.send(\"core.playback.play\", {tl_track, tlid});\n            },\n                //Change to the previous track.\n                //\n                //The current playback state will be kept. If it was playing, playing\n                //will continue. If it was paused, it will still be paused, etc.\n            previous() {\n                return this.commands.send(\"core.playback.previous\");\n            },\n                //If paused, resume playing the current track.\n            resume() {\n                return this.commands.send(\"core.playback.resume\");\n            },\n                //Seeks to time position given in milliseconds.\n                //\n                //:param time_position: time position in milliseconds\n                //:type time_position: int\n                //:rtype: :class:`True` if successful, else :class:`False`\n            seek(time_position: number) {\n                return this.commands.send(\"core.playback.seek\", {time_position});\n            },\n                //Set the playback state.\n                //\n                //Must be :attr:`PLAYING`, :attr:`PAUSED`, or :attr:`STOPPED`.\n                //\n                //Possible states and transitions:\n                //\n                //.. digraph:: state_transitions\n                //\n                //    \"STOPPED\" -> \"PLAYING\" [ label=\"play\" ]\n                //    \"STOPPED\" -> \"PAUSED\" [ label=\"pause\" ]\n                //    \"PLAYING\" -> \"STOPPED\" [ label=\"stop\" ]\n                //    \"PLAYING\" -> \"PAUSED\" [ label=\"pause\" ]\n                //    \"PLAYING\" -> \"PLAYING\" [ label=\"play\" ]\n                //    \"PAUSED\" -> \"PLAYING\" [ label=\"resume\" ]\n                //    \"PAUSED\" -> \"STOPPED\" [ label=\"stop\" ]\n            setState(new_state: PlaybackState) {\n                return this.commands.send(\"core.playback.set_state\", {new_state});\n            },\n                //Stop playing.\n            stop() {\n                return this.commands.send(\"core.playback.stop\");\n            },\n        },\n        playlists: {\n            commands: undefined as Commands,\n                //Get a list of the currently available playlists.\n                //\n                //Returns a list of :class:`~mopidy.models.Ref` objects referring to the\n                //playlists. In other words, no information about the playlists' content\n                //is given.\n                //\n                //:rtype: list of :class:`mopidy.models.Ref`\n                //\n                //.. versionadded:: 1.0\n            asList() {\n                return this.commands.send(\"core.playlists.as_list\");\n            },\n                //Create a new playlist.\n                //\n                //If ``uri_scheme`` matches an URI scheme handled by a current backend,\n                //that backend is asked to create the playlist. If ``uri_scheme`` is\n                //:class:`None` or doesn't match a current backend, the first backend is\n                //asked to create the playlist.\n                //\n                //All new playlists must be created by calling this method, and **not**\n                //by creating new instances of :class:`mopidy.models.Playlist`.\n                //\n                //:param name: name of the new playlist\n                //:type name: string\n                //:param uri_scheme: use the backend matching the URI scheme\n                //:type uri_scheme: string\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            create(name: string, uri_scheme: string) {\n                return this.commands.send(\"core.playlists.create\", {name, uri_scheme});\n            },\n                //Delete playlist identified by the URI.\n                //\n                //If the URI doesn't match the URI schemes handled by the current\n                //backends, nothing happens.\n                //\n                //Returns :class:`True` if deleted, :class:`False` otherwise.\n                //\n                //:param uri: URI of the playlist to delete\n                //:type uri: string\n                //:rtype: :class:`bool`\n                //\n                //.. versionchanged:: 2.2\n                //    Return type defined.\n            delete(uri: string) {\n                return this.commands.send(\"core.playlists.delete\", {uri});\n            },\n                //Get the items in a playlist specified by ``uri``.\n                //\n                //Returns a list of :class:`~mopidy.models.Ref` objects referring to the\n                //playlist's items.\n                //\n                //If a playlist with the given ``uri`` doesn't exist, it returns\n                //:class:`None`.\n                //\n                //:rtype: list of :class:`mopidy.models.Ref`, or :class:`None`\n                //\n                //.. versionadded:: 1.0\n            getItems(uri: string) {\n                return this.commands.send(\"core.playlists.get_items\", {uri});\n            },\n                //Get the list of URI schemes that support playlists.\n                //\n                //:rtype: list of string\n                //\n                //.. versionadded:: 2.0\n            getUriSchemes() {\n                return this.commands.send(\"core.playlists.get_uri_schemes\");\n            },\n                //Lookup playlist with given URI in both the set of playlists and in any\n                //other playlist sources. Returns :class:`None` if not found.\n                //\n                //:param uri: playlist URI\n                //:type uri: string\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            lookup(uri: string) {\n                return this.commands.send(\"core.playlists.lookup\", {uri});\n            },\n                //Refresh the playlists in :attr:`playlists`.\n                //\n                //If ``uri_scheme`` is :class:`None`, all backends are asked to refresh.\n                //If ``uri_scheme`` is an URI scheme handled by a backend, only that\n                //backend is asked to refresh. If ``uri_scheme`` doesn't match any\n                //current backend, nothing happens.\n                //\n                //:param uri_scheme: limit to the backend matching the URI scheme\n                //:type uri_scheme: string\n            refresh(uri_scheme: string) {\n                return this.commands.send(\"core.playlists.refresh\", {uri_scheme});\n            },\n                //Save the playlist.\n                //\n                //For a playlist to be saveable, it must have the ``uri`` attribute set.\n                //You must not set the ``uri`` atribute yourself, but use playlist\n                //objects returned by :meth:`create` or retrieved from :attr:`playlists`,\n                //which will always give you saveable playlists.\n                //\n                //The method returns the saved playlist. The return playlist may differ\n                //from the saved playlist. E.g. if the playlist name was changed, the\n                //returned playlist may have a different URI. The caller of this method\n                //must throw away the playlist sent to this method, and use the\n                //returned playlist instead.\n                //\n                //If the playlist's URI isn't set or doesn't match the URI scheme of a\n                //current backend, nothing is done and :class:`None` is returned.\n                //\n                //:param playlist: the playlist\n                //:type playlist: :class:`mopidy.models.Playlist`\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            save(playlist: Playlist) {\n                return this.commands.send(\"core.playlists.save\", {playlist});\n            },\n        },\n        tracklist: {\n            commands: undefined as Commands,\n                //Add tracks to the tracklist.\n                //\n                //If ``uris`` is given instead of ``tracks``, the URIs are\n                //looked up in the library and the resulting tracks are added to the\n                //tracklist.\n                //\n                //If ``at_position`` is given, the tracks are inserted at the given\n                //position in the tracklist. If ``at_position`` is not given, the tracks\n                //are appended to the end of the tracklist.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param tracks: tracks to add\n                //:type tracks: list of :class:`mopidy.models.Track` or :class:`None`\n                //:param at_position: position in tracklist to add tracks\n                //:type at_position: int or :class:`None`\n                //:param uris: list of URIs for tracks to add\n                //:type uris: list of string or :class:`None`\n                //:rtype: list of :class:`mopidy.models.TlTrack`\n                //\n                //.. versionadded:: 1.0\n                //    The ``uris`` argument.\n                //\n                //.. deprecated:: 1.0\n                //    The ``tracks`` argument. Use ``uris``.\n            add(tracks?: undefined, at_position?: number, uris?: string[]) {\n                return this.commands.send(\"core.tracklist.add\", {tracks, at_position, uris});\n            },\n                //Clear the tracklist.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n            clear() {\n                return this.commands.send(\"core.tracklist.clear\");\n            },\n                //The track that will be played after the given track.\n                //\n                //Not necessarily the same track as :meth:`next_track`.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_eot_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            eotTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.eot_track\", {tl_track});\n            },\n                //Filter the tracklist by the given criteria.\n                //\n                //Each rule in the criteria consists of a model field and a list of\n                //values to compare it against. If the model field matches any of the\n                //values, it may be returned.\n                //\n                //Only tracks that match all the given criteria are returned.\n                //\n                //Examples::\n                //\n                //    # Returns tracks with TLIDs 1, 2, 3, or 4 (tracklist ID)\n                //    filter({'tlid': [1, 2, 3, 4]})\n                //\n                //    # Returns track with URIs 'xyz' or 'abc'\n                //    filter({'uri': ['xyz', 'abc']})\n                //\n                //    # Returns track with a matching TLIDs (1, 3 or 6) and a\n                //    # matching URI ('xyz' or 'abc')\n                //    filter({'tlid': [1, 3, 6], 'uri': ['xyz', 'abc']})\n                //\n                //:param criteria: one or more rules to match by\n                //:type criteria: dict, of (string, list) pairs\n                //:rtype: list of :class:`mopidy.models.TlTrack`\n            filter(criteria: any /*TODO: a dict*/) {\n                return this.commands.send(\"core.tracklist.filter\", {criteria});\n            },\n                //Get consume mode.\n                //\n                //:class:`True`\n                //    Tracks are removed from the tracklist when they have been played.\n                //:class:`False`\n                //    Tracks are not removed from the tracklist.\n            getConsume() {\n                return this.commands.send(\"core.tracklist.get_consume\");\n            },\n                //The TLID of the track that will be played after the current track.\n                //\n                //Not necessarily the same TLID as returned by :meth:`get_next_tlid`.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getEotTlid() {\n                return this.commands.send(\"core.tracklist.get_eot_tlid\");\n            },\n                //Get length of the tracklist.\n            getLength() {\n                return this.commands.send(\"core.tracklist.get_length\");\n            },\n                //The tlid of the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.next()`.\n                //\n                //For normal playback this is the next track in the tracklist. If repeat\n                //is enabled the next track can loop around the tracklist. When random is\n                //enabled this should be a random track, all tracks should be played once\n                //before the tracklist repeats.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getNextTlid() {\n                return this.commands.send(\"core.tracklist.get_next_tlid\");\n            },\n                //Returns the TLID of the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.previous()`.\n                //\n                //For normal playback this is the previous track in the tracklist. If\n                //random and/or consume is enabled it should return the current track\n                //instead.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getPreviousTlid() {\n                return this.commands.send(\"core.tracklist.get_previous_tlid\");\n            },\n                //Get random mode.\n                //\n                //:class:`True`\n                //    Tracks are selected at random from the tracklist.\n                //:class:`False`\n                //    Tracks are played in the order of the tracklist.\n            getRandom() {\n                return this.commands.send(\"core.tracklist.get_random\");\n            },\n                //Get repeat mode.\n                //\n                //:class:`True`\n                //    The tracklist is played repeatedly.\n                //:class:`False`\n                //    The tracklist is played once.\n            getRepeat() {\n                return this.commands.send(\"core.tracklist.get_repeat\");\n            },\n                //Get single mode.\n                //\n                //:class:`True`\n                //    Playback is stopped after current song, unless in ``repeat`` mode.\n                //:class:`False`\n                //    Playback continues after current song.\n            getSingle() {\n                return this.commands.send(\"core.tracklist.get_single\");\n            },\n                //Get tracklist as list of :class:`mopidy.models.TlTrack`.\n            getTlTracks() {\n                return this.commands.send(\"core.tracklist.get_tl_tracks\");\n            },\n                //Get tracklist as list of :class:`mopidy.models.Track`.\n            getTracks() {\n                return this.commands.send(\"core.tracklist.get_tracks\");\n            },\n                //Get the tracklist version.\n                //\n                //Integer which is increased every time the tracklist is changed. Is not\n                //reset before Mopidy is restarted.\n            getVersion() {\n                return this.commands.send(\"core.tracklist.get_version\");\n            },\n                //The position of the given track in the tracklist.\n                //\n                //If neither *tl_track* or *tlid* is given we return the index of\n                //the currently playing track.\n                //\n                //:param tl_track: the track to find the index of\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:param tlid: TLID of the track to find the index of\n                //:type tlid: :class:`int` or :class:`None`\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n                //    The *tlid* parameter\n            index(tl_track?: TlTrack, tlid?: number) {\n                return this.commands.send(\"core.tracklist.index\", {tl_track, tlid});\n            },\n                //Move the tracks in the slice ``[start:end]`` to ``to_position``.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param start: position of first track to move\n                //:type start: int\n                //:param end: position after last track to move\n                //:type end: int\n                //:param to_position: new position for the tracks\n                //:type to_position: int\n            move(start: number, end: number, to_position: number) {\n                return this.commands.send(\"core.tracklist.move\", {start, end, to_position});\n            },\n                //The track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.next()`.\n                //\n                //For normal playback this is the next track in the tracklist. If repeat\n                //is enabled the next track can loop around the tracklist. When random is\n                //enabled this should be a random track, all tracks should be played once\n                //before the tracklist repeats.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_next_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            nextTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.next_track\", {tl_track});\n            },\n                //Returns the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.previous()`.\n                //\n                //For normal playback this is the previous track in the tracklist. If\n                //random and/or consume is enabled it should return the current track\n                //instead.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_previous_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            previousTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.previous_track\", {tl_track});\n            },\n                //Remove the matching tracks from the tracklist.\n                //\n                //Uses :meth:`filter()` to lookup the tracks to remove.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param criteria: one or more rules to match by\n                //:type criteria: dict, of (string, list) pairs\n                //:rtype: list of :class:`mopidy.models.TlTrack` that were removed\n            remove(criteria: string /*TODO: or list */) {\n                return this.commands.send(\"core.tracklist.remove\", {criteria});\n            },\n                //Set consume mode.\n                //\n                //:class:`True`\n                //    Tracks are removed from the tracklist when they have been played.\n                //:class:`False`\n                //    Tracks are not removed from the tracklist.\n            setConsume(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_consume\", {value});\n            },\n                //Set random mode.\n                //\n                //:class:`True`\n                //    Tracks are selected at random from the tracklist.\n                //:class:`False`\n                //    Tracks are played in the order of the tracklist.\n            setRandom(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_random\", {value});\n            },\n                //Set repeat mode.\n                //\n                //To repeat a single track, set both ``repeat`` and ``single``.\n                //\n                //:class:`True`\n                //    The tracklist is played repeatedly.\n                //:class:`False`\n                //    The tracklist is played once.\n            setRepeat(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_repeat\", {value});\n            },\n                //Set single mode.\n                //\n                //:class:`True`\n                //    Playback is stopped after current song, unless in ``repeat`` mode.\n                //:class:`False`\n                //    Playback continues after current song.\n            setSingle(value: boolean) {\n                return this.commands.send(\"core.tracklist.set_single\", {value});\n            },\n                //Shuffles the entire tracklist. If ``start`` and ``end`` is given only\n                //shuffles the slice ``[start:end]``.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param start: position of first track to shuffle\n                //:type start: int or :class:`None`\n                //:param end: position after last track to shuffle\n                //:type end: int or :class:`None`\n            shuffle(start?: number, end?: number) {\n                return this.commands.send(\"core.tracklist.shuffle\", {start, end});\n            },\n                //Returns a slice of the tracklist, limited by the given start and end\n                //positions.\n                //\n                //:param start: position of first track to include in slice\n                //:type start: int\n                //:param end: position after last track to include in slice\n                //:type end: int\n                //:rtype: :class:`mopidy.models.TlTrack`\n            slice(start: number, end: number) {\n                return this.commands.send(\"core.tracklist.slice\", {start, end});\n            },\n        },\n    }\n}\n","import {Model} from \"../model\";\r\nimport {Commands} from \"../commands\";\r\nimport models from \"../../js/mopidy\";\r\nimport {EboPlayerDataType} from \"../views/view\";\r\nimport {Controller} from \"../controller\";\r\nimport {numberedDictToArray, quadratic100} from \"../global\";\r\nimport TlTrack = models.TlTrack;\r\nimport Ref = models.Ref;\r\nimport {HistoryLine, LibraryDict} from \"../modelTypes\";\r\nimport {SearchResult} from \"../refs\";\r\n\r\nexport class MopidyProxy {\r\n    private controller: Controller;\r\n    private model: Model;\r\n    private commands: Commands;\r\n\r\n    constructor(controller: Controller, model: Model, commands: Commands) {\r\n        this.controller = controller;\r\n        this.model = model;\r\n        this.commands = commands;\r\n    }\r\n\r\n    async fetchRootDirs() {\r\n        return this.browse(null);\r\n    }\r\n\r\n    //todo: this is a test function.\r\n    async fetchTracksforArtist() {\r\n        return await this.commands.core.library.search({artist: [\"Sting\"]}, null);\r\n    }\r\n\r\n    async playTracklistItem(tlid: number) {\r\n        await this.commands.core.playback.play(null, tlid);\r\n    }\r\n\r\n    async addTrackToTracklist(uri: string) {\r\n        return await this.commands.core.tracklist.add(null, null, [uri]);\r\n    }\r\n\r\n    async clearTrackList() {\r\n        await this.commands.core.tracklist.clear();\r\n    }\r\n\r\n    async browse(uri: string) {\r\n        return await this.commands.core.library.browse(uri) as Ref[];\r\n    }\r\n\r\n    async sendVolume(value: number) {\r\n        await this.commands.core.mixer.setVolume(value);\r\n    }\r\n\r\n    async sendStop() {\r\n        return this.commands.core.playback.stop();\r\n    }\r\n\r\n    async sendPause() {\r\n        return this.commands.core.playback.pause();\r\n    }\r\n\r\n    async sendPlay() {\r\n        return this.commands.core.playback.play();\r\n    }\r\n\r\n    async search(uri: string) {\r\n        return await this.commands.core.library.search({uri}, [], true) as SearchResult[];\r\n    }\r\n\r\n    async fetchRequiredData(dataType: EboPlayerDataType) {\r\n        switch (dataType) {\r\n            case EboPlayerDataType.Volume:\r\n                let volume = await this.commands.core.mixer.getVolume() as number;\r\n                this.controller.setVolume(volume);\r\n                break;\r\n            case  EboPlayerDataType.CurrentTrack:\r\n                let track = await this.commands.core.playback.getCurrentTlTrack() as TlTrack;\r\n                await this.controller.setCurrentTrackAndFetchDetails(track);\r\n                break;\r\n            case  EboPlayerDataType.PlayState:\r\n                let state = await this.commands.core.playback.getState() as string;\r\n                this.controller.setPlayState(state);\r\n                break;\r\n            case  EboPlayerDataType.TrackList:\r\n                await this.fetchTracklistAndDetails();\r\n                break;\r\n        }\r\n    }\r\n\r\n    async fetchTracks(uris: string | string[]) {\r\n        if (typeof uris == \"string\")\r\n            uris = [uris];\r\n        let dict: LibraryDict = await this.commands.core.library.lookup(uris);\r\n        return dict;\r\n    }\r\n\r\n    async fetchTracklistAndDetails() {\r\n        let tracks = await this.commands.core.tracklist.getTlTracks();\r\n        this.model.setTrackList(tracks);\r\n    }\r\n\r\n    async fetchHistory() {\r\n        let historyObject: Object = await this.commands.core.history.getHistory();\r\n        let historyLines = numberedDictToArray<HistoryLine>(historyObject, line => {\r\n            return {\r\n                timestamp: line[\"0\"],\r\n                ref: line[\"1\"]\r\n            };\r\n        });\r\n\r\n\r\n        //Make sure a stream is only listed once.\r\n        let foundStreams = new Set<string>();\r\n        let filtered = historyLines.filter(line => {\r\n            if (!line.ref.uri.startsWith(\"http:\"))\r\n                return true; //assume not a stream\r\n            if (foundStreams.has(line.ref.uri))\r\n                return false;\r\n            foundStreams.add(line.ref.uri);\r\n            return true;\r\n        });\r\n\r\n\r\n        let prev = {ref: {uri: \"\"}};\r\n        let dedupLines = filtered.filter((line) => {\r\n            if (line.ref.uri == prev.ref.uri)\r\n                return false;\r\n            prev = line;\r\n            return true;\r\n        });\r\n\r\n        let unique = [...new Set(dedupLines)];\r\n        let dict: LibraryDict = await this.commands.core.library.lookup(unique.map(l => l.ref.uri));\r\n        this.model.addDictToLibraryCache(dict);\r\n\r\n        this.model.setHistory(dedupLines);\r\n    }\r\n\r\n    fetchPlaybackOptions() {\r\n        let promises = [\r\n            this.commands.core.tracklist.getRepeat(),\r\n            this.commands.core.tracklist.getRandom(),\r\n            this.commands.core.tracklist.getConsume(),\r\n            this.commands.core.tracklist.getSingle(),\r\n        ];\r\n        Promise.all(promises).then((results) => {\r\n            this.model.setPlaybackState({\r\n                repeat: results[0],\r\n                random: results[1],\r\n                consume: results[2],\r\n                single: results[3]\r\n            });\r\n        })\r\n    }\r\n\r\n    async fetchCurrentTrackAndDetails() {\r\n        let currentTrack = await this.commands.core.playback.getCurrentTlTrack(); //todo: likely to result in null, as the track probably hasn't been started yet. Remoove this line?\r\n        await this.controller.setCurrentTrackAndFetchDetails(currentTrack);\r\n    }\r\n\r\n    async fetchPlayLists() {\r\n        return await this.commands.core.playlists.asList() as Ref[];\r\n    }\r\n\r\n    async fetchPlaylistItems(uri: string) {\r\n        return await this.commands.core.playlists.getItems(uri) as Ref[];\r\n    }\r\n}","import {BrowseFilterBreadCrumbs, Model} from \"../model\";\r\nimport {jsonParse} from \"../functionsvars\";\r\nimport {BreadCrumbBrowseFilter, BreadCrumbRef, BrowseFilter, FilterBreadCrumbType} from \"../modelTypes\";\r\nimport {BreadCrumb, BreadCrumbStack} from \"../breadCrumb\";\r\nimport models from \"../../js/mopidy\";\r\nimport Ref = models.Ref;\r\n\r\nconst CURRENT_BROWSE_FILTERS__KEY = \"currentBrowseFilters\";\r\nconst BROWSE_FILTERS_BREADCRUMBS_KEY = \"browseFiltersBreadCrumbs\";\r\n\r\nexport class LocalStorageProxy {\r\n    private model: Model;\r\n\r\n    constructor(model: Model) {\r\n        this.model = model;\r\n    }\r\n\r\n    loadCurrentBrowseFilter() {\r\n        let browseFilterString = localStorage.getItem(CURRENT_BROWSE_FILTERS__KEY);\r\n        if (browseFilterString) {\r\n            let browseFilterObject = jsonParse(browseFilterString, this.model.getCurrentBrowseFilter());\r\n            let browseFilter = new BrowseFilter();\r\n            Object.assign(browseFilter, browseFilterObject);\r\n            this.model.setCurrentBrowseFilter(browseFilter);\r\n            return;\r\n        }\r\n        console.error(\"Could not load or parse browse filter bread crumbs from local storage. Using default bread crumbs.\");\r\n    }\r\n\r\n    loadBrowseFiltersBreadCrumbs() {\r\n        let breadCrumbsString = localStorage.getItem(BROWSE_FILTERS_BREADCRUMBS_KEY);\r\n        if (breadCrumbsString) {\r\n            let breadCrumbsArray = jsonParse(breadCrumbsString, this.model.getBreadCrumbs().list());\r\n            let breadCrumbs = new BreadCrumbStack<FilterBreadCrumbType>();\r\n            breadCrumbsArray\r\n                .map(crumb => {\r\n                    switch (crumb.type) {\r\n                        case \"browseFilter\": //todo: make this a const in BreadCrumbBrowseFilter\r\n                            let browseFilter = new BrowseFilter();\r\n                            Object.assign(browseFilter, crumb.data);\r\n                            return new BreadCrumbBrowseFilter(crumb.label, browseFilter);\r\n                        case \"ref\":\r\n                            return new BreadCrumbRef(crumb.label, crumb.data as Ref);\r\n                    }\r\n                })\r\n                .forEach(crumb =>\r\n                    breadCrumbs.push(crumb));\r\n            this.model.setBrowseFilterBreadCrumbs(breadCrumbs);\r\n            return;\r\n        }\r\n        console.error(\"Could not load or parse browse filters from local storage. Using default filters.\");\r\n    }\r\n\r\n    saveCurrentBrowseFilter(browseFilter: BrowseFilter) {\r\n        let obj = JSON.stringify(browseFilter);\r\n        console.log(obj);\r\n        localStorage.setItem(CURRENT_BROWSE_FILTERS__KEY, obj);\r\n    }\r\n\r\n    saveBrowseFilterBreadCrumbs(breadCrumbs: BrowseFilterBreadCrumbs) {\r\n        let obj = JSON.stringify(breadCrumbs.list());\r\n        console.log(obj);\r\n        localStorage.setItem(BROWSE_FILTERS_BREADCRUMBS_KEY, obj);\r\n    }\r\n\r\n}","import models from \"../js/mopidy\";\r\nimport Ref = models.Ref;\r\n\r\nimport {BrowseFilter} from \"./modelTypes\";\r\n\r\nexport interface SearchResult {\r\n    ref: Ref;\r\n    weight: number;\r\n}\r\n\r\nexport abstract class Refs {\r\n    searchResults: SearchResult[];\r\n\r\n    get browseFilter(): BrowseFilter {\r\n        return this._browseFilter;\r\n    }\r\n\r\n    protected constructor() {\r\n        this.searchResults = [];\r\n    }\r\n\r\n    set browseFilter(value: BrowseFilter) {\r\n        this._browseFilter = value;\r\n    }\r\n    private _browseFilter: BrowseFilter;\r\n\r\n    abstract filter(): void;\r\n\r\n    protected calculateWeight(result: SearchResult, browseFilter: BrowseFilter) {\r\n        if (result.ref.name.toLowerCase().startsWith(browseFilter.searchText.toLowerCase()))\r\n            result.weight += 100;\r\n        if (result.ref.name.toLowerCase().includes(browseFilter.searchText.toLowerCase()))\r\n            result.weight += 100;\r\n        if (!browseFilter.searchText)\r\n            result.weight += 1; //No search text? Give every result a weight of 1, so that they are always shown.\r\n    }\r\n\r\n    setFilter(browseFilter: BrowseFilter) {\r\n        this._browseFilter = browseFilter;\r\n    }\r\n\r\n    protected applyFilter(searchResults: SearchResult[]) {\r\n        searchResults.forEach(result => {\r\n            this.calculateWeight(result, this.browseFilter);\r\n        });\r\n        return searchResults\r\n            .filter(result => result.weight > 0)\r\n            .sort((a, b) => {\r\n                if (b.weight === a.weight) {\r\n                    return a.ref.name.localeCompare(b.ref.name);\r\n                }\r\n                return b.weight - a.weight\r\n            });\r\n    }\r\n\r\n    getSearchResults(): SearchResult[] {\r\n        return this.searchResults;\r\n    }\r\n}\r\n\r\nexport class AllRefs extends Refs {\r\n    roots: Ref[];\r\n    sub: Ref[];\r\n    tracks: Ref[];\r\n    albums: Ref[];\r\n    artists: Ref[];\r\n    genres: Ref[];\r\n    radioStreams: Ref[];\r\n    playlists: Ref[];\r\n\r\n    constructor( roots: Ref[], sub: Ref[], tracks: Ref[], albums: Ref[], artists: Ref[], genres: Ref[], radioStreams: Ref[], playlists: Ref[]) {\r\n        super();\r\n        this.roots = roots;\r\n        this.sub = sub;\r\n        this.tracks = tracks;\r\n        this.albums = albums;\r\n        this.artists = artists;\r\n        this.genres = genres;\r\n        this.radioStreams = radioStreams;\r\n        this.playlists = playlists;\r\n    }\r\n\r\n    filter() {\r\n        this.prefillWithTypes(this.browseFilter);\r\n        this.searchResults = this.applyFilter(this.searchResults);\r\n    }\r\n\r\n    private prefillWithTypes(browseFilter: BrowseFilter) {\r\n        this.searchResults = [];\r\n        if(browseFilter.album || browseFilter.isNoTypeSelected())\r\n            this.searchResults.push(...this.albums.map(album => ({ref: album, weight: 0})));\r\n        if(browseFilter.artist || browseFilter.isNoTypeSelected())\r\n            this.searchResults.push(...this.artists.map(artist => ({ref: artist, weight: 0})));\r\n        if(browseFilter.track || browseFilter.isNoTypeSelected())\r\n            this.searchResults.push(...this.tracks.map(track => ({ref: track, weight: 0})));\r\n        if(browseFilter.genre || browseFilter.isNoTypeSelected())\r\n            this.searchResults.push(...this.genres.map(track => ({ref: track, weight: 0})));\r\n        if(browseFilter.radio || browseFilter.isNoTypeSelected())\r\n            this.searchResults.push(...this.radioStreams.map(track => ({ref: track, weight: 0})));\r\n        if(browseFilter.playlist || browseFilter.isNoTypeSelected())\r\n            this.searchResults.push(...this.playlists.map(track => ({ref: track, weight: 0})));\r\n    }\r\n}\r\n\r\nexport class SomeRefs extends Refs {\r\n    refs: Ref[];\r\n\r\n    constructor(refs: Ref[]) {\r\n        super();\r\n        this.refs = refs;\r\n    }\r\n\r\n    filter() {\r\n        this.searchResults = this.refs.map(ref => ({ref: ref, weight: 0}));\r\n        this.searchResults = this.applyFilter(this.searchResults);\r\n    }\r\n}","import {Model} from \"../model\";\r\nimport {EboPlayerDataType} from \"../views/view\";\r\nimport {getHostAndPort} from \"../global\";\r\n\r\nexport class WebProxy {\r\n    private model: Model;\r\n\r\n    constructor(model: Model) {\r\n        this.model = model;\r\n    }\r\n\r\n    async fetchRequiredData(dataType: EboPlayerDataType) {\r\n        switch (dataType) {\r\n            case  EboPlayerDataType.StreamLines:\r\n                await this.fetchActiveStreamLines();\r\n                break;\r\n        }\r\n    }\r\n\r\n    async fetchActiveStreamLines() {\r\n        if (!this.model.currentTrack) {\r\n            this.model.setActiveStreamLinesHistory(undefined);\r\n            return;\r\n        }\r\n\r\n        let url = new URL(`http://${getHostAndPort()}/eboplayer2/stream/activeLines`);\r\n        url.searchParams.set(\"uri\", this.model.currentTrack);\r\n        let res = await fetch(url);\r\n        let lines = await res.json();\r\n        this.model.setActiveStreamLinesHistory(lines);\r\n    }\r\n\r\n    async fetchAllStreamLines(uri: string) {\r\n        let url = new URL(`http://${getHostAndPort()}/eboplayer2/stream/allLines`);\r\n        url.searchParams.set(\"uri\", uri);\r\n        let res = await fetch(url);\r\n        return await res.json() as string[];\r\n    }\r\n}","import getState from \"./playerState\";\r\nimport {showLoading} from \"./functionsvars\";\r\nimport {library} from \"./library\";\r\nimport {transformTlTrackDataToModel} from \"./process_ws\";\r\nimport {Model} from \"./model\";\r\nimport {Commands} from \"./commands\";\r\nimport models, {Mopidy} from \"../js/mopidy\";\r\nimport {EboPlayerDataType} from \"./views/view\";\r\nimport {DataRequester} from \"./views/dataRequester\";\r\nimport {MopidyProxy} from \"./proxies/mopidyProxy\";\r\nimport {LocalStorageProxy} from \"./proxies/localStorageProxy\";\r\nimport {numberedDictToArray, transformLibraryItem} from \"./global\";\r\nimport {AllRefs, SomeRefs} from \"./refs\";\r\nimport {AlbumDataLoaded, AlbumDataType, AlbumNone, AlbumStreamLinesLoaded, BreadCrumbBrowseFilter, BreadCrumbRef, BrowseFilter, ConnectionState, PlayState, StreamTitles, TrackModel, TrackType, Views} from \"./modelTypes\";\r\nimport {JsonRpcController} from \"./jsonRpcController\";\r\nimport {WebProxy} from \"./proxies/webProxy\";\r\nimport TlTrack = models.TlTrack;\r\nimport Ref = models.Ref;\r\nimport Track = models.Track;\r\n\r\n//The controller updates the model and has functions called by the views.\r\n//The controller does not update the views directly.\r\n//The controller should not listen to model events, to avoid circular updates (dead loops).\r\nexport class Controller extends Commands implements DataRequester{\r\n    protected model: Model;\r\n    public mopidyProxy: MopidyProxy;\r\n    public webProxy: WebProxy;\r\n    public localStorageProxy: LocalStorageProxy;\r\n    private eboWebSocketCtrl: JsonRpcController;\r\n\r\n    constructor(model: Model, mopidy: Mopidy, eboWebSocketCtrl: JsonRpcController) {\r\n        super(mopidy);\r\n        this.model  = model;\r\n        this.mopidyProxy = new MopidyProxy(this, model, new Commands(mopidy));\r\n        this.webProxy = new WebProxy(model);\r\n        this.localStorageProxy = new LocalStorageProxy(model);\r\n        this.eboWebSocketCtrl = eboWebSocketCtrl;\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.CurrentTrack];\r\n    }\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[] {\r\n        return this.getRequiredDataTypes();\r\n    }\r\n\r\n    initSocketevents () {\r\n        this.mopidy.on('state:online', async () => {\r\n            this.model.setConnectionState(ConnectionState.Online);\r\n            await getState().getRequiredData();\r\n            await this.mopidyProxy.fetchHistory();\r\n        });\r\n\r\n        this.mopidy.on('state:offline', () => {\r\n            this.model.setConnectionState(ConnectionState.Offline);\r\n        });\r\n\r\n        this.mopidy.on('event:optionsChanged', this.mopidyProxy.fetchPlaybackOptions);\r\n\r\n        this.mopidy.on('event:trackPlaybackStarted', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n            this.setPlayState(\"playing\");\r\n        });\r\n\r\n        this.mopidy.on('event:trackPlaybackResumed', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n        });\r\n\r\n        this.mopidy.on('event:playlistsLoaded', ()  => {\r\n            showLoading(true);\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:playlistChanged', (data) => {\r\n            delete getState().playlists[data.playlist.uri];\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:playlistDeleted', (data) => {\r\n            delete getState().playlists[data.uri];\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:volumeChanged', (data) => {\r\n            this.model.setVolume(data.volume);\r\n        });\r\n\r\n        this.mopidy.on('event:muteChanged', (_data) => {\r\n        });\r\n\r\n        this.mopidy.on('event:playbackStateChanged', (data) => {\r\n            getState().getController().setPlayState(data.new_state);\r\n        });\r\n\r\n        this.mopidy.on('event:tracklistChanged', async () => {\r\n            await this.mopidyProxy.fetchTracklistAndDetails();\r\n            await this.mopidyProxy.fetchCurrentTrackAndDetails();\r\n        });\r\n\r\n        this.mopidy.on('event:seeked', () => {\r\n            // controls.setPosition(data.time_position);\r\n            if (getState().play) {\r\n                getState().syncedProgressTimer.start();\r\n            }\r\n        });\r\n\r\n        //log all events:\r\n        this.mopidy.on((data) => {\r\n            if(data instanceof MessageEvent) {\r\n                try {\r\n                    let dataObject = JSON.parse(data.data);\r\n                    if((dataObject.event ?? \"\") == \"stream_title_changed\")\r\n                        return;\r\n                } catch (e) {} //not valid json.\r\n            }\r\n            if(typeof(data) == \"object\") {\r\n                if((data.title && Object.keys(data).length) == 1)\r\n                    return;\r\n            }\r\n            if(data instanceof Array) {\r\n                if (data.length && data[0] == \"event:streamTitleChanged\")\r\n                    return;\r\n            }\r\n            console.log(data);\r\n        });\r\n        this.eboWebSocketCtrl.on(\"event:streamHistoryChanged\", (data) => {\r\n            let streamTitles: StreamTitles = data.data;\r\n            this.model.setActiveStreamLinesHistory(streamTitles);\r\n        });\r\n    }\r\n\r\n    async setCurrentTrackAndFetchDetails(data: (TlTrack | null)) {\r\n        this.model.setCurrentTrack(transformTlTrackDataToModel(data));\r\n        await this.webProxy.fetchActiveStreamLines();\r\n        //todo: do this only when a track is started?s\r\n        // this.core.playback.getTimePosition().then(processCurrentposition, console.error)\r\n        // this.core.playback.getState().then(processPlaystate, console.error)\r\n        // this.core.mixer.getMute().then(processMute, console.error)\r\n    }\r\n\r\n    setVolume(volume: number) {\r\n        this.model.setVolume(volume);\r\n    }\r\n\r\n    setPlayState(state: string) {\r\n        this.model.setPlayState(state as PlayState);\r\n    }\r\n\r\n    setTracklist(trackList: TlTrack[]) {\r\n        this.model.setTrackList(trackList);\r\n    }\r\n\r\n    setAndSaveBrowseFilter(filter: BrowseFilter) {\r\n        this.localStorageProxy.saveCurrentBrowseFilter(filter);\r\n        this.model.setCurrentBrowseFilter(filter);\r\n        this.filterBrowseResults();\r\n    }\r\n\r\n    diveIntoBrowseResult(label: string, uri: string, type: string) {\r\n        if(type == \"track\"  ||  type  == \"radio\") {\r\n            this.clearListAndPlay(uri).then(() => {});\r\n            return; //don't dive.\r\n        }\r\n\r\n        if(type == \"album\") {\r\n            this.model.setAlbumToView(uri);\r\n            this.setView(Views.Album);\r\n            return;\r\n        }\r\n\r\n        // set 2 new breadCrumbs and a new browseFilter.\r\n        // > setting the browseFilter should only trigger a view update. NOT a re-filter!!!\r\n        let browseFilter = this.model.getCurrentBrowseFilter();\r\n        let breadCrumb1 = new BreadCrumbBrowseFilter(browseFilter.searchText, browseFilter);\r\n        this.model.pushBreadCrumb(breadCrumb1);\r\n\r\n        let ref: Ref = {type: type as models.ModelType, name: label, uri};\r\n        let breadCrumb2 = new BreadCrumbRef(label, ref);\r\n        this.model.pushBreadCrumb(breadCrumb2);\r\n\r\n        this.localStorageProxy.saveBrowseFilterBreadCrumbs(this.model.getBreadCrumbs());\r\n\r\n        let newBrowseFilter = new BrowseFilter();\r\n        //for each type, we dive into the next level of type. E.g., artist -> album -> track.\r\n        switch (type) {\r\n            case \"artist\": newBrowseFilter.album = true; break;\r\n            case \"genre\":\r\n                newBrowseFilter.radio = true;\r\n                newBrowseFilter.playlist = true;\r\n                newBrowseFilter.artist = true;\r\n                newBrowseFilter.album = true;\r\n                newBrowseFilter.track = true;\r\n                newBrowseFilter.genre = true;\r\n                break;\r\n            case \"playlist\":\r\n                newBrowseFilter.playlist = true;\r\n                newBrowseFilter.artist = true;\r\n                newBrowseFilter.album = true;\r\n                newBrowseFilter.track = true;\r\n                break;\r\n        }\r\n        this.setAndSaveBrowseFilter(newBrowseFilter);\r\n\r\n        this.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n            this.filterBrowseResults();\r\n        });\r\n    }\r\n\r\n    resetToBreadCrumb(id: number) {\r\n        let breadCrumb = getState().getModel().getBreadCrumbs().get(id);\r\n        let breadCrumbs = getState().getModel().getBreadCrumbs();\r\n\r\n        //if the breadCrumb is a browseFilter, reset to the previous breadCrumb and set the current browseFilter to the one in the breadCrumb.\r\n        if(breadCrumb instanceof BreadCrumbBrowseFilter) {\r\n            this.model.resetBreadCrumbsTo(id);\r\n            let browseFilter = this.model.popBreadCrumb().data as BrowseFilter;\r\n            this.setAndSaveBrowseFilter(browseFilter);\r\n            this.localStorageProxy.saveBrowseFilterBreadCrumbs(breadCrumbs);\r\n            this.fetchRefsForCurrentBreadCrumbs().then(() => {\r\n                this.filterBrowseResults();\r\n            });\r\n        }\r\n        //todo: if the breadCrumb is a uri, reset to the CURRENT breadCrumb and clear the current browseFilter.\r\n    }\r\n\r\n    async getTrackInfoCached(uri: string) {\r\n        let track  = getState().getModel().getTrackInfo(uri);\r\n        if(!track)\r\n            await this.lookupCached(uri);\r\n\r\n        return transformLibraryItem(track);\r\n    }\r\n\r\n    async lookupCached(uri: string) {\r\n        let tracks = this.model.getTrackFromCache(uri);\r\n        if(tracks)\r\n            return tracks;\r\n        let dict = await this.mopidyProxy.fetchTracks(uri);\r\n        this.model.addDictToLibraryCache(dict);\r\n        return this.model.getTrackFromCache(uri);\r\n    }\r\n\r\n    async clearListAndPlay(uri: string) {\r\n        await this.mopidyProxy.clearTrackList();\r\n        let trackList = await this.addToPlaylist(uri);\r\n        // noinspection ES6MissingAwait\r\n        this.play(trackList[0].tlid);\r\n    }\r\n\r\n    async play(tlid: number) {\r\n        // noinspection ES6MissingAwait\r\n        this.mopidyProxy.playTracklistItem(tlid);\r\n    }\r\n\r\n    private async addToPlaylist(uri: string) {\r\n        let tracks = await this.mopidyProxy.addTrackToTracklist(uri);\r\n        let trackList = numberedDictToArray(tracks) as models.TlTrack[];\r\n        this.setTracklist(trackList);\r\n        return trackList;\r\n    }\r\n\r\n    setSelectedTrack(uri: string) {\r\n        this.model.setSelectedTrack(uri);\r\n    }\r\n\r\n    async getCurrertTrackInfoCached() {\r\n        let trackUri = this.model.getCurrentTrack();\r\n        if(!trackUri)\r\n            return undefined;\r\n        return await this.getTrackInfoCached(trackUri);\r\n    }\r\n\r\n    readonly LIBRARY_PROTOCOL = \"eboback:\";\r\n\r\n    async fetchAllRefs() {\r\n        let roots = await this.mopidyProxy.fetchRootDirs();\r\n        let subDir1 = await this.mopidyProxy.browse(roots[1].uri);\r\n        let allTracks = await this.mopidyProxy.browse(this.LIBRARY_PROTOCOL+\"directory?type=track\");\r\n        let allAlbums = await this.mopidyProxy.browse(this.LIBRARY_PROTOCOL+\"directory?type=album\");\r\n        let allArtists = await this.mopidyProxy.browse(this.LIBRARY_PROTOCOL+\"directory?type=artist\");\r\n        let allGenres = await this.mopidyProxy.browse(this.LIBRARY_PROTOCOL+\"directory?type=genre\");\r\n        let playLists = await this.mopidyProxy.fetchPlayLists();\r\n        let radioStreamsPlayList = playLists.find(playlist => playlist.name == \"[Radio Streams]\");\r\n        let playlists = playLists.filter(playlist => playlist.name != \"[Radio Streams]\");\r\n        let radioStreams: models.Ref[];\r\n        if(radioStreamsPlayList) {\r\n            radioStreams = await this.mopidyProxy.fetchPlaylistItems(radioStreamsPlayList.uri);\r\n        }\r\n\r\n        return new AllRefs(roots, subDir1, allTracks, allAlbums, allArtists, allGenres, radioStreams, playlists);\r\n    }\r\n\r\n    filterBrowseResults() {\r\n        this.model.filterCurrentRefs();\r\n    }\r\n\r\n    async fetchRefsForCurrentBreadCrumbs() {\r\n        let breadCrumbs = this.model.getBreadCrumbs();\r\n        let lastCrumb = breadCrumbs.getLast();\r\n        if(!lastCrumb) {\r\n            await this.setAllRefsAsCurrent();\r\n            return;\r\n        }\r\n\r\n        if(lastCrumb instanceof BreadCrumbBrowseFilter) {\r\n            await this.setAllRefsAsCurrent();\r\n            return;\r\n        }\r\n\r\n        if(lastCrumb instanceof BreadCrumbRef) {\r\n            if(lastCrumb.data.type == \"playlist\") {\r\n                let playlistItems = await this.mopidyProxy.fetchPlaylistItems(lastCrumb.data.uri);\r\n                playlistItems.forEach(ref => {\r\n                    //\"local:track:Air/Moon%20Safari/01%20La%20Femme%20d%27Argent.wma\"\r\n                    ref.name = ref.uri\r\n                        .replace(\"local:track:\", \"\")\r\n                        .replaceAll(\"%20\", \" \");\r\n                    //remove the last part of the uri, which is the file extension.\r\n                    ref.name = ref.name.split(\".\").slice(0,-1).join(\".\");\r\n                });\r\n                this.model.setCurrentRefs(new SomeRefs(playlistItems));\r\n                return;\r\n            }\r\n\r\n            let refs = await this.mopidyProxy.browse(lastCrumb.data.uri);\r\n            this.model.setCurrentRefs(new SomeRefs(refs));\r\n            return;\r\n        }\r\n    }\r\n\r\n    private async setAllRefsAsCurrent() {\r\n        if (!this.model.getAllRefs()) {\r\n            let allRefs = await this.fetchAllRefs();\r\n            this.model.setAllRefs(allRefs);\r\n        }\r\n        this.model.setCurrentRefs(this.model.getAllRefs());\r\n    }\r\n\r\n    playAlbum(albumUri: string) {\r\n        this.clearListAndPlay(albumUri);\r\n    }\r\n\r\n    addAlbum(albumUri: string) {\r\n        this.addToPlaylist(albumUri);\r\n    }\r\n\r\n    async fetchAlbumDataForTrack(track: TrackModel) {\r\n        if (!track)\r\n            return AlbumNone;\r\n        switch (track.type) {\r\n            case TrackType.File:\r\n                console.log(track.track.album.uri);\r\n                let albumUri = track.track.album.uri;\r\n                return await this.fetchAlbumInfo(albumUri);\r\n            case TrackType.Stream:\r\n                let stream_lines = await this.webProxy.fetchAllStreamLines(track.track.uri);\r\n                let groupLines = function (grouped: string[][], line: string){\r\n                    if(line == \"---\") {\r\n                        grouped.push([]);\r\n                        return grouped;\r\n                    }\r\n                    grouped[grouped.length-1].push(line);\r\n                    return grouped;\r\n                }\r\n                let grouped = stream_lines\r\n                    .reduce<string[][]>(groupLines, new Array([]))\r\n                    .filter(lineGroup => lineGroup.length);\r\n                let albumInfo: AlbumStreamLinesLoaded = {\r\n                    type: AlbumDataType.StreamLinesLoaded,\r\n                    lines: grouped,\r\n                    albumTrack: track.track\r\n                };\r\n                return albumInfo;\r\n        }\r\n    }\r\n\r\n    async fetchAlbumInfo(albumUri: string) {\r\n        let album = await this.lookupCached(albumUri);\r\n        let albumTracks = numberedDictToArray<Track>(album);\r\n        let albumData: AlbumDataLoaded = {\r\n            type: AlbumDataType.Loaded,\r\n            tracks: albumTracks,\r\n            albumTrack: undefined,\r\n            albumInfo: albumTracks[0].album //bit of a hack\r\n        };\r\n        return albumData;\r\n    }\r\n\r\n    setView(view: Views) {\r\n        this.model.setView(view);\r\n    }\r\n\r\n    async fetchAllAlbums() {\r\n        //get all the albums.\r\n        //first refs:\r\n        let albumRefs = await this.mopidyProxy.browse(\"local:directory?type=album\");\r\n        let albumsPromises = albumRefs.map(async ref => {\r\n            return await this.fetchAlbumInfo(ref.uri);\r\n        });\r\n\r\n        let albums = await Promise.all(albumsPromises);\r\n\r\n        console.log(albums);\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {EboplayerEvents, PlayState, Views} from \"../modelTypes\";\r\nimport {MainView} from \"./mainView\";\r\nimport {EboButtonBar} from \"../components/eboButtonBarComp\";\r\nimport {console_yellow} from \"../global\";\r\n\r\nexport class ButtonBarView extends View {\r\n    private componentId: string;\r\n    private parent: MainView;\r\n\r\n    constructor(containerId: string, parent: MainView) {\r\n        super();\r\n        this.parent = parent;\r\n        this.componentId = containerId;\r\n    }\r\n\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.playStateChanged, () => {\r\n            this.onPlaybackStateChangegd();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, () => {\r\n            this.onSelectedTrackChanged();\r\n        });\r\n\r\n        //todo: capture img click in comp.\r\n        // document.getElementById(\"buttonBarImg\").onclick = () => {\r\n        //     this.onButtonBarImgClicked();\r\n        // }\r\n\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.addEventListener(EboplayerEvents.playPressed, () => {\r\n            this.playOrStopOrPause(EboplayerEvents.playPressed).then(r => {});\r\n        });\r\n        comp.addEventListener(EboplayerEvents.stopPressed, () => {\r\n            this.playOrStopOrPause(EboplayerEvents.stopPressed).then(r => {});\r\n        });\r\n        comp.addEventListener(EboplayerEvents.pausePressed, () => {\r\n            this.playOrStopOrPause(EboplayerEvents.pausePressed).then(r => {});\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.volumeChanged, () => {\r\n            this.onVolumeChanged();\r\n        });\r\n        comp.addEventListener(EboplayerEvents.changingVolume, async (ev) => {\r\n            console_yellow(`buttonBarrView.event:changingVolume:`);\r\n            console.log(ev);\r\n            let value = parseInt((ev as CustomEvent).detail.volume);\r\n            console_yellow(`value=${value}`);\r\n            await getState().getController().mopidyProxy.sendVolume(value);\r\n\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.viewChanged, () => {\r\n            this.showHideInfo();\r\n        });\r\n    }\r\n\r\n    private onVolumeChanged() {\r\n        let volume = getState().getModel().getVolume();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"volume\", volume.toString());\r\n\r\n    }\r\n\r\n    private onPlaybackStateChangegd() {\r\n        let playState = getState().getModel().getPlayState();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"playing\", (playState == PlayState.playing).toString());\r\n    }\r\n\r\n    private async onCurrentTrackChanged() {\r\n        let currentTrack = await getState().getController().getCurrertTrackInfoCached();\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.track = currentTrack;\r\n        this.showHideInfo();\r\n    }\r\n\r\n    private async onSelectedTrackChanged() {\r\n        this.showHideInfo();\r\n    }\r\n\r\n    private showHideInfo() {\r\n        let currentTrack = getState().getModel().getCurrentTrack();\r\n        let selectedTrack = getState().getModel().getSelectedTrack();\r\n        let currentView = getState().getModel().getView();\r\n        let show_info = false;\r\n        if(selectedTrack && currentTrack != selectedTrack)\r\n            show_info = true;\r\n        if(currentView != Views.NowPlaying)\r\n            show_info = true;\r\n        let comp = document.getElementById(this.componentId) as EboButtonBar;\r\n        comp.setAttribute(\"show_info\", show_info.toString());\r\n    }\r\n\r\n    private async playOrStopOrPause(event: EboplayerEvents) {\r\n        switch(event) {\r\n            case EboplayerEvents.playPressed:\r\n                await getState().getController().mopidyProxy.sendPlay();\r\n                break;\r\n            case EboplayerEvents.stopPressed:\r\n                await getState().getController().mopidyProxy.sendStop();\r\n                break;\r\n            case EboplayerEvents.pausePressed:\r\n                await getState().getController().mopidyProxy.sendPause();\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.PlayState, EboPlayerDataType.Volume];\r\n    }\r\n\r\n    private onButtonBarImgClicked() {\r\n        getState().getController().setSelectedTrack(getState().getModel().getCurrentTrack());\r\n        this.parent.showView(Views.NowPlaying); //todo: this call of function in parent is ugly.\r\n    }\r\n}\r\n","export interface HasName {\r\n    tagName: string;\r\n}\r\n\r\nexport abstract class EboComponent extends HTMLElement implements HasName {\r\n    static globalCss: CSSStyleSheet[];\r\n    protected shadow: ShadowRoot; //todo: make private and expose only in renderPrepared and updateWhenConnected.\r\n    protected styleTemplate: HTMLTemplateElement;\r\n    protected divTemplate: HTMLTemplateElement;\r\n    private connected = false;\r\n    private static readonly NO_TAG_NAME: string = \"todo: override in subclass\";\r\n    static tagName: string = EboComponent.NO_TAG_NAME;\r\n\r\n    protected constructor(styleText: string, htmlText: string) {\r\n        super();\r\n        this.shadow = this.attachShadow({mode: \"open\"});\r\n        this.styleTemplate = document.createElement(\"template\");\r\n        this.divTemplate = document.createElement(\"template\");\r\n        this.styleTemplate.innerHTML = styleText;\r\n        this.divTemplate.innerHTML = htmlText;\r\n    }\r\n        // noinspection JSUnusedGlobalSymbols\r\n    attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n        if(oldValue === newValue)\r\n            return;\r\n        this.attributeReallyChangedCallback(name, oldValue, newValue);\r\n    }\r\n\r\n    abstract attributeReallyChangedCallback(name: string, oldValue: string, newValue: string): void;\r\n\r\n    static setGlobalCss(text: string[]) {\r\n        this.globalCss = text.map(text => {\r\n            let css = new CSSStyleSheet();\r\n            css.replaceSync(text);\r\n            return css;\r\n        });\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n        this.connected = true;\r\n        this.onConnected();\r\n    }\r\n\r\n    onConnected(){\r\n        //todo: make this abstract.\r\n    }\r\n\r\n    update() { //todo: aad TS option `noImplicitOverride` and set `override` modifier where needed.\r\n        if (!this.connected)\r\n            return;\r\n        //todo: batch updates.\r\n        this.updateWhenConnected();\r\n    }\r\n\r\n    updateWhenConnected(): void {\r\n        //should be overridden by subclasses.\r\n    }\r\n\r\n    render() {\r\n        if(!this.shadow)\r\n            return;\r\n        this.shadow.innerHTML = \"\";\r\n        if(EboComponent.globalCss) {\r\n            this.shadow.adoptedStyleSheets = EboComponent.globalCss;\r\n        }\r\n\r\n        this.renderPrepared();\r\n    }\r\n\r\n    abstract renderPrepared(): void;\r\n\r\n    setClassFromBoolAttribute(attName: string, el: HTMLElement) {\r\n        if (this[attName] == true)\r\n            el.classList.add(attName);\r\n        else\r\n            el.classList.remove(attName);\r\n    }\r\n\r\n    static define(comp: new (...args: any[]) => EboComponent) {\r\n        // @ts-ignore\r\n        if((comp as typeof EboComponent).tagName == EboComponent.NO_TAG_NAME)\r\n            throw \"Component class should have tagName defined.\";\r\n        // @ts-ignore\r\n        customElements.define(comp.tagName, comp);\r\n    }\r\n\r\n    addShadowEventListener(id: string, type: string, listener: (this: HTMLElement, ev: MouseEvent) => any) {\r\n        this.shadow.getElementById(id).addEventListener(type, listener);\r\n    }\r\n}\r\n\r\n","import {EboComponent} from \"./EboComponent\";\r\n\r\nexport class EboProgressBar extends EboComponent {\r\n    static readonly tagName=  \"ebo-progressbar\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    private position: number = 51;\r\n    private min: number = 0;\r\n    private max: number = 100;\r\n    private active: boolean = false;\r\n    private button: boolean = true;\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n        .movingGradient {\r\n            background-color: #555;\r\n        }\r\n        .active .movingGradient {\r\n            --darkGradient: #555;\r\n            background: linear-gradient(to right, var(--darkGradient),\r\n            #2a84a5, var(--darkGradient), #ffffff,\r\n                var(--darkGradient), #ca497c, var(--darkGradient), #9e9c2d, var(--darkGradient), #ee7752, var(--darkGradient),\r\n                #2a84a5\r\n            );\r\n            background-size: 1100% 1100%;  /*Must be a multiple of the number of colors above for a smooth transistion and the last color must be the first*/\r\n            animation: gradient 15s forwards infinite linear;\r\n            animation-timing-function: linear;\r\n            animation-direction: normal;\r\n        }\r\n        .button #button {\r\n                background-color: white;\r\n                width: 3px; \r\n                display: inline-block;\r\n                box-shadow: 0 0 5px white, 0 0 5px white,  0 0 5px white, 0 0 5px white, 0 0 15px white;\r\n        }\r\n        @keyframes gradient {\r\n            0% {\r\n                background-position: 0% 50%;\r\n            }\r\n            100% {\r\n                background-position: 100% 50%;\r\n            }\r\n        }\r\n        </style>\r\n    `;\r\n\r\n    static htmlText = `\r\n        <div style=\"\r\n            background-color: #444; \r\n            height: 1px; \r\n            display: flex; \r\n            \">\r\n            <div class=\"movingGradient\" style=\"\r\n                height: 1px;\r\n                display: inline-block;\">\r\n            </div>\r\n            <div id=\"button\"></div>\r\n        </div>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboProgressBar.styleText, EboProgressBar.htmlText);\r\n        this.render();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"position\":\r\n            case \"min\":\r\n            case \"max\":\r\n                let test = parseInt(newValue);\r\n                if (isNaN(test))\r\n                    throw `\"${name}\" attribute should be a number. Current value: \"${newValue}\"`;\r\n                this[name] = test;\r\n                break;\r\n            case \"active\":\r\n            case \"button\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        if(!(this.min <= this.position && this.position <= this.max))\r\n            throw `Attribute position=\"${this.position}\" should be between min=\"${this.min}\" and max=\"${this.max}\".`;\r\n        this.render();\r\n        }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n    }\r\n\r\n    renderPrepared() {\r\n        let percent = (this.position - this.min) / (this.max-this.min) * 100;\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let styleElement = this.shadow.appendChild(document.createElement(\"style\"));\r\n        styleElement.innerHTML = `.movingGradient { width: ${percent}%; } `;\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        this.setClassFromBoolAttribute(\"button\", fragment.firstElementChild as HTMLElement);\r\n        this.setClassFromBoolAttribute(\"active\", fragment.firstElementChild as HTMLElement);\r\n        this.shadow.appendChild(fragment);\r\n    }\r\n\r\n    setClassFromBoolAttribute(attName: string, el: HTMLElement) {\r\n        if (this[attName] == true)\r\n            el.classList.add(attName);\r\n        else\r\n            el.classList.remove(attName);\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport models from \"../../js/mopidy\";\r\nimport {transformTrackDataToModel} from \"../global\";\r\nimport {EboplayerEvents, HistoryLine, TrackType} from \"../modelTypes\";\r\n\r\nexport class TimelineView extends View {\r\n    private clickedRow: HTMLTableRowElement;\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.historyChanged, () => {\r\n            this.rebuildTimeline().then(r => {});\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.trackListChanged, () => {\r\n            this.rebuildTimeline().then(r => {});\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, () => {\r\n            this.onSelectedTrackChanged();\r\n        });\r\n    }\r\n\r\n\r\n    private async rebuildTimeline() {\r\n        let history = getState().getModel().getHistory() ?? [];\r\n        let trackList = getState().getModel().getTrackList() ?? [];\r\n\r\n        let timelineTable = document.getElementById(\"timelineTable\") as HTMLTableElement;\r\n        let body = timelineTable.tBodies[0];\r\n        body.innerHTML = \"\";\r\n\r\n        let allLookups: Promise<void>[] = [];\r\n        //reverse order as we want the most recent tracks to at the bottom.\r\n        for(let i = history.length - 1; i >= 0; i-- ) {\r\n            allLookups.push(this.insertHistoryLine(history[i], body));\r\n        }\r\n\r\n        //The last history line may be the current track. If so, we don't want to insert it again.\r\n        let sliceStart = 0;\r\n        if(trackList.length > 0 && history[0]?.ref.uri == trackList[0].track.uri)\r\n            sliceStart = 1;\r\n        for(let track of trackList.slice(sliceStart)) {\r\n            allLookups.push(this.insertTrackLine(track.track.name, track.track.uri, body, [], track.tlid)); //todo: actually we already have the track info. No need for lookup.\r\n        }\r\n\r\n        Promise.all(allLookups).then(()=> {\r\n            this.setCurrentTrack();\r\n        });\r\n\r\n        body.querySelectorAll(\"tr\").forEach(tr => {\r\n            tr.addEventListener(\"dblclick\", ev => {this.onRowDoubleClicked(ev)});\r\n            tr.addEventListener(\"click\", ev => {this.onRowClicked(ev)});\r\n        });\r\n    }\r\n\r\n    private onRowClicked(ev: MouseEvent) {\r\n        let row = ev.currentTarget as HTMLTableRowElement;\r\n        this.setRowsClass(row, [\"clicked\"]);\r\n\r\n        getState().getController().setSelectedTrack(row.dataset.uri);\r\n    }\r\n\r\n    private async onRowDoubleClicked(ev: MouseEvent) {\r\n        this.clickedRow = ev.currentTarget as HTMLTableRowElement;\r\n        if(this.clickedRow.dataset.tlid)\r\n            await getState().getController().play(parseInt(this.clickedRow.dataset.tlid));\r\n        else\r\n            await getState().getController().clearListAndPlay(this.clickedRow.dataset.uri);\r\n    }\r\n\r\n    private setRowsClass(rowOrSelector: HTMLTableRowElement | string, classes: string[]) {\r\n        document\r\n            .getElementById(\"timelineTable\")\r\n            .querySelectorAll(`tr`)\r\n            .forEach(tr =>\r\n                tr.classList.remove(...classes)\r\n            );\r\n        if(rowOrSelector instanceof HTMLTableRowElement)\r\n            rowOrSelector.classList.add(...classes);\r\n        else {\r\n            document\r\n                .getElementById(\"timelineTable\")\r\n                .querySelectorAll(rowOrSelector)\r\n                .forEach(tr =>\r\n                    tr.classList.add(...classes)\r\n                );\r\n        }\r\n    }\r\n\r\n    private setSelectedTrack() {\r\n        let selectedTrackUri = getState().getModel().getSelectedTrack();\r\n        this.setRowsClass(`tr[data-uri=\"${selectedTrackUri}\"]`, [\"selected\"]);\r\n    }\r\n\r\n    private async setCurrentTrack() {\r\n        let timelineTable = document.getElementById(\"timelineTable\") as HTMLTableElement;\r\n        let currentTrack = await getState().getController().getCurrertTrackInfoCached();\r\n        if(!currentTrack)\r\n            return;\r\n        if (currentTrack.type == TrackType.None)\r\n            return; // don't clear the screen as this is probably temporary and will cause a flicker.\r\n        let currentUri = currentTrack.track.uri;\r\n        let trs = [...timelineTable.querySelectorAll(`tr[data-uri=\"${currentUri}\"]`)];\r\n        if(trs.length == 0)\r\n            return;\r\n        let tr = trs[trs.length - 1];\r\n        if(this.clickedRow?.dataset?.uri != currentTrack.track.uri)\r\n            tr.scrollIntoView( { block: \"nearest\" });\r\n        timelineTable.querySelectorAll(\"tr\").forEach(tr  => tr.classList.remove(\"current\", \"textGlow\"));\r\n        tr.classList.add(\"current\", \"textGlow\");\r\n    }\r\n\r\n    private async insertHistoryLine(line: HistoryLine, body: HTMLTableSectionElement) {\r\n        let slices = line.ref.name.split(\" - \");\r\n        let title = slices.pop();\r\n        await this.insertTrackLine(title, line.ref.uri, body, [\"historyLine\"]);\r\n    }\r\n\r\n    private async insertTrackLine(title: string, uri: string, body: HTMLTableSectionElement, classes: string[] = [], tlid?: number) {\r\n        let tr = document.createElement(\"tr\");\r\n        body.appendChild(tr);\r\n        tr.classList.add(\"trackLine\", ...classes);\r\n        tr.dataset.uri = uri;\r\n        if(tlid)\r\n            tr.dataset.tlid = tlid.toString();\r\n        this.setTrackLineContent(tr, title);\r\n        body.insertAdjacentHTML('beforeend', `\r\n<tr>\r\n    <td colspan=\"2\">\r\n        <div class=\"progressBar\"></div>\r\n    </td>\r\n</tr>\r\n            `);\r\n\r\n        //delayed update of track info.\r\n        const tracks = await getState().getController().lookupCached(uri);\r\n        this.updateTrackLineFromLookup(tr, tracks, title);\r\n    }\r\n\r\n    private updateTrackLineFromLookup(tr: HTMLTableRowElement, tracks: models.Track[], title: string) {\r\n        let track = transformTrackDataToModel(tracks[0]);\r\n        let artist =  \"\";\r\n        let album =  \"\";\r\n        switch (track.type) {\r\n            case TrackType.File:\r\n                title = track.title;\r\n                artist = track.track.artists[0].name; //todo: add other names?\r\n                album = track.track.album.name;\r\n                break;\r\n            case TrackType.Stream:\r\n                title = track.name;\r\n                break;\r\n        }\r\n        this.setTrackLineContent(tr, title, artist, album);\r\n    }\r\n\r\n    private setTrackLineContent(tr: HTMLTableRowElement, title: string, artist: string = \"\", album: string = \"\") {\r\n        tr.innerHTML = `\r\n    <td>\r\n        <h1>${title}</h1>\r\n        <small>${artist}  ${album}</small>\r\n    </td>\r\n    <td>\r\n        <button><i class=\"fa fa fa-ellipsis-v\"></i></button>\r\n    </td>\r\n            `;\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.TrackList];\r\n    }\r\n\r\n    private onCurrentTrackChanged() {\r\n        this.setCurrentTrack();\r\n    }\r\n\r\n    private onSelectedTrackChanged() {\r\n        this.setSelectedTrack();\r\n    }\r\n\r\n}\r\n","import {EboComponent} from \"./EboComponent\";\r\nimport {EboAlbumTracksComp} from \"./eboAlbumTracksComp\";\r\nimport {AlbumData, AlbumDataType, AlbumNone} from \"../modelTypes\";\r\n\r\nexport class EboBigTrackComp extends EboComponent {\r\n    get activeTrackUri(): string | null {\r\n        return this._activeTrackUri;\r\n    }\r\n    set activeTrackUri(value: string | null) {\r\n        this._activeTrackUri = value;\r\n        this.onActiveTrackChanged();\r\n    }\r\n    get albumInfo(): AlbumData {\r\n        return this._albumInfo;\r\n    }\r\n\r\n    set albumInfo(value: AlbumData) {\r\n        this._albumInfo = value;\r\n        this.render();\r\n    }\r\n\r\n    private _activeTrackUri: string | null = null;\r\n    static readonly tagName=  \"ebo-big-track-view\";\r\n    static progressBarAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"name\", \"stream_lines\", \"extra\", \"img\", \"disabled\", \"show_back\",\r\n        ...EboBigTrackComp.progressBarAttributes\r\n    ];\r\n    private name: string = \"\";\r\n    private stream_lines: string = \"\";\r\n    private extra: string = \"\";\r\n    private enabled: boolean = false;\r\n    private show_back: boolean = false;\r\n    //for progressBar\r\n    private position: string = \"40\";\r\n    private min: string = \"0\";\r\n    private max: string = \"100\";\r\n    private button: string = \"false\";\r\n    private active: string = \"true\";\r\n\r\n    private img: string  = \"images/default_cover.png\";\r\n    private albumClickEvent: CustomEvent<unknown>;\r\n    private _albumInfo: AlbumData;\r\n\r\n    static styleText= `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                } \r\n                h3 {\r\n                    margin-block-start: .5em;\r\n                    margin-block-end: .5em;\r\n                }\r\n                .albumCoverContainer {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    align-content: center;\r\n                    overflow: hidden;\r\n                }\r\n                img {\r\n                    width: 100%;\r\n                    height: 100%;\r\n                    object-fit: contain;\r\n                }\r\n                ebo-progressbar {\r\n                    margin-top: .5em;\r\n                }\r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: row;\r\n                    height: 100%;\r\n                    width: 100%;\r\n                    #front {\r\n                        display: flex;\r\n                        flex-direction: column;\r\n                        width: 100%;\r\n                    }\r\n                }\r\n                #wrapper.front {\r\n                    #back {\r\n                        display: none;\r\n                    }                \r\n                }\r\n                .info {\r\n                    font-size: .7em;\r\n                }\r\n                ebo-album-tracks-view {\r\n                    height: 100%;\r\n                }\r\n            </style>\r\n        `;\r\n\r\n    // noinspection HtmlUnknownTarget\r\n    static htmlText = `\r\n            <div id=\"wrapper\" class=\"front\">\r\n                <div id=\"front\">\r\n                    <div class=\"albumCoverContainer\">\r\n                        <img id=\"img\" src=\"images/default_cover.png\" alt=\"Album cover\"/>\r\n                        <ebo-progressbar position=\"40\" active=\"false\" button=\"false\"></ebo-progressbar>\r\n                    </div>\r\n        \r\n                    <div id=\"info\">\r\n                        <h3 id=\"albumTitle\" class=\"selectable\"></h3>\r\n                        <h3 id=\"name\" class=\"selectable\"></h3>\r\n                        <div id=\"stream_lines\" class=\"selectable info\"></div>\r\n                        <div id=\"extra\" class=\"selectable info\"></div>\r\n                    </div>\r\n                </div>\r\n            </div>        \r\n        `;\r\n\r\n    constructor() {\r\n        super(EboBigTrackComp.styleText, EboBigTrackComp.htmlText);\r\n        this.albumInfo = AlbumNone;\r\n        this.render();\r\n        this.albumClickEvent = new CustomEvent(\"albumClick\", {\r\n            bubbles: true,\r\n            cancelable: false,\r\n            composed: true, //needed to 'break' out of the shadow.\r\n            detail: \"todo: tadaaa!\"\r\n        });\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        if(EboBigTrackComp.progressBarAttributes.includes(name)) {\r\n            this[name] = newValue;\r\n            this.shadow.querySelector(\"ebo-progressbar\")?.setAttribute(name, newValue);\r\n            return;\r\n        }\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"stream_lines\":\r\n            case \"extra\":\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"enabled\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.render();\r\n        }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n        super.connectedCallback();\r\n    }\r\n\r\n    renderPrepared() {\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        [\"name\", \"stream_lines\", \"extra\"].forEach(attName => {\r\n            fragment.getElementById(attName).innerHTML = this[attName];\r\n        });\r\n        let progressBarElement = fragment.querySelector(\"ebo-progressbar\") as HTMLElement;\r\n        //todo: try casting to EboProgressBar class and set attributes directly? Without re-rendering?\r\n        EboBigTrackComp.progressBarAttributes.forEach(attName => {\r\n            progressBarElement.setAttribute(attName, this[attName]);//todo: check if each of these causes a re-rendering.\r\n        });\r\n        //todo: image.\r\n        this.shadow.appendChild(fragment);\r\n        // let img = this.shadow.getElementById(\"img\");\r\n        // img.addEventListener(\"click\", (ev) => {\r\n        //     this.dispatchEvent(this.albumClickEvent);\r\n        // });\r\n        this.addShadowEventListener(\"img\",\"click\", (ev) => {\r\n            this.dispatchEvent(this.albumClickEvent);\r\n        });\r\n        this.update();\r\n    }\r\n\r\n    override updateWhenConnected() {\r\n        if(this.albumInfo.type == AlbumDataType.Loaded) {\r\n            this.shadow.getElementById(\"albumTitle\").textContent = this.albumInfo.albumInfo.name;\r\n        }\r\n    }\r\n\r\n    private onActiveTrackChanged() {\r\n\r\n    }\r\n}","import {EboPlayerDataType, View} from \"./view\";\r\n\r\nexport class ComponentViewAdapter extends View {\r\n    protected componentId: string;\r\n\r\n    constructor(id: string) {\r\n        super();\r\n        this.componentId = id;\r\n    }\r\n\r\n    bind(): void {\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [];\r\n    }\r\n\r\n}","import getState from \"../playerState\";\r\nimport {Model} from \"../model\";\r\nimport {EboPlayerDataType} from \"./view\";\r\nimport {ComponentViewAdapter} from \"./componentViewAdapter\";\r\nimport {EboBigTrackComp} from \"../components/eboBigTrackComp\";\r\nimport {AlbumData, AlbumNone, EboplayerEvents, TrackModel, TrackType} from \"../modelTypes\";\r\n\r\nexport class BigTrackViewUriAdapter extends ComponentViewAdapter {\r\n    private streamLines: string;\r\n    private track: TrackModel;\r\n    private uri: string;\r\n    private albumInfo: AlbumData;\r\n\r\n    constructor(id: string) {\r\n        super(id);\r\n        this.streamLines = \"\";\r\n        this.track = Model.NoTrack;\r\n        this.uri = \"\";\r\n        this.albumInfo = AlbumNone;\r\n    }\r\n\r\n    bind() {\r\n        super.bind();\r\n        getState().getModel().addEventListener(EboplayerEvents.activeStreamLinesChanged, () => {\r\n            this.onStreamLinesChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onActiveTrackChanged();\r\n        });\r\n    }\r\n\r\n    setUri(uri: string) {\r\n        this.uri = uri;\r\n        getState().getController().getTrackInfoCached(this.uri)\r\n            .then(async track => {\r\n                this.track = track;\r\n                this.albumInfo = AlbumNone;\r\n                this.setComponentData();\r\n                let comp = document.getElementById(this.componentId) as EboBigTrackComp;\r\n                this.albumInfo = await getState().getController().fetchAlbumDataForTrack(track);\r\n                comp.albumInfo = this.albumInfo;\r\n            });\r\n    }\r\n\r\n    protected onStreamLinesChanged() {\r\n        this.streamLines = \"\";\r\n        let linesObject = getState().getModel().getActiveStreamLines();\r\n        if(linesObject?.uri == this.uri)\r\n            this.streamLines = linesObject.active_titles?.join(\"<br/>\") ?? \"\";\r\n        document.getElementById(this.componentId).setAttribute(\"stream_lines\", this.streamLines);\r\n    }\r\n\r\n    protected onActiveTrackChanged() {\r\n        let streamTitles = getState().getModel().getActiveStreamLines();\r\n        if(streamTitles?.uri == this.uri)\r\n            this.streamLines = streamTitles.active_titles?.join(\"<br/>\") ?? \"\";\r\n        document.getElementById(this.componentId).setAttribute(\"stream_lines\", this.streamLines);\r\n        let comp = document.getElementById(this.componentId) as EboBigTrackComp;\r\n        comp.activeTrackUri = getState().getModel().getCurrentTrack();\r\n    }\r\n\r\n    protected setComponentData() {\r\n        if(this.track.type == TrackType.None)\r\n            return; // don't clear the screen as this is probably temporary and will cause a flicker.\r\n        let name = \"no current track\";\r\n        let info = \"\";\r\n        let position: string;\r\n        let button: string;\r\n        switch (this.track.type) {\r\n            case TrackType.Stream:\r\n                name = this.track.name;\r\n                position = \"100\";\r\n                button = \"false\";\r\n                break;\r\n            case TrackType.File:\r\n                name = this.track.title;\r\n                info = this.track.track.album.name;\r\n                position = \"60\"; //todo: just a test\r\n                button = \"true\";\r\n                let artists = this.track.track.artists.map(a => a.name).join(\", \");\r\n                let composers = this.track.track.composers?.map(c => c.name)?.join(\", \") ?? \"\";\r\n                if(artists)\r\n                    info += \"<br>\" + artists;\r\n                if(composers)\r\n                    info += \"<br>\" + composers;\r\n                break;\r\n        }\r\n        document.getElementById(this.componentId).setAttribute(\"name\", name);\r\n        document.getElementById(this.componentId).setAttribute(\"info\", info);\r\n        document.getElementById(this.componentId).setAttribute(\"position\", position);\r\n        document.getElementById(this.componentId).setAttribute(\"button\", button);\r\n        this.onStreamLinesChanged();\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.TrackList, EboPlayerDataType.StreamLines, ...super.getRequiredDataTypes()];\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {Model} from \"../model\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {ComponentViewAdapter} from \"./componentViewAdapter\";\r\nimport { BigTrackViewUriAdapter } from \"./bigTrackViewUriAdapter\";\r\nimport {EboplayerEvents, TrackModel, TrackType} from \"../modelTypes\";\r\n\r\nexport class BigTrackViewCurrentOrSelectedAdapter extends BigTrackViewUriAdapter {\r\n    constructor(id: string) {\r\n        super(id);\r\n    }\r\n\r\n    bind() {\r\n        super.bind();\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, async () => {\r\n            this.onCurrentOrSelectedChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, async () => {\r\n            this.onCurrentOrSelectedChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.activeStreamLinesChanged, () => {\r\n            this.onStreamLinesChanged();\r\n        });\r\n    }\r\n\r\n    private onCurrentOrSelectedChanged() {\r\n        let currentTrackUri = getState().getModel().getCurrentTrack();\r\n        let selectedTrackUri: string = getState().getModel().getSelectedTrack();\r\n        this.setUri(selectedTrackUri ?? currentTrackUri);\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.CurrentTrack, EboPlayerDataType.TrackList, ...super.getRequiredDataTypes()];\r\n    }\r\n\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {AlbumData, AlbumDataType, AlbumNone} from \"../modelTypes\";\r\n\r\nexport class EboAlbumTracksComp extends EboComponent {\r\n    set activeTrackUri(value: string | null) {\r\n        this._activeTrackUri = value;\r\n        this.highLightActiveTrack();\r\n    }\r\n    get albumInfo(): AlbumData {\r\n        return this._albumInfo;\r\n    }\r\n\r\n    set albumInfo(value: AlbumData) {\r\n        this._albumInfo = value;\r\n        this.render();\r\n    }\r\n\r\n    private _activeTrackUri: string | null = null;\r\n\r\n    static readonly tagName=  \"ebo-album-tracks-view\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"img\",\r\n    ];\r\n    private _albumInfo: AlbumData;\r\n\r\n\r\n    constructor() {\r\n        super(EboAlbumTracksComp.styleText, EboAlbumTracksComp.htmlText);\r\n\r\n        this.albumInfo = AlbumNone;\r\n        this.render();\r\n    }\r\n\r\n    static styleText = `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                    text-align: start;\r\n                } \r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    height: 100%;\r\n                    width: 100%;\r\n                }\r\n                .info {\r\n                    font-size: .7em;\r\n                }\r\n                #tableScroller {\r\n                    overflow: scroll;\r\n                    scrollbar-width: none;\r\n                    height: 100%;    \r\n                }\r\n                #tracksTable {\r\n                    margin-left: 1em;\r\n                    border-collapse: collapse;\r\n                    tr {\r\n                        border-bottom: 1px solid #ffffff80;\r\n                    }\r\n                }\r\n            </style>\r\n        `;\r\n        static htmlText = `\r\n            <div id=\"wrapper\">\r\n                <div id=\"tableScroller\">\r\n                    <table id=\"tracksTable\">\r\n                        <tbody>\r\n                        </tbody>                \r\n                    </table>\r\n                </div>          \r\n            </div>        \r\n        `;\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        this.render();\r\n        }\r\n\r\n    renderPrepared() {\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        this.shadow.appendChild(this.divTemplate.content.cloneNode(true));\r\n        this.renderTrackList();\r\n    }\r\n\r\n    renderTrackList() {\r\n        let tbody = (this.shadow.getElementById(\"tracksTable\") as HTMLTableElement).tBodies[0];\r\n        tbody.innerHTML  = \"\";\r\n        switch (this.albumInfo?.type) {\r\n            case AlbumDataType.Loaded:\r\n                this.albumInfo.tracks.forEach(track => {\r\n                    let tr = tbody.appendChild(document.createElement(\"tr\"));\r\n                    let td = tr.appendChild(document.createElement(\"td\"));\r\n                    tr.dataset.uri = track.uri;\r\n                    td.innerText = track.name;\r\n                });\r\n                break;\r\n            case AlbumDataType.StreamLinesLoaded:\r\n                this.albumInfo.lines.forEach(lineGroup => {\r\n                    let tr = tbody.appendChild(document.createElement(\"tr\"));\r\n                    let td = tr.appendChild(document.createElement(\"td\"));\r\n                    td.innerHTML = lineGroup.join(\"<br>\");\r\n                    td.classList.add(\"selectable\");\r\n                });\r\n                break;\r\n        }\r\n        this.highLightActiveTrack();\r\n    }\r\n\r\n    private highLightActiveTrack() {\r\n        if(!this._activeTrackUri)\r\n            return;\r\n        let tr = this.shadow.querySelector(`tr[data-uri=\"${this._activeTrackUri}\"]`) as HTMLTableRowElement;\r\n        if(tr) {\r\n            tr.classList.add(\"current\", \"textGlow\");\r\n        }\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport EboBrowseComp from \"../components/eboBrowseComp\";\r\n\r\nimport {EboplayerEvents, Views} from \"../modelTypes\";\r\nimport {EboBigAlbumComp} from \"../components/eboBigAlbumComp\";\r\n\r\nexport class MainView extends View {\r\n    bind() {\r\n        document.getElementById(\"headerSearchBtn\").addEventListener(\"click\", () => {\r\n            this.onBrowseButtonClick();\r\n        });\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.addEventListener(\"browseFilterChanged\", (ev) => {\r\n            getState().getController().setAndSaveBrowseFilter(browseComp.browseFilter);\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.refsFiltered, () => {\r\n            this.onRefsFiltered();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.breadCrumbsChanged, () => {\r\n            this.onBreadCrumbsChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.browseFilterChanged, () => {\r\n            this.onBrowseFilterChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.selectedTrackChanged, () => {\r\n            this.onSelectedTrackChanged();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.viewChanged, () => {\r\n            this.setCurrentView();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.albumToViewChanged, () => {\r\n            this.onAlbumToViewChanged();\r\n        });\r\n        let currentTrackBigViewComp = document.getElementById(\"currentTrackBigView\") as EboBrowseComp;\r\n        currentTrackBigViewComp.addEventListener(\"albumClick\", async (e) => {\r\n            this.onAlbumClick();\r\n        });\r\n\r\n    }\r\n\r\n    private onRefsFiltered() {\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.renderResults();\r\n    }\r\n\r\n    private onBreadCrumbsChanged() {\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.renderBreadCrumbs();\r\n    }\r\n\r\n    private onBrowseFilterChanged() {\r\n        let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n        browseComp.browseFilter = getState().getModel().getCurrentBrowseFilter();\r\n    }\r\n\r\n    private onBrowseButtonClick() {\r\n        let browseBtn = document.getElementById(\"headerSearchBtn\");\r\n        switch (browseBtn.dataset.goto) {\r\n            case Views.Browse:\r\n                getState().getController().setView(Views.Browse);\r\n                break;\r\n            case Views.NowPlaying:\r\n                getState().getController().setView(Views.NowPlaying);\r\n                break;\r\n            case Views.Album:\r\n                getState().getController().setView(Views.Album);\r\n                break;\r\n        }\r\n    }\r\n\r\n    setCurrentView() {\r\n        let view = getState().getModel().getView();\r\n        this.showView(view);\r\n    }\r\n\r\n    showView(view: Views) {\r\n        let browseBtn = document.getElementById(\"headerSearchBtn\");\r\n        let layout = document.getElementById(\"layout\");\r\n        layout.classList.remove(\"browse\", \"bigAlbum\", \"bigTrack\");\r\n        switch (view) {\r\n            case Views.Browse:\r\n                layout.classList.add(\"browse\");\r\n                location.hash = Views.Browse;\r\n                browseBtn.dataset.goto = Views.NowPlaying;\r\n                browseBtn.title = \"Now playing\";\r\n                let browseComp = document.getElementById(\"browseView\") as EboBrowseComp;\r\n                browseComp.browseFilter = getState().getModel().getCurrentBrowseFilter(); //todo: already set in controller?\r\n                browseComp.setFocusAndSelect();\r\n                break;\r\n            case Views.NowPlaying:\r\n                layout.classList.add(\"bigTrack\");\r\n                location.hash = \"\"; //default = now playing\r\n                browseBtn.dataset.goto = Views.Browse;\r\n                browseBtn.title = \"Search\";\r\n                break;\r\n            case Views.Album:\r\n                layout.classList.add(\"bigAlbum\");\r\n                location.hash = Views.Album;\r\n                browseBtn.dataset.goto = Views.NowPlaying;\r\n                browseBtn.title = \"Now playing\";\r\n        }\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.TrackList, EboPlayerDataType.StreamLines];\r\n    }\r\n\r\n    private onAlbumClick() {\r\n        this.showView(Views.Album);\r\n    }\r\n\r\n    private async onSelectedTrackChanged() {\r\n        let uri = getState().getModel().getSelectedTrack();\r\n        getState().getController().getTrackInfoCached(uri)\r\n            .then(async track => {\r\n                let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n                albumComp.albumInfo = await getState().getController().fetchAlbumDataForTrack(track);\r\n            });\r\n    }\r\n\r\n    private async onAlbumToViewChanged() {\r\n        let albumComp = document.getElementById(\"bigAlbumView\") as EboBigAlbumComp;\r\n        albumComp.albumInfo = await getState().getController().fetchAlbumInfo(getState().getModel().getAlbumToView());\r\n    }\r\n}\r\n\r\n","import {EboComponent} from \"./EboComponent\";\r\nimport getState from \"../playerState\";\r\nimport {EboButton, PressedChangeEvent} from \"./eboButton\";\r\n\r\nimport {BreadCrumbBrowseFilter, BreadCrumbRef, BrowseFilter, EboplayerEvents, FilterBreadCrumbType} from \"../modelTypes\";\r\n\r\nclass EboBrowseComp extends EboComponent {\r\n    get browseFilter(): BrowseFilter {\r\n        return this._browseFilter;\r\n    }\r\n    set browseFilter(value: BrowseFilter) {\r\n        if(JSON.stringify(this._browseFilter) == JSON.stringify(value))\r\n            return;\r\n        this._browseFilter = value;\r\n        this.render();\r\n    }\r\n\r\n    private _browseFilter: BrowseFilter;\r\n    static readonly tagName=  \"ebo-browse-view\";\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [];\r\n\r\n    private readonly browseFilterChangedEvent: CustomEvent<unknown>;\r\n\r\n    static styleText= `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                } \r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    width: 100%;\r\n                    height: 100%;\r\n                }\r\n                #filterButtons {\r\n                    margin-top: .3em;\r\n                    display: flex;\r\n                    flex-direction: row;\r\n                }\r\n                #searchBox {\r\n                    display: flex;\r\n                    flex-direction: row;\r\n                    border-bottom: 1px solid #ffffff80;\r\n                    & input {\r\n                        flex-grow: 1;\r\n                        background-color: transparent;\r\n                        color: white;\r\n                        border: none;\r\n                        &:focus {\r\n                            outline: none;\r\n                        }\r\n                    }\r\n                }\r\n                .filterButton {\r\n                    width: 2em;\r\n                    height: 2em;\r\n                    object-fit: contain;\r\n                    margin-right: .5em;\r\n                }\r\n                #searchResultsTable {\r\n                    width: 100%;\r\n                    border-collapse: collapse;\r\n                }\r\n                #tableWrapper {\r\n                    height: 100%;\r\n                    width: 100%;\r\n                    overflow: scroll;\r\n                    scrollbar-width: none;\r\n                    td {\r\n                        padding-top: .2em;\r\n                        padding-bottom: .2em;\r\n                    }\r\n                }\r\n                #searchResults {\r\n                    height: 100%;\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                }\r\n\r\n            </style>\r\n        `;\r\n\r\n    // noinspection HtmlUnknownTarget\r\n    static htmlText = `\r\n<div id=\"wrapper\">\r\n    <div id=\"searchBox\">\r\n        <button id=\"headerSearchBtn\"><img src=\"images/icons/Magnifier.svg\" alt=\"\" class=\"filterButton whiteIconFilter\"></button>\r\n        <input id=\"searchText\" type=\"text\" autofocus>\r\n    </div>\r\n    <div id=\"filterButtons\">\r\n        <ebo-button id=\"filterAlbum\" img=\"images/icons/Album.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n        <ebo-button id=\"filterTrack\" img=\"images/icons/Track.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n        <ebo-button id=\"filterRadio\" img=\"images/icons/Radio.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n        <ebo-button id=\"filterArtist\" img=\"images/icons/Artist.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n        <ebo-button id=\"filterPlaylist\" img=\"images/icons/Playlist.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n        <ebo-button id=\"filterGenre\" img=\"images/icons/Genre.svg\" class=\"filterButton whiteIconFilter\"></ebo-button>\r\n        <button> ALL </button>\r\n        <button> &nbsp;&nbsp;(i) </button>\r\n    </div>\r\n    <div id=\"breacCrumbs\"></div>\r\n    <div id=\"searchResults\">\r\n        <div id=\"searchInfo\">\r\n        </div>  \r\n        <div id=\"tableWrapper\" class=\"\">\r\n            <table id=\"searchResultsTable\">\r\n                <colgroup>\r\n                    <col span=\"1\" style=\"width: auto;\">\r\n                    <col span=\"1\" style=\"width: 1em;\">\r\n                </colgroup>\r\n                <tbody></tbody>\r\n            </table>\r\n        </div>\r\n    </div>\r\n</div>        \r\n        `;\r\n\r\n    constructor() {\r\n        super(EboBrowseComp.styleText, EboBrowseComp.htmlText);\r\n        this.browseFilterChangedEvent = new CustomEvent(\"browseFilterChanged\", {\r\n            bubbles: true,\r\n            cancelable: false,\r\n            composed: true, //needed to 'break' out of the shadow.\r\n            detail: \"todo\"\r\n        });\r\n        this._browseFilter = new BrowseFilter();\r\n        this.render();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"stream_lines\":\r\n            case \"extra\":\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"enabled\":\r\n            case \"show_back\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.render();\r\n        }\r\n\r\n    onConnected() {\r\n    }\r\n\r\n    setFocusAndSelect() {\r\n        let searchText = this.shadow.getElementById(\"searchText\") as HTMLInputElement;\r\n        searchText.focus();\r\n        searchText.select();\r\n    }\r\n\r\n    renderPrepared() {\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        this.shadow.appendChild(fragment);\r\n        this.shadow.getElementById(\"headerSearchBtn\").addEventListener(\"click\", async (ev) => {\r\n            //todo: is this button even needed?\r\n        });\r\n        this.renderBrowseFilter();\r\n        this.renderBreadCrumbs();\r\n        this.renderResults();\r\n        this.update();\r\n    }\r\n\r\n    private renderBrowseFilter() {\r\n        let inputElement = this.shadow.getElementById(\"searchText\") as HTMLInputElement;\r\n        inputElement.addEventListener(\"keyup\", (ev: KeyboardEvent) => {\r\n            this._browseFilter.searchText = inputElement.value;\r\n            this.dispatchEvent(this.browseFilterChangedEvent);\r\n        });\r\n        this.shadow.querySelectorAll(\"ebo-button\")\r\n            .forEach(btn => {\r\n                btn.addEventListener(\"pressedChange\", async (ev: PressedChangeEvent) => {\r\n                    this.onFilterButtonPress(ev);\r\n                });\r\n                btn.addEventListener(EboplayerEvents.longPress, (ev) => {\r\n                    this.onFilterButtonLongPress(ev);\r\n                });\r\n                btn.addEventListener(\"dblclick\", (ev) => {\r\n                    this.onFilterButtonDoubleClick(ev);\r\n                })\r\n            });\r\n    }\r\n\r\n    private onFilterButtonLongPress(ev: Event) {\r\n        this.setSingleButton(ev);\r\n    }\r\n\r\n    private onFilterButtonDoubleClick(ev: Event) {\r\n        this.setSingleButton(ev);\r\n    }\r\n\r\n    private setSingleButton(ev: Event) {\r\n        this.clearFilterButtons();\r\n        this.toggleFilterButton(ev.target as EboButton);\r\n        this.update();\r\n    }\r\n\r\n    private clearFilterButtons() {\r\n        this.browseFilter.genre = false;\r\n        this.browseFilter.radio = false;\r\n        this.browseFilter.playlist = false;\r\n        this.browseFilter.album = false;\r\n        this.browseFilter.track = false;\r\n        this.browseFilter.artist = false;\r\n    }\r\n\r\n    private onFilterButtonPress(ev: PressedChangeEvent) {\r\n        let btn: EboButton = ev.target as EboButton;\r\n        this.toggleFilterButton(btn);\r\n    }\r\n\r\n    private toggleFilterButton(btn: EboButton) {\r\n        let propName = btn.id.replace(\"filter\", \"\");\r\n        propName = propName.charAt(0).toLowerCase() + propName.slice(1);\r\n        this.browseFilter[propName] = !this.browseFilter[propName];\r\n        this.dispatchEvent(this.browseFilterChangedEvent);\r\n    }\r\n\r\n    updateWhenConnected() {\r\n        this.shadow.querySelectorAll(\"ebo-button\")\r\n            .forEach(btn =>\r\n                this.updateFilterButton(btn));\r\n        let inputElement = this.shadow.getElementById(\"searchText\") as HTMLInputElement;\r\n        inputElement.value = this._browseFilter.searchText;\r\n    }\r\n\r\n    private updateFilterButton(btn: Element) {\r\n        if (btn.id.startsWith(\"filter\")) {\r\n            let propName = btn.id\r\n                    .replace(\"filter\", \"\").charAt(0).toLowerCase()\r\n                + btn.id.replace(\"filter\", \"\").slice(1);\r\n            btn.setAttribute(\"pressed\", this._browseFilter[propName].toString());\r\n        }\r\n    }\r\n\r\n    setSearchInfo(text: string) {\r\n        let searchInfo = this.shadow.getElementById(\"searchInfo\");\r\n        searchInfo.innerHTML = text;\r\n    }\r\n\r\n    renderBreadCrumbs() {\r\n        let breadCrumbsDiv = this.shadow.getElementById(\"breacCrumbs\");\r\n        breadCrumbsDiv.innerHTML = \" > \" + (getState()?.getModel()?.getBreadCrumbs()?.list() ?? [])\r\n            .map(crumb => this.renderBreadcrumb(crumb))\r\n            .join(\" > \");\r\n\r\n        breadCrumbsDiv.querySelectorAll(\"button\").forEach(btn => {\r\n            btn.addEventListener(\"click\", (ev)  => {\r\n                this.onBreadCrumbClicked(ev);\r\n            });\r\n        })\r\n    }\r\n\r\n    private renderBreadcrumb(crumb: FilterBreadCrumbType) {\r\n        if(crumb instanceof BreadCrumbRef)\r\n            return `<button data-id=\"${crumb.id}\" class=\"uri\">${crumb.label}</button>`; //todo: have the type of uri and add a little icon?\r\n        else if(crumb instanceof BreadCrumbBrowseFilter)\r\n            return `<button data-id=\"${crumb.id}\" class=\"filter\">\"${crumb.label}\"</button>`;\r\n        //todo: click event.\r\n    }\r\n\r\n    renderResults() {\r\n        this.setSearchInfo(\"\");\r\n\r\n        let table = this.shadow.getElementById(\"searchResultsTable\") as HTMLTableElement;\r\n        let body = table.tBodies[0];\r\n        body.innerHTML = \"\";\r\n\r\n        let results = getState()?.getModel()?.getCurrentSearchResults() ?? []; //todo: direct reference to model in component. Make searchResults a property.\r\n        if(results?.length == 0)\r\n            return;\r\n\r\n\r\n        let resultsHtml = results\r\n            .map(result => {\r\n                let refType = result.ref.type as string;\r\n                if(refType == \"directory\") {\r\n                    if(result.ref.uri.includes(\"local:directory?genre=\"))\r\n                        refType = \"genre\";\r\n                }\r\n                return `\r\n                    <tr data-uri=\"${result.ref.uri}\" data-type=\"${refType}\">\r\n                    <td>${result.ref.name}</td>\r\n                    <td>...</td>\r\n                    </tr>`;\r\n            })\r\n            .join(\"\\n\");\r\n        body.innerHTML = resultsHtml;\r\n        body.querySelectorAll(\"tr\").forEach(tr => {\r\n            tr.addEventListener(\"dblclick\", ev => {this.onRowDoubleClicked(ev).then(r => {})});\r\n            tr.addEventListener(\"click\", ev => {this.onRowClicked(ev)});\r\n        });\r\n\r\n    }\r\n\r\n    private onRowClicked(ev: MouseEvent) {\r\n        let row = ev.currentTarget as HTMLTableRowElement;\r\n        getState().getController().diveIntoBrowseResult(row.cells[0].innerText, row.dataset.uri, row.dataset.type);\r\n    }\r\n\r\n    private async onRowDoubleClicked(ev: MouseEvent) {\r\n        let row = ev.currentTarget as HTMLTableRowElement;\r\n        await getState().getController().clearListAndPlay(row.dataset.uri);\r\n    }\r\n\r\n\r\n    private onBreadCrumbClicked(ev: MouseEvent) {\r\n        let btn = ev.currentTarget as HTMLButtonElement;\r\n        getState().getController().resetToBreadCrumb(parseInt(btn.dataset.id)); //todo rename to breadCrumbId.\r\n    }\r\n\r\n}\r\n\r\nexport default EboBrowseComp\r\n","const TIME_OUT_TIME = 500;\r\n\r\nexport class MouseTimer<Source> {\r\n    private activeTimer: number;\r\n    private source: Source;\r\n    private mouseUpCount = 0;\r\n    private isMouseDown = false;\r\n\r\n    private readonly onClick: (source: Source) => void = undefined;\r\n    private readonly onTimeOut: (source: Source) => void = undefined;\r\n    private readonly onMultiClick: (source: Source, clickCount: number) => void = undefined;\r\n\r\n    constructor(source: Source,\r\n                onClick: (source: Source) => void = undefined,\r\n                onMultiClick: (source: Source, clickCount: number) => void = undefined,\r\n                onTimeOut: (source: Source) => void = undefined\r\n    ) {\r\n        this.source = source;\r\n        this.onClick = onClick;\r\n        this.onMultiClick = onMultiClick;\r\n        this.onTimeOut = onTimeOut;\r\n    }\r\n\r\n    onMouseDown = (ev: MouseEvent) => {\r\n        this.isMouseDown = true;\r\n        if(this.activeTimer)\r\n            return;\r\n        this.startPressTimer(ev, () => {\r\n            this.doTimeOut();\r\n        });\r\n    };\r\n\r\n    onMouseUp = (ev: MouseEvent) => {\r\n        this.isMouseDown = false;\r\n        if(!this.activeTimer)\r\n            return;\r\n        this.mouseUpCount++;\r\n        if(this.mouseUpCount > 1) {\r\n            this.onMultiClick?.(this.source, this.mouseUpCount);\r\n            return;\r\n        }\r\n        this.onClick?.(this.source);\r\n    };\r\n\r\n    onMouseLeave = (ev: MouseEvent) => {\r\n        this.cancelPressTimer();\r\n    }\r\n\r\n    doTimeOut() {\r\n        this.cancelPressTimer();\r\n        if(!this.isMouseDown)\r\n            return;\r\n        this.onTimeOut?.(this.source);\r\n    }\r\n\r\n    private cancelPressTimer() {\r\n        if(this.activeTimer)\r\n            clearTimeout(this.activeTimer);\r\n        this.activeTimer = undefined;\r\n    }\r\n\r\n    private startPressTimer(ev: MouseEvent, onTimeOutCallback: (ev: MouseEvent) => void) {\r\n        this.mouseUpCount = 0;\r\n        this.activeTimer = window.setTimeout(() => { //use `window.` to avoid conflict with nodejs version of setTimeout.\r\n            if(this.activeTimer)\r\n                onTimeOutCallback(ev);\r\n            this.cancelPressTimer();\r\n        }, TIME_OUT_TIME);\r\n    }\r\n\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {EboplayerEvents} from \"../modelTypes\";\r\nimport {MouseTimer} from \"../MouseTimer\";\r\n\r\nexport class PressedChangeEvent extends Event {\r\n    private _pressed: boolean;\r\n\r\n    constructor(pressed: boolean) {\r\n        super(\"pressedChange\");\r\n        this._pressed = pressed;\r\n    }\r\n\r\n    get pressed() {\r\n        return this._pressed;\r\n    }\r\n}\r\n\r\nexport class EboButton extends EboComponent {\r\n    static readonly tagName=  \"ebo-button\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"toggle\", \"img\", \"img_pressed\", \"pressed\", \"opacity_off\", \"click\"];\r\n    private pressed: boolean = false;\r\n    private img: string;\r\n    private imgPressed: string;\r\n    private opacityOff: number = 0.5;\r\n    private pressTimer: MouseTimer<EboButton>;\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n            img {\r\n                width: 100%;\r\n                opacity: 0.5;\r\n                &.pressed { \r\n                    opacity: 1; \r\n                }\r\n            }\r\n        </style>\r\n    `;\r\n    //todo: make a html (or style) template literal function to inject opacity and such.\r\n    // > This function does NOT return a string, but the list of string fragments and placeholders.\r\n    // > The template is rendered later with `this` as the context.\r\n\r\n    static htmlText = `\r\n        <button>\r\n            <img id=\"img\" src=\"images/default_cover.png\" alt=\"Button image\">\r\n        </button>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboButton.styleText, EboButton.htmlText);\r\n        this.render();\r\n        this.pressTimer = new MouseTimer<EboButton>(\r\n            this,\r\n            (source) => this.onClick(source),\r\n            (source, clickCount) => this.onMultiClick(source, clickCount),\r\n            (source) => this.onFilterButtonTimeOut(source)\r\n        );\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"pressed\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.render();\r\n        }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n    }\r\n\r\n    renderPrepared() {\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        this.shadow.appendChild(fragment);\r\n        let imgTag = this.shadow.getElementById(\"img\") as HTMLImageElement;\r\n        this.setClassFromBoolAttribute(\"pressed\", imgTag);\r\n        imgTag.src = this.img ?? \"\";\r\n        let button = this.shadow.querySelector(\"button\");\r\n        button.addEventListener(\"mousedown\", (ev) => {\r\n            this.pressTimer.onMouseDown(ev);\r\n        });\r\n        button.addEventListener(\"mouseup\", (ev) => {\r\n            this.pressTimer.onMouseUp(ev);\r\n        });\r\n        button.addEventListener(\"mouseleave\", (ev) => {\r\n            this.pressTimer.onMouseLeave(ev);\r\n        });\r\n    }\r\n\r\n    private onClick(eboButton: EboButton) {\r\n        let button = this.shadow.querySelector(\"button\");\r\n        this.pressed = !this.pressed;\r\n        this.setClassFromBoolAttribute(\"pressed\", button);\r\n        this.setAttribute(\"pressed\", this.pressed.toString());\r\n        let event = new PressedChangeEvent(this.pressed);\r\n        this.dispatchEvent(event);\r\n    }\r\n\r\n    onFilterButtonTimeOut(source: EboButton) {\r\n        this.dispatchEvent(new Event(EboplayerEvents.longPress, {bubbles: true, composed: true}));\r\n    }\r\n\r\n    setClassFromBoolAttribute(attName: string, el: HTMLElement) {\r\n        if (this[attName] == true)\r\n            el.classList.add(attName);\r\n        else\r\n            el.classList.remove(attName);\r\n    }\r\n\r\n    private onMultiClick(eboButton: EboButton, clickCount: number) {\r\n        this.dispatchEvent(new Event(\"dblclick\", {bubbles: true, composed: true}));\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {EboAlbumTracksComp} from \"./eboAlbumTracksComp\";\r\nimport {AlbumData, AlbumDataType, AlbumNone} from \"../modelTypes\";\r\nimport getState from \"../playerState\";\r\n\r\nexport class EboBigAlbumComp extends EboComponent {\r\n    get activeTrackUri(): string | null {\r\n        return this._activeTrackUri;\r\n    }\r\n    set activeTrackUri(value: string | null) {\r\n        this._activeTrackUri = value;\r\n        this.onActiveTrackChanged();\r\n    }\r\n    get albumInfo(): AlbumData {\r\n        return this._albumInfo;\r\n    }\r\n\r\n    set albumInfo(value: AlbumData) {\r\n        this._albumInfo = value;\r\n        this.render();\r\n    }\r\n\r\n    private _activeTrackUri: string | null = null;\r\n    static readonly tagName=  \"ebo-big-album-view\";\r\n    static progressBarAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"name\", \"extra\", \"img\", \"disabled\"\r\n    ];\r\n    private name: string = \"\";\r\n    private extra: string = \"\";\r\n    private img: string  = \"images/default_cover.png\";\r\n    private albumClickEvent: CustomEvent<unknown>;\r\n    private _albumInfo: AlbumData;\r\n\r\n    static styleText= `\r\n            <style>\r\n                :host { \r\n                    display: flex;\r\n                } \r\n                h3 {\r\n                    margin-block-start: .5em;\r\n                    margin-block-end: .5em;\r\n                }\r\n                .albumCoverContainer {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    align-content: center;\r\n                    overflow: hidden;\r\n                    flex-wrap: wrap;\r\n                }\r\n                img {\r\n                    width: 70%;\r\n                    height: 70%;\r\n                    object-fit: contain;\r\n                }\r\n                ebo-progressbar {\r\n                    margin-top: .5em;\r\n                }\r\n                #wrapper {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    height: 100%;\r\n                    width: 100%;\r\n                    #bottom {\r\n                        overflow: hidden;\r\n                    }\r\n                    #buttons {\r\n                        display: flex;\r\n                        flex-direction: row;\r\n                        margin-bottom: .5em;\r\n                    }\r\n                }\r\n                #wrapper.front {\r\n                    #back {\r\n                        display: none;\r\n                    }                \r\n                }\r\n                #wrapper.back {\r\n                    #front {\r\n                        position: absolute;\r\n                        display: none;\r\n                    }                \r\n                }\r\n                .info {\r\n                    font-size: .7em;\r\n                }\r\n                #albumTableWrapper {\r\n                    height: 100%;\r\n                }\r\n                ebo-album-tracks-view {\r\n                    height: 100%;\r\n                }\r\n            </style>\r\n        `;\r\n\r\n    // noinspection HtmlUnknownTarget\r\n    static htmlText = `\r\n            <div id=\"wrapper\" class=\"front\">\r\n                <div id=\"top\">\r\n                    <div class=\"albumCoverContainer\">\r\n                        <img id=\"img\" src=\"images/default_cover.png\" alt=\"Album cover\"/>\r\n                    </div>\r\n        \r\n                    <div id=\"info\">\r\n                        <h3 id=\"albumTitle\" class=\"selectable\"></h3>\r\n                        <h3 id=\"name\" class=\"selectable\"></h3>\r\n                        <div id=\"stream_lines\" class=\"selectable info\"></div>\r\n                        <div id=\"extra\" class=\"selectable info\"></div>\r\n                    </div>\r\n                    <div id=\"buttons\">\r\n                        <button id=\"btnPlay\" class=\"roundBorder\">Play</button>\r\n                        <button id=\"btnAdd\" class=\"roundBorder\">Add</button>\r\n                    </div>                \r\n                </div>\r\n                <div id=\"bottom\">\r\n                    <div id=\"albumTableWrapper\">\r\n                        <ebo-album-tracks-view img=\"images/default_cover.png\" ></ebo-album-tracks-view>\r\n                    </div>\r\n                </div>\r\n            </div>        \r\n        `;\r\n\r\n    constructor() {\r\n        super(EboBigAlbumComp.styleText, EboBigAlbumComp.htmlText);\r\n        this.albumInfo = AlbumNone;\r\n        this.render();\r\n        this.albumClickEvent = new CustomEvent(\"albumClick\", {\r\n            bubbles: true,\r\n            cancelable: false,\r\n            composed: true, //needed to 'break' out of the shadow.\r\n            detail: \"todo: tadaaa!\"\r\n        });\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        if(EboBigAlbumComp.progressBarAttributes.includes(name)) {\r\n            this[name] = newValue;\r\n            return;\r\n        }\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"extra\":\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n        }\r\n        this.render();\r\n        }\r\n\r\n    renderPrepared() {\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        [\"name\", \"extra\"].forEach(attName => {\r\n            fragment.getElementById(attName).innerHTML = this[attName];\r\n        });\r\n        //todo: image.\r\n        this.shadow.appendChild(fragment);\r\n        let tracksComp = this.shadow.querySelector(\"ebo-album-tracks-view\") as EboAlbumTracksComp;\r\n        tracksComp.albumInfo = this.albumInfo;\r\n        this.addShadowEventListener(\"btnPlay\", \"click\", (ev) => {\r\n            this.onBtnPlayClick();\r\n        });\r\n        this.addShadowEventListener(\"btnAdd\", \"click\", (ev) => {\r\n            this.onBtnAddClick();\r\n        });\r\n        this.update();\r\n    }\r\n\r\n    private onBtnPlayClick() {\r\n        if (this.albumInfo.type != AlbumDataType.Loaded)\r\n            return;\r\n        getState().getController().playAlbum(this.albumInfo.albumInfo.uri);\r\n    }\r\n\r\n    private onBtnAddClick() {\r\n        if (this.albumInfo.type != AlbumDataType.Loaded)\r\n            return;\r\n        getState().getController().addAlbum(this.albumInfo.albumInfo.uri);\r\n    }\r\n\r\n    override updateWhenConnected() {\r\n        if(this.albumInfo.type == AlbumDataType.Loaded) {\r\n            this.shadow.getElementById(\"albumTitle\").textContent = this.albumInfo.albumInfo.name;\r\n        }\r\n    }\r\n\r\n    private onActiveTrackChanged() {\r\n        let tracksComp = this.shadow.querySelector(\"ebo-album-tracks-view\") as EboAlbumTracksComp;\r\n        tracksComp.activeTrackUri = this.activeTrackUri;\r\n    }\r\n}","import {EboComponent} from \"./EboComponent\";\r\nimport {EboplayerEvents, TrackModel, TrackType} from \"../modelTypes\";\r\nimport {console_yellow, inverseQuadratic100, quadratic100} from \"../global\";\r\n\r\nexport class EboButtonBar extends EboComponent {\r\n    private _track: TrackModel;\r\n    get track(): TrackModel {\r\n        return this._track;\r\n    }\r\n    set track(value: TrackModel) {\r\n        this._track = value;\r\n        this.update();\r\n    }\r\n    static readonly tagName=  \"ebo-button-bar\";\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"playing\", \"img\", \"show_info\", \"volume\"];\r\n    private playing: boolean = false;\r\n    private show_info: boolean = false;\r\n    private img: string;\r\n    private isVolumeSliding: boolean = false;\r\n    private volume: number = 0;\r\n\r\n    // noinspection CssUnresolvedCustomProperty\r\n    static styleText = `\r\n        <style>\r\n            img {\r\n                width: 2em;\r\n                height: 2em;\r\n                margin-right: 1em;\r\n            }\r\n        \r\n            .playing {\r\n                background-color: rgba(184, 134, 11, 0.53);\r\n            }\r\n            #buttonBar  {\r\n                display: flex;\r\n                justify-content: center;\r\n                flex-wrap: wrap;\r\n                align-items: center;\r\n                align-content: center;\r\n            \r\n                & button {\r\n                    padding-left: .5ch;\r\n                    padding-right: .5ch;\r\n                }\r\n            }\r\n            #buttonBar {\r\n                display: flex;\r\n                justify-content: center;\r\n                align-items: center;\r\n            }\r\n            #volumeSlider {\r\n                width: 100px;\r\n            }\r\n            input[type='range'] {\r\n                & {\r\n                    margin: 10px 5px;\r\n                    height: 2px;\r\n                    background-color: gray;\r\n                    -webkit-appearance: none;\r\n                }\r\n            \r\n                &::-webkit-slider-thumb {\r\n                    padding: 0;\r\n            \r\n                    width: 7px;\r\n                    appearance: none;\r\n                    height: 7px;\r\n                    background: white;\r\n                    color: white;\r\n                    border-color: white;\r\n                    border-style: solid;\r\n                    border-width:7px;\r\n                    border-radius: 7px;\r\n                }\r\n            }\r\n            #wrapper {\r\n                width: 100%;\r\n                display: flex;\r\n                flex-direction: column;\r\n                justify-content: center;\r\n                align-items: center;\r\n                padding-top: .5em;\r\n                padding-bottom: .5em;\r\n            }\r\n            #title {\r\n                font-size: .7em;\r\n            }\r\n        </style>\r\n    `;\r\n    //todo: make a html (or style) template literal function to inject opacity and such.\r\n    // > This function does NOT return a string, but the list of string fragments and placeholders.\r\n    // > The template is rendered later with `this` as the context.\r\n\r\n    static htmlText = `\r\n        <div id=\"wrapper\">\r\n            <div id=\"info\">\r\n                <span id=\"title\">sdfsdf sdfsdf </span>\r\n            </div>\r\n            <div id=\"buttonBar\">\r\n                <img id=\"buttonBarImg\" src=\"images/default_cover.png\" alt=\"Album cover\"/>\r\n                <div id=\"buttonBar\">\r\n                    <button id=\"btnPrev\" title=\"Previous\"><i class=\"fa fa-fast-backward\"></i></button>\r\n                    <button id=\"btnPlay\" title=\"Play\"><i class=\"fa fa-play\"></i></button>\r\n                    <button id=\"btnNext\" title=\"Next\"><i class=\"fa fa-fast-forward\"></i></button>\r\n                    <input id=\"volumeSlider\" data-highlight=\"true\" name=\"volumeSlider\" data-mini=\"true\" type=\"range\" min=\"0\" value=\"0\" max=\"100\"/>\r\n                    <button id=\"btnMore\" style=\"margin-left: 1em;\" title=\"Next\"><i class=\"fa fa-ellipsis-h\"></i></button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        `;\r\n\r\n    constructor() {\r\n        super(EboButtonBar.styleText, EboButtonBar.htmlText);\r\n        this.render();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"volume\":\r\n                this.volume = parseInt(newValue);\r\n                console_yellow(`eboButtonBarComp: attributeReallyChangedCallback: volume: ${this.volume}`);\r\n                break;\r\n            case \"playing\":\r\n            case \"show_info\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.update();\r\n        }\r\n\r\n    renderPrepared() {\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        this.shadow.appendChild(fragment);\r\n        let slider = this.shadow.getElementById(\"volumeSlider\") as HTMLInputElement;\r\n        slider.oninput = (ev) => {\r\n            this.isVolumeSliding = true;\r\n            this.volume = quadratic100(parseInt(slider.value));\r\n            console_yellow(`eboButtonBarComp: slider.oninput: slider.value: ${slider.value}, this.volume: ${this.volume}`);\r\n            this.dispatchEvent(new CustomEvent(EboplayerEvents.changingVolume, {bubbles: true, composed: true, detail: {volume: this.volume}}));\r\n        };\r\n        slider.onmousedown = slider.ontouchstart = () => { this.isVolumeSliding = true;};\r\n        slider.onmouseup = slider.ontouchend = () => { this.isVolumeSliding = false;};\r\n\r\n        let btnPlay = this.shadow.getElementById('btnPlay');\r\n        btnPlay.addEventListener(\"click\", (ev) => {\r\n            let title = btnPlay.querySelector('i').title;\r\n            let eventName: EboplayerEvents;\r\n            switch (title) {\r\n                case \"Play\": eventName = EboplayerEvents.playPressed; break;\r\n                case \"Pause\": eventName = EboplayerEvents.pausePressed; break;\r\n                case \"Stop\": eventName = EboplayerEvents.stopPressed; break;\r\n            }\r\n            this.dispatchEvent(new CustomEvent(eventName, {bubbles: true, composed: true}));\r\n        })\r\n    }\r\n\r\n    updateWhenConnected() {\r\n        if(!this.track)\r\n            return;\r\n        if(this.playing) {\r\n            if(this.track.type == TrackType.Stream)\r\n                this.setPlayButton('Stop', 'fa-stop');\r\n            else\r\n                this.setPlayButton('Pause', 'fa-pause');\r\n\r\n        } else {\r\n                this.setPlayButton('Play', 'fa-play');\r\n        }\r\n        let opacity = this.track.type == TrackType.File ? \"1\" : \"0.5\";\r\n        this.shadow.getElementById(\"btnNext\").style.opacity = opacity;\r\n        this.shadow.getElementById(\"btnPrev\").style.opacity = opacity;\r\n        let img = this.shadow.querySelector(\"img\") as HTMLElement;\r\n        img.style.visibility = this.show_info ? \"visible\" : \"hidden\";\r\n        if(!this.isVolumeSliding) {\r\n            let slider = this.shadow.getElementById(\"volumeSlider\") as HTMLInputElement;\r\n            let visualVolume = inverseQuadratic100(this.volume);\r\n            slider.value = Math.floor(visualVolume).toString();\r\n            console_yellow(`eboButtonBarComp.update: slider.value: ${slider.value}, this.volume: ${this.volume}`);\r\n        }\r\n        let wrapper = this.shadow.getElementById(\"wrapper\");\r\n        wrapper.classList.toggle(\"playing\", this.playing);\r\n        let titleEl = this.shadow.getElementById(\"title\");\r\n        titleEl.textContent = \"\";\r\n        if(this.show_info) {\r\n            let title: string;\r\n            if (this.track) {\r\n                if (this.track.type == TrackType.Stream)\r\n                    title = this.track.name;\r\n                else if (this.track.type == TrackType.File)\r\n                    title = this.track.title;\r\n                titleEl.textContent = title;\r\n            }\r\n        }\r\n    }\r\n\r\n    private setPlayButton(title: string, addClass: string) {\r\n        let btnPlayIcon = this.shadow.getElementById('btnPlay').querySelector('i');\r\n        btnPlayIcon.classList.remove(\"fa-play\", \"fa-pause\", \"fa-stop\" );\r\n        btnPlayIcon.classList.add(addClass);\r\n        btnPlayIcon.setAttribute('title', title);\r\n    }\r\n}","import {Mopidy, Options} from \"../js/mopidy\";\r\nimport {SyncedProgressTimer} from \"./synced_timer\";\r\nimport getState, {setState, State} from \"./playerState\";\r\nimport {Model} from \"./model\";\r\nimport {HeaderView} from \"./views/headerView\";\r\nimport {Controller} from \"./controller\";\r\nimport {ButtonBarView} from \"./views/buttonBarView\";\r\nimport {EboProgressBar} from \"./components/eboProgressBar\";\r\nimport {TimelineView} from \"./views/timelineView\";\r\nimport {EboBigTrackComp} from \"./components/eboBigTrackComp\";\r\nimport {BigTrackViewCurrentOrSelectedAdapter} from \"./views/bigTrackViewCurrentOrSelectedAdapter\";\r\nimport {EboAlbumTracksComp} from \"./components/eboAlbumTracksComp\";\r\nimport {EboComponent} from \"./components/EboComponent\";\r\nimport {MainView} from \"./views/mainView\";\r\nimport EboBrowseComp from \"./components/eboBrowseComp\";\r\nimport {EboButton} from \"./components/eboButton\";\r\nimport {getHostAndPort} from \"./global\";\r\nimport {JsonRpcController} from \"./jsonRpcController\";\r\nimport {EboBigAlbumComp} from \"./components/eboBigAlbumComp\";\r\nimport {EboButtonBar} from \"./components/eboButtonBarComp\";\r\nimport {Views} from \"./modelTypes\";\r\n\r\nexport function getWebSocketUrl() {\r\n    let webSocketUrl = document.body.dataset.websocketUrl;\r\n    if (webSocketUrl.startsWith(\"{{\"))\r\n        webSocketUrl = `ws://${getHostAndPort()}/mopidy/ws`;\r\n    return webSocketUrl;\r\n}\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\",function () {\r\n    Promise.all([\r\n        fetch(`${rootDir}css/global.css`).then(res => res.text()),\r\n        fetch(`${rootDir}vendors/font_awesome/css/font-awesome.css`).then(res => res.text()),\r\n    ])\r\n        .then(texts => {\r\n            EboComponent.setGlobalCss(texts);\r\n\r\n            EboComponent.define(EboProgressBar);\r\n            EboComponent.define(EboBigTrackComp);\r\n            EboComponent.define(EboAlbumTracksComp);\r\n            EboComponent.define(EboBrowseComp);\r\n            EboComponent.define(EboButton);\r\n            EboComponent.define(EboBigAlbumComp);\r\n            EboComponent.define(EboButtonBar);\r\n\r\n            setupStuff();\r\n        });\r\n});\r\n\r\nfunction setupStuff() {\r\n    let webSocketUrl = getWebSocketUrl();\r\n    let connectOptions: Options = {\r\n        webSocketUrl,\r\n        autoConnect: false //important: delay connection until all bindings, listeners and dependencies are setup.\r\n    };\r\n    let mopidy = new Mopidy(connectOptions);\r\n    let wsUrl = \"ws://192.168.1.111:6680/eboplayer2/ws/\"; //iris socket: ws://192.168.1.111:6680/iris/ws/\r\n    let eboWebSocketCtrl = new JsonRpcController(wsUrl);\r\n    let timer = new SyncedProgressTimer(8, mopidy);\r\n    let model = new Model();\r\n\r\n    let controller = new Controller(model, mopidy, eboWebSocketCtrl);\r\n\r\n    controller.initSocketevents();\r\n\r\n    let state = new State(mopidy, timer, model, controller);\r\n    setState(state);\r\n\r\n    let mainView = new MainView();\r\n    let headerView = new HeaderView();\r\n    let currentTrackView = new BigTrackViewCurrentOrSelectedAdapter(\"currentTrackBigView\");\r\n    let buttonBarView = new ButtonBarView(\"buttonBar\", mainView);\r\n    let historyView = new TimelineView();\r\n    getState().addViews(mainView, headerView, currentTrackView, buttonBarView, historyView);\r\n\r\n    if(location.hash == Views.Browse)\r\n        mainView.showView(Views.Browse);\r\n    else\r\n        mainView.showView(Views.NowPlaying);\r\n\r\n    mopidy.connect();\r\n    eboWebSocketCtrl.connect();\r\n}\r\n\r\nfunction updateDocumentTitle (headline) {\r\n    headline = headline || document.getElementById('contentHeadline').textContent;\r\n    document.title = headline + ' | ' + document.body.dataset.title;\r\n}\r\n\r\n//intellij live preview hack because they don't allow to set a root folder for the built-in server:\r\nlet rootDir = document.location.pathname.replace(\"index.html\", \"\");\r\n\r\n"],"mappings":"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"}