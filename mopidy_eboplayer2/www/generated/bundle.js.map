{"version":3,"file":"bundle.js","names":["state","state: State","state","history","getState","getState","getState","state","historyObject: Object","dict: LibraryDict","array: any[]","model: FileTrackModel","getState","position: string","button: string","getState","getState","history","getState","allLookups: Promise<void>[]","tr","connectOptions: Options","state"],"sources":["../js/mopidy.ts","../../../typescript/timer.ts","../../../typescript/synced_timer.ts","../../../typescript/playerState.ts","../../../typescript/model.ts","../../../typescript/views/dataRequester.ts","../../../typescript/views/view.ts","../../../typescript/views/headerView.ts","../../../typescript/process_ws.ts","../../../typescript/library.ts","../../../typescript/controls.ts","../../../typescript/functionsvars.ts","../../../scripts/commands.ts","../../../typescript/controller.ts","../../../typescript/views/bigTrackView.ts","../../../typescript/views/volumeView.ts","../../../typescript/views/buttonBarView.ts","../../../typescript/components/EboComponent.ts","../../../typescript/components/eboProgressBar.ts","../../../typescript/views/timelineView.ts","../../../typescript/components/eboBigTrackView.ts","../../../typescript/gui.ts"],"sourcesContent":["// Type definitions for js v1.2.0, Mopidy v3.0.2 WebSocket API\r\n\r\nexport interface Options {\r\n    /**\r\n     * URL used when creating new WebSocket objects.\r\n     *\r\n     * In a browser environment, it defaults to\r\n     * ws://${document.location.host}/mopidy/ws. If the current page is served\r\n     * over HTTPS, it defaults to using wss:// instead of ws://.\r\n     *\r\n     * In a non-browser environment, where document.location isn't available, it\r\n     * defaults to ws://localhost/mopidy/ws.\r\n     */\r\n    webSocketUrl: string;\r\n    /**\r\n     * Whether or not to connect to the WebSocket on instance creation. Defaults\r\n     * to true.\r\n     */\r\n    autoConnect?: boolean;\r\n    /**\r\n     * The minimum number of milliseconds to wait after a connection error before\r\n     * we try to reconnect. For every failed attempt, the backoff delay is doubled\r\n     * until it reaches backoffDelayMax. Defaults to 1000.\r\n     */\r\n    backoffDelayMin?: number;\r\n    /**\r\n     * The maximum number of milliseconds to wait after a connection error before\r\n     * we try to reconnect. Defaults to 64000.\r\n     */\r\n    backoffDelayMax?: number;\r\n    /**\r\n     * If set, this object will be used to log errors from Mopidy.js. This is\r\n     * mostly useful for testing Mopidy.js. Defaults to console.\r\n     */\r\n}\r\n\r\ntype URI = string;\r\n\r\ninterface StrictEvents extends core.CoreListener {\r\n    /**\r\n     * The events from Mopidy are also emitted under the aggregate event named\r\n     * event.\r\n     */\r\n    event: (args?: unknown) => void;\r\n\r\n    /**\r\n     * Client state\r\n     *\r\n     * You can get notified about when the js client is connected to the\r\n     * server and ready for method calls, when it's offline, and when it's\r\n     * trying to reconnect to the server by looking at the events\r\n     */\r\n    \"state:online\": () => void;\r\n    \"state:offline\": () => void;\r\n    reconnectionPending: ({ timeToAttempt }: { timeToAttempt: number }) => void;\r\n    reconnecting: () => void;\r\n    /**\r\n     * The client state events are also emitted under the aggregate event named\r\n     * state.\r\n     */\r\n    state: (args?: unknown) => void;\r\n\r\n    /**\r\n     * WebSocket events\r\n     *\r\n     * You can introspect what happens internally on the WebSocket by looking at\r\n     * the events.\r\n     *\r\n     * Of course, you can also do this using the web developer tools in any\r\n     * modern browser.\r\n     */\r\n    \"websocket:close\": any;\r\n    \"websocket:error\": any;\r\n    \"websocket:incomingMessage\": any;\r\n    \"websocket:open\": any;\r\n    \"websocket:outgoingMessage\": any;\r\n}\r\n\r\nexport namespace models {\r\n    type ModelType = \"album\" | \"artist\" | \"directory\" | \"playlist\" | \"track\";\r\n\r\n    export class TlTrack {\r\n        readonly tlid: number;\r\n        readonly track: Track;\r\n    }\r\n    export class Track {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly artists: Artist[];\r\n        readonly album: Album;\r\n        readonly composers: Artist[];\r\n        readonly performers: Artist[];\r\n        readonly genre: string;\r\n        readonly track_no: number;\r\n        readonly disc_no: number;\r\n        readonly date: string;\r\n        readonly length: number;\r\n        readonly bitrate: string;\r\n        readonly comment: string;\r\n        readonly musicbrainz_id: string;\r\n        readonly last_modified: number;\r\n    }\r\n    class SearchResult {\r\n        readonly uri: URI;\r\n        readonly tracks: Track[];\r\n        readonly artists: Artist[];\r\n        readonly albums: Album[];\r\n    }\r\n\r\n    class Artist {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly sortname: string;\r\n        readonly musicbrainz_id: string;\r\n    }\r\n\r\n    class Album {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly artists: Artist[];\r\n        readonly num_tracks: number;\r\n        readonly num_discs: number;\r\n        readonly date: string;\r\n        readonly musicbrainz_id: string;\r\n    }\r\n\r\n    class Image {\r\n        readonly uri: URI;\r\n        readonly width: number;\r\n        readonly height: number;\r\n    }\r\n\r\n    export class Playlist {\r\n        readonly uri: URI;\r\n        readonly name: string;\r\n        readonly tracks: Track[];\r\n        readonly last_modified: number;\r\n        readonly length: number;\r\n    }\r\n}\r\n\r\nexport namespace core {\r\n    export type PlaybackState = \"playing\" | \"paused\" | \"stopped\";\r\n    type QueryField =\r\n        | \"uri\"\r\n        | \"track_name\"\r\n        | \"album\"\r\n        | \"artist\"\r\n        | \"albumartist\"\r\n        | \"composer\"\r\n        | \"performer\"\r\n        | \"track_no\"\r\n        | \"genre\"\r\n        | \"date\"\r\n        | \"comment\"\r\n        | \"any\";\r\n    type Query = { [key in QueryField]?: string[] };\r\n\r\n    // ----------------- Events -----------------\r\n\r\n    /**\r\n     * Core events\r\n     *\r\n     * You can get events sent from the Mopidy server by looking at the events\r\n     * with the name prefix 'event:'\r\n     */\r\n    export interface CoreListener {\r\n        /**\r\n         * Called whenever the mute state is changed.\r\n         */\r\n        \"event:muteChanged\": ({\r\n                                  mute,\r\n                              }: {\r\n            /**\r\n             * the new mute state\r\n             */\r\n            mute: boolean;\r\n        }) => void;\r\n        \"event:optionsChanged\": () => void;\r\n        \"event:playbackStateChanged\": ({\r\n                                           old_state,\r\n                                           new_state,\r\n                                       }: {\r\n            old_state: PlaybackState;\r\n            new_state: PlaybackState;\r\n        }) => void;\r\n        \"event:playlistChanged\": ({\r\n                                      playlist,\r\n                                  }: {\r\n            playlist: models.Playlist;\r\n        }) => void;\r\n        \"event:playlistDeleted\": ({\r\n                                      /**\r\n                                       * the URI of the deleted playlist\r\n                                       */\r\n                                      uri,\r\n                                  }: {\r\n            uri: URI;\r\n        }) => void;\r\n        \"event:playlistsLoaded\": () => void;\r\n        /**\r\n         * Called whenever the time position changes by an unexpected amount, e.g.\r\n         * at seek to a new time position.\r\n         */\r\n        \"event:seeked\": ({\r\n                             /**\r\n                              * the position that was seeked to in milliseconds\r\n                              */\r\n                             time_position,\r\n                         }: {\r\n            time_position: number;\r\n        }) => void;\r\n        /**\r\n         * Called whenever the currently playing stream title changes.\r\n         */\r\n        \"event:streamTitleChanged\": ({\r\n                                         /**\r\n                                          * the new stream title\r\n                                          */\r\n                                         title,\r\n                                     }: {\r\n            title: string;\r\n        }) => void;\r\n\r\n        /**\r\n         * Called whenever playback of a track ends.\r\n         */\r\n        \"event:trackPlaybackEnded\": ({\r\n                                         /**\r\n                                          * the track that was played before playback stopped\r\n                                          */\r\n                                         tl_track,\r\n                                         /**\r\n                                          * the time position in milliseconds\r\n                                          */\r\n                                         time_position,\r\n                                     }: {\r\n            tl_track: models.TlTrack;\r\n            time_position: number;\r\n        }) => void;\r\n        /**\r\n         * Called whenever track playback is paused.\r\n         */\r\n        \"event:trackPlaybackPaused\": ({\r\n                                          /**\r\n                                           * the track that was playing when playback paused\r\n                                           */\r\n                                          tl_track,\r\n                                          /**\r\n                                           * the time position in milliseconds\r\n                                           */\r\n                                          time_position,\r\n                                      }: {\r\n            tl_track: models.TlTrack;\r\n            time_position: number;\r\n        }) => void;\r\n        /**\r\n         * Called whenever track playback is resumed.\r\n         */\r\n        \"event:trackPlaybackResumed\": ({\r\n                                           /**\r\n                                            * the track that was playing when playback resumed\r\n                                            */\r\n                                           tl_track,\r\n                                           /**\r\n                                            * the time position in milliseconds\r\n                                            */\r\n                                           time_position,\r\n                                       }: {\r\n            tl_track: models.TlTrack;\r\n            time_position: number;\r\n        }) => void;\r\n        /**\r\n         * Called whenever a new track starts playing.\r\n         */\r\n        \"event:trackPlaybackStarted\": ({\r\n                                           /**\r\n                                            * the track that just started playing\r\n                                            */\r\n                                           tl_track,\r\n                                       }: {\r\n            tl_track: models.TlTrack;\r\n        }) => void;\r\n        /**\r\n         * Called whenever the tracklist is changed.\r\n         */\r\n        \"event:tracklistChanged\": () => void;\r\n        /**\r\n         * Called whenever the volume is changed.\r\n         */\r\n        \"event:volumeChanged\": ({\r\n                                    /**\r\n                                     * the new volume in the range [0..100]\r\n                                     */\r\n                                    volume,\r\n                                }: {\r\n            volume: number;\r\n        }) => void;\r\n    }\r\n\r\n    // ----------------- CONTROLLERS -----------------\r\n\r\n    // https://docs.mopidy.com/en/latest/api/core/#tracklist-controller\r\n    interface TracklistController {\r\n        /**\r\n         * Add tracks to the tracklist.\r\n         *\r\n         * If `uris` is given instead of `tracks`, the URIs are looked up in the library\r\n         * and the resulting tracks are added to the tracklist.\r\n         *\r\n         * If `at_position` is given, the tracks are inserted at the given position in\r\n         * the tracklist. If `at_position` is not given, the tracks are appended to\r\n         * the end of the tracklist.\r\n         *\r\n         * Triggers the `mopidy.core.CoreListener.tracklist_changed()` event.\r\n         */\r\n        add({\r\n                tracks,\r\n                at_position,\r\n                uris,\r\n            }: {\r\n            /**\r\n             * The tracks to add\r\n             */\r\n            tracks?: models.Track[];\r\n            /**\r\n             * The position in tracklist to add tracks\r\n             */\r\n            at_position?: number;\r\n            /**\r\n             * list of URIs for tracks to add\r\n             */\r\n            uris?: string[];\r\n        }): Promise<models.TlTrack[]>;\r\n\r\n        /**\r\n         * Remove the matching tracks from the tracklist.\r\n         * Uses `filter()` to lookup the tracks to remove.\r\n         *\r\n         * Triggers the `mopidy.core.CoreListener.tracklist_changed()` event.\r\n         */\r\n        remove({\r\n                   criteria,\r\n               }: {\r\n            /**\r\n             * (dict, of (string, list) pairs) – one or more rules to match by\r\n             */\r\n            criteria: { [key: string]: string[] };\r\n        }): Promise<models.TlTrack[]>;\r\n\r\n        /**\r\n         * Clear the tracklist\r\n         *\r\n         * Triggers the `mopidy.core.CoreListener.tracklist_changed()` event.\r\n         */\r\n        clear(): Promise<void>;\r\n\r\n        /**\r\n         * Move the tracks in the slice `[start:end]` to `to_position`.\r\n         *\r\n         * Triggers the `mopidy.core.CoreListener.tracklist_changed()` event.\r\n         */\r\n        move({\r\n                 start,\r\n                 end,\r\n                 to_position,\r\n             }: {\r\n            /**\r\n             * position of first track to move\r\n             */\r\n            start: number;\r\n            /**\r\n             * position after last track to move\r\n             */\r\n            end: number;\r\n            /**\r\n             * new position for the tracks\r\n             */\r\n            to_position: number;\r\n        }): Promise<void>;\r\n\r\n        /**\r\n         * Shuffles the entire tracklist. If `start` and `end` is given\r\n         * only shuffles the slice `[start:end]`.\r\n         *\r\n         * Triggers the `mopidy.core.CoreListener.tracklist_changed()` event.\r\n         */\r\n        shuffle({\r\n                    start,\r\n                    end,\r\n                }: {\r\n            /**\r\n             * position of first track to shuffle\r\n             */\r\n            start?: number;\r\n            /**\r\n             * position after last track to shuffle\r\n             */\r\n            end?: number;\r\n        }): Promise<void>;\r\n\r\n        /**\r\n         * Get tracklist as list of `mopidy.models.TlTrack`\r\n         */\r\n        getTlTracks(): Promise<models.TlTrack[]>;\r\n\r\n        /**\r\n         * The position of the given track in the tracklist.\r\n         *\r\n         * If neither tl_track or tlid is given we return the index of the\r\n         * currently playing track.\r\n         */\r\n        index({\r\n                  tl_track,\r\n                  tlid,\r\n              }: {\r\n            /**\r\n             * The track to find the index of\r\n             */\r\n            tl_track?: models.TlTrack;\r\n            /**\r\n             * TLID of the track to find the index of\r\n             */\r\n            tlid?: number;\r\n        }): Promise<number | null>;\r\n\r\n        /**\r\n         * Get the tracklist version.\r\n         *\r\n         * Integer which is increased every time the tracklist is changed.\r\n         * Is not reset before Mopidy is restarted.\r\n         */\r\n        getVersion(): Promise<number>;\r\n\r\n        /**\r\n         * Get length of the tracklist\r\n         */\r\n        getLength(): Promise<number>;\r\n\r\n        /**\r\n         * Get tracklist as list of `mopidy.models.Track`\r\n         */\r\n        getTracks(): Promise<models.Track[]>;\r\n\r\n        /**\r\n         * Returns a slice of the tracklist, limited by the given start and end\r\n         * positions.\r\n         */\r\n        slice({\r\n                  start,\r\n                  end,\r\n              }: {\r\n            /**\r\n             * position of first track to include in slice\r\n             */\r\n            start: number;\r\n            /**\r\n             * position after last track to include in slice\r\n             */\r\n            end: number;\r\n        }): Promise<models.TlTrack[]>;\r\n\r\n        /**\r\n         *\r\n         * Filter the tracklist by the given criteria.\r\n         *\r\n         * Each rule in the criteria consists of a model field and a list of values to compare it against. If * the model field matches any of the values, it may be returned.\r\n         *\r\n         * Only tracks that match all the given criteria are returned.\r\n         */\r\n        filter({\r\n                   criteria,\r\n               }: {\r\n            /**\r\n             * (dict, of (string, list) pairs) – one or more rules to match by\r\n             */\r\n            criteria: { [key: string]: string[] };\r\n        }): Promise<models.TlTrack[]>;\r\n\r\n        // ----------------- FUTURE STATE -----------------\r\n\r\n        /**\r\n         * The TLID of the track that will be played after the current track.\r\n         *\r\n         * Not necessarily the same TLID as returned by `get_next_tlid()`.\r\n         */\r\n        getEotTlid(): Promise<number | null>;\r\n\r\n        /**\r\n         * The tlid of the track that will be played if calling `mopidy.core.PlaybackController.next()`.\r\n         *\r\n         * For normal playback this is the next track in the tracklist. If repeat is enabled the next\r\n         * track can loop around the tracklist. When random is enabled this should be a random track,\r\n         * all tracks should be played once before the tracklist repeats.\r\n         */\r\n        getNextTlid(): Promise<number | null>;\r\n\r\n        /**\r\n         * Returns the TLID of the track that will be played if calling\r\n         * `mopidy.core.PlaybackController.previous()`.\r\n         *\r\n         * For normal playback this is the previous track in the tracklist. If random and/or\r\n         * consume is enabled it should return the current track instead.\r\n         */\r\n        getPreviousTlid(): Promise<number | null>;\r\n\r\n        /**\r\n         * The track that will be played after the given track.\r\n         *\r\n         * Not necessarily the same track as `next_track()`.\r\n         */\r\n        eotTrack({\r\n                     tl_track,\r\n                 }: {\r\n            /**\r\n             * The reference track\r\n             */\r\n            tl_track?: models.TlTrack;\r\n        }): Promise<models.TlTrack | null>;\r\n\r\n        // ----------------- DEPRECATED -----------------\r\n\r\n        /**\r\n         * @deprecated Deprecated since version 3.0: Use `get_next_tlid()` instead.\r\n         */\r\n        nextTrack({\r\n                      tl_track,\r\n                  }: {\r\n            tl_track: models.TlTrack;\r\n        }): Promise<models.TlTrack | null>;\r\n\r\n        /**\r\n         * @deprecated Deprecated since version 3.0: Use `get_previous_tlid()` instead.\r\n         */\r\n        previousTrack({\r\n                          tl_track,\r\n                      }: {\r\n            tl_track: models.TlTrack;\r\n        }): Promise<models.TlTrack | null>;\r\n\r\n        // ----------------- OPTIONS -----------------\r\n\r\n        /**\r\n         * Get consume mode.\r\n         *\r\n         * True - Tracks are removed from the tracklist when they have been played.\r\n         * False - Tracks are not removed from the tracklist.\r\n         */\r\n        getConsume(): Promise<boolean>;\r\n\r\n        /**\r\n         * Set consume mode.\r\n         *\r\n         * True - Tracks are removed from the tracklist when they have been played.\r\n         * False - Tracks are not removed from the tracklist.\r\n         */\r\n        setConsume({ value }: { value: boolean }): Promise<void>;\r\n\r\n        /**\r\n         * Get random mode.\r\n         */\r\n        getRandom(): Promise<boolean>;\r\n\r\n        /**\r\n         * Set random mode.\r\n         *\r\n         * True - Tracks are selected at random from the tracklist.\r\n         * False - Tracks are played in the order of the tracklist.\r\n         */\r\n        setRandom({ value }: { value: boolean }): Promise<void>;\r\n\r\n        /**\r\n         * Get repeat mode.\r\n         */\r\n        getRepeat(): Promise<boolean>;\r\n\r\n        /**\r\n         * Set repeat mode.\r\n         *\r\n         * To repeat a single track, set both `repeat` and `single`.\r\n         */\r\n        setRepeat({ value }: { value: boolean }): Promise<void>;\r\n\r\n        /**\r\n         * Get single mode\r\n         */\r\n        getSingle(): Promise<boolean>;\r\n\r\n        /**\r\n         * Set single mode.\r\n         *\r\n         * True - Playback is stopped after current song, unless in repeat mode.\r\n         * False - Playback continues after current song.\r\n         */\r\n        setSingle({ value }: { value: boolean }): Promise<void>;\r\n    }\r\n\r\n    // https://docs.mopidy.com/en/latest/api/core/#playback-controller\r\n    interface PlaybackController {\r\n        /**\r\n         * Play the given track, or if the given `tl_track` and `tlid` is None,\r\n         * play the currently active track.\r\n         *\r\n         * Note that the track *must* already be in the tracklist.\r\n         */\r\n        play({\r\n                 track,\r\n                 tlid,\r\n             }: {\r\n            track?: models.TlTrack;\r\n            tlid?: number;\r\n        }): Promise<void>;\r\n\r\n        /**\r\n         * Change to the next track.\r\n         *\r\n         * The current playback state will be kept. If it was playing, playing will\r\n         * continue. If it was paused, it will still be paused, etc.\r\n         */\r\n        next(): Promise<void>;\r\n\r\n        /**\r\n         * Change to the previous track.\r\n         *\r\n         * The current playback state will be kept. If it was playing, playing will\r\n         * continue. If it was paused, it will still be paused, etc.\r\n         */\r\n        previous(): Promise<void>;\r\n\r\n        /**\r\n         * Stop playing.\r\n         */\r\n        stop(): Promise<void>;\r\n\r\n        /**\r\n         * Pause playback.\r\n         */\r\n        pause(): Promise<void>;\r\n\r\n        /**\r\n         * If paused, resume playing the current track.\r\n         */\r\n        resume(): Promise<void>;\r\n\r\n        /**\r\n         * Seeks to time position given in milliseconds.\r\n         */\r\n        seek({\r\n                 time_position,\r\n             }: {\r\n            /**\r\n             * time position in milliseconds\r\n             */\r\n            time_position: number;\r\n        }): Promise<boolean>;\r\n\r\n        // ----------------- CURRENT TRACK -----------------\r\n\r\n        /**\r\n         * Get the currently playing or selected track.\r\n         */\r\n        getCurrentTlTrack(): Promise<models.TlTrack | null>;\r\n\r\n        /**\r\n         * Get the currently playing or selected track.\r\n         *\r\n         * Extracted from `get_current_tl_track()` for convenience.\r\n         */\r\n        getCurrentTrack(): Promise<models.Track | null>;\r\n\r\n        /**\r\n         * Get the current stream title or None.\r\n         */\r\n        getStreamTitle(): Promise<string | null>;\r\n\r\n        /**\r\n         * Get time position in milliseconds.\r\n         */\r\n        getTimePosition(): Promise<number | null>;\r\n\r\n        // ----------------- PLAYBACK STATES -----------------\r\n\r\n        /**\r\n         * Get The playback state.\r\n         */\r\n        getState(): Promise<PlaybackState>;\r\n\r\n        /**\r\n         * Set the playback state. See:\r\n         *  https://docs.mopidy.com/en/latest/api/core/#mopidy.core.PlaybackController.set_state\r\n         * for possible states and transitions\r\n         */\r\n        setState({ new_state }: { new_state: PlaybackState }): Promise<void>;\r\n    }\r\n\r\n    // https://docs.mopidy.com/en/latest/api/core/#library-controller\r\n    interface LibraryController {\r\n        /**\r\n         * Browse directories and tracks at the given uri.\r\n         *\r\n         * uri is a string which represents some directory belonging to a backend.\r\n         * To get the intial root directories for backends pass None as the URI.\r\n         *\r\n         * returns a list of `mopidy.models.Ref` objects for the directories and\r\n         * tracks at the given uri.\r\n         *\r\n         * The Ref objects representing tracks keep the track's original URI. A\r\n         * matching pair of objects can look like this:\r\n         *\r\n         *    Track(uri='dummy:/foo.mp3', name='foo', artists=..., album=...)\r\n         *    Ref.track(uri='dummy:/foo.mp3', name='foo')\r\n         *\r\n         * The Ref objects representing directories have backend specific URIs.\r\n         * These are opaque values, so no one but the backend that created them\r\n         * should try and derive any meaning from them. The only valid exception to\r\n         * this is checking the scheme, as it is used to route browse requests to\r\n         * the correct backend.\r\n         *\r\n         * For example, the dummy library's /bar directory could be returned like\r\n         * this:\r\n         *\r\n         *    `Ref.directory(uri='dummy:directory:/bar', name='bar')`\r\n         */\r\n        browse({\r\n                   uri,\r\n               }: {\r\n            /**\r\n             * URI to browse\r\n             */\r\n            uri: URI;\r\n        }): Promise<any>;\r\n\r\n        /**\r\n         * Search the library for tracks where `field` contains `values`.\r\n         *\r\n         * `field` can be one of `uri`, `track_name`, `album`, `artist`, `albumartist`,\r\n         * `composer`, `performer`, `track_no`, `genre`, `date`, `comment`, or `any`.\r\n         *\r\n         * If `uris` is given, the search is limited to results from within the URI\r\n         * roots. For example passing `uris=['file:']` will limit the search to the\r\n         * local backend.\r\n         *\r\n         * Examples:\r\n         *\r\n         *     # Returns results matching 'a' in any backend\r\n         *     search({'any': ['a']})\r\n         *\r\n         *     # Returns results matching artist 'xyz' in any backend\r\n         *     search({'artist': ['xyz']})\r\n         *\r\n         *     # Returns results matching 'a' and 'b' and artist 'xyz' in any\r\n         *     # backend\r\n         *     search({'any': ['a', 'b'], 'artist': ['xyz']})\r\n         *\r\n         *     # Returns results matching 'a' if within the given URI roots\r\n         *     # \"file:///media/music\" and \"spotify:\"\r\n         *     search({'any': ['a']}, uris=['file:///media/music', 'spotify:'])\r\n         *\r\n         *     # Returns results matching artist 'xyz' and 'abc' in any backend\r\n         *     search({'artist': ['xyz', 'abc']})\r\n         */\r\n        search({\r\n                   query,\r\n                   uris,\r\n                   exact,\r\n               }: {\r\n            /**\r\n             * one or more queries to search for\r\n             */\r\n            query: Query;\r\n            /**\r\n             * zero or more URI roots to limit the search to\r\n             */\r\n            uris?: string[];\r\n            /**\r\n             * if the search should use exact matching\r\n             */\r\n            exact?: boolean;\r\n        }): Promise<any>;\r\n\r\n        /**\r\n         * Lookup the given URIs.\r\n         *\r\n         * If the URI expands to multiple tracks, the returned list will contain them all.\r\n         */\r\n        lookup({\r\n                   uris,\r\n               }: {\r\n            /**\r\n             * A list of URI's\r\n             */\r\n            uris: string[];\r\n        }): Promise<{ [index: string]: models.Track[] }>;\r\n\r\n        /**\r\n         *\r\n         * Refresh library. Limit to URI and below if an URI is given.\r\n         */\r\n        refresh({ uri }: { uri?: string }): Promise<void>;\r\n\r\n        /**\r\n         * Lookup the images for the given URIs\r\n         *\r\n         * Backends can use this to return image URIs for any URI they know about be\r\n         * it tracks, albums, playlists. The lookup result is a dictionary mapping\r\n         * the provided URIs to lists of images.\r\n         *\r\n         * Unknown URIs or URIs the corresponding backend couldn't find anything for\r\n         * will simply return an empty list for that URI.\r\n         */\r\n        getImages({\r\n                      uris,\r\n                  }: {\r\n            /**\r\n             * A list of URI's\r\n             */\r\n            uris: string[];\r\n        }): Promise<any>;\r\n    }\r\n\r\n    interface PlaylistsController {\r\n        getUriSchemes(): Promise<string[]>;\r\n\r\n        asList(): Promise<any>;\r\n\r\n        getItems({ uri }: { uri: string }): Promise<any>;\r\n\r\n        lookup({ uri }: { uri: URI }): Promise<models.Playlist | null>;\r\n\r\n        refresh({ uri_scheme }: { uri_scheme?: string }): Promise<void>;\r\n\r\n        create({\r\n                   name,\r\n                   uri_scheme,\r\n               }: {\r\n            name: string;\r\n            uri_scheme?: string;\r\n        }): Promise<models.Playlist | null>;\r\n\r\n        save({\r\n                 playlist,\r\n             }: {\r\n            playlist: models.Playlist;\r\n        }): Promise<models.Playlist | null>;\r\n\r\n        delete({\r\n                   uri,\r\n               }: {\r\n            uri: URI;\r\n        }): Promise<boolean>;\r\n    }\r\n\r\n    interface MixerController {\r\n        getMute(): Promise<boolean | null>;\r\n        setMute({ mute }: { mute: boolean }): Promise<boolean>;\r\n        getVolume(): Promise<number | null>;\r\n        setVolume({ volume }: { volume: number }): Promise<boolean>;\r\n    }\r\n\r\n    interface HistoryController {\r\n        getHistory(): Promise<any>;\r\n        getLength(): Promise<number>;\r\n    }\r\n}\r\n\r\n//todo: use this one instead?\r\n// https://javascript.plainenglish.io/building-a-simple-event-emitter-in-javascript-f82f68c214ad\r\nclass EventEmitter {\r\n    listeners = [];\r\n    supervisors = [];\r\n\r\n    emit(eventName: string, ...data) {\r\n        this.listeners.filter(({name}) => name === eventName)\r\n            .forEach(({callback}) => {\r\n                setTimeout(() =>  callback.call(this, ...data) , 0);\r\n            });\r\n        this.supervisors.forEach(callback => {\r\n            setTimeout(() => callback.call(this, ...data), 0);\r\n        });\r\n    }\r\n\r\n    on(name: string | Function, callback?: any) { //todo: make callback type more specific?\r\n        if(typeof name === 'string' && typeof callback === 'function') {\r\n            this.listeners.push({name, callback});\r\n            return;\r\n        }\r\n        if(typeof name === 'function') {\r\n            this.supervisors.push(name);\r\n        }\r\n    }\r\n\r\n    off(eventName: string, callback: any) {\r\n        this.removeListener(eventName, callback);\r\n    }\r\n\r\n    destroy() {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    removeAllListeners(eventName?: string) {\r\n        if(!eventName) {\r\n            this.listeners.length = 0;\r\n            return;\r\n        }\r\n        this.listeners = this.listeners.filter(listener => !(listener.name === eventName ));\r\n    }\r\n\r\n    removeListener(eventName: string, callback: any) {\r\n        this.listeners = this.listeners.filter(listener =>\r\n            !(listener.name === eventName &&\r\n                listener.callback === callback)\r\n        );\r\n    }\r\n}\r\n\r\nfunction snakeToCamel(name: string) {\r\n  return name.replace(/(_[a-z])/g, (match) =>\r\n    match.toUpperCase().replace(\"_\", \"\")\r\n  );\r\n}\r\n\r\nexport class Mopidy extends EventEmitter {\r\n    _options: Options;\r\n    private _backoffDelay: number;\r\n    private _pendingRequests: {}; //this initialization gets stripped by rolldown!\r\n    private _webSocket: WebSocket;\r\n    constructor(options: Options) {\r\n        super();\r\n        const defaultOptions = {\r\n            backoffDelayMin: 1000,\r\n                backoffDelayMax: 64000,\r\n            autoConnect: true,\r\n            webSocketUrl: ''\r\n        };\r\n        this._options = this._configure({...defaultOptions, ...options});\r\n        this._backoffDelay = this._options.backoffDelayMin;\r\n        this._pendingRequests = {};\r\n        this._webSocket = null;\r\n        this._delegateEvents();\r\n        if (this._options.autoConnect) {\r\n            this.connect();\r\n        }\r\n    }\r\n\r\n    private _configure(options: Options) {\r\n        if(options.webSocketUrl)\r\n            return options;\r\n\r\n        let protocol =\r\n            typeof document !== \"undefined\" && document.location.protocol === \"https:\"\r\n                ? \"wss://\"\r\n                : \"ws://\";\r\n        let currentHost =\r\n            (typeof document !== \"undefined\" && document.location.host) ||\r\n            \"localhost\";\r\n        options.webSocketUrl = `${protocol}${currentHost}/mopidy/ws`;\r\n        return options;\r\n    }\r\n\r\n  _delegateEvents() {\r\n    // Remove existing event handlers\r\n    this.removeAllListeners(\"websocket:close\");\r\n    this.removeAllListeners(\"websocket:error\");\r\n    this.removeAllListeners(\"websocket:incomingMessage\");\r\n    this.removeAllListeners(\"websocket:open\");\r\n    this.removeAllListeners(\"state:offline\");\r\n    // Register basic set of event handlers\r\n    this.on(\"websocket:close\", this._cleanup);\r\n    this.on(\"websocket:error\", this._handleWebSocketError);\r\n    this.on(\"websocket:incomingMessage\", this._handleMessage);\r\n    this.on(\"websocket:open\", this._resetBackoffDelay);\r\n    this.on(\"websocket:open\", this._getApiSpec);\r\n    this.on(\"state:offline\", this._reconnect);\r\n  }\r\n\r\n  eventOff(eventName?: string, callback?: any) {\r\n    if (!eventName) {\r\n      this.removeAllListeners();\r\n      return;\r\n    }\r\n    if (!callback) {\r\n        this.removeAllListeners(eventName);\r\n        return;\r\n    }\r\n  this.removeListener(eventName, callback);\r\n  }\r\n\r\n  connect() {\r\n    if (this._webSocket) {\r\n      if (this._webSocket.readyState === WebSocket.OPEN) {\r\n        return;\r\n      }\r\n      this._webSocket.close();\r\n    }\r\n\r\n    this._webSocket = new WebSocket(this._options.webSocketUrl);\r\n\r\n    this._webSocket.onclose = (close) => {\r\n      this.emit(\"websocket:close\", close);\r\n    };\r\n    this._webSocket.onerror = (error) => {\r\n      this.emit(\"websocket:error\", error);\r\n    };\r\n    this._webSocket.onopen = () => {\r\n      this.emit(\"websocket:open\");\r\n    };\r\n    this._webSocket.onmessage = (message) => {\r\n      this.emit(\"websocket:incomingMessage\", message);\r\n    };\r\n  }\r\n\r\n  _cleanup(closeEvent) {\r\n    Object.keys(this._pendingRequests).forEach((requestId) => {\r\n      const { reject } = this._pendingRequests[requestId];\r\n      delete this._pendingRequests[requestId];\r\n      const error = new ConnectionError(\"WebSocket closed\");\r\n      error.closeEvent = closeEvent;\r\n      reject(error);\r\n    });\r\n    this.emit(\"state\", \"state:offline\");\r\n    this.emit(\"state:offline\");\r\n  }\r\n\r\n  _reconnect() {\r\n    // We asynchronously process the reconnect because we don't want to start\r\n    // emitting \"reconnectionPending\" events before we've finished handling the\r\n    // \"state:offline\" event, which would lead to emitting the events to\r\n    // listeners in the wrong order.\r\n    setTimeout(() => {\r\n      this.emit(\"state\", [\r\n          \"reconnectionPending\",\r\n          { timeToAttempt: this._backoffDelay}\r\n      ]);\r\n      this.emit(\"reconnectionPending\", {\r\n        timeToAttempt: this._backoffDelay,\r\n      });\r\n      setTimeout(() => {\r\n        this.emit(\"state\", \"reconnecting\");\r\n        this.emit(\"reconnecting\");\r\n        this.connect();\r\n      }, this._backoffDelay);\r\n      this._backoffDelay *= 2;\r\n      if (this._backoffDelay > this._options.backoffDelayMax) {\r\n        this._backoffDelay = this._options.backoffDelayMax;\r\n      }\r\n    }, 0);\r\n  }\r\n\r\n  _resetBackoffDelay() {\r\n    this._backoffDelay = this._options.backoffDelayMin;\r\n  }\r\n\r\n  close() {\r\n    this.eventOff(\"state:offline\", this._reconnect);\r\n    if (this._webSocket) {\r\n      this._webSocket.close();\r\n    }\r\n  }\r\n\r\n  _handleWebSocketError(error) {\r\n    console.warn(\"WebSocket error:\", error.stack || error);\r\n  }\r\n\r\n  send(message: Object) {\r\n    switch (this._webSocket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return Promise.reject(\r\n          new ConnectionError(\"WebSocket is still connecting\")\r\n        );\r\n      case WebSocket.CLOSING:\r\n        return Promise.reject(\r\n          new ConnectionError(\"WebSocket is closing\")\r\n        );\r\n      case WebSocket.CLOSED:\r\n        return Promise.reject(\r\n          new ConnectionError(\"WebSocket is closed\")\r\n        );\r\n      default:\r\n        return new Promise((resolve, reject) => {\r\n          const jsonRpcMessage = {\r\n            ...message,\r\n            jsonrpc: \"2.0\",\r\n            id: this._nextRequestId(),\r\n          };\r\n          this._pendingRequests[jsonRpcMessage.id] = { resolve, reject };\r\n          this._webSocket.send(JSON.stringify(jsonRpcMessage));\r\n          this.emit(\"websocket:outgoingMessage\", jsonRpcMessage);\r\n        });\r\n    }\r\n  }\r\n\r\n  _handleMessage(message) {\r\n    try {\r\n      const data = JSON.parse(message.data);\r\n      if (Object.hasOwnProperty.call(data, \"id\")) {\r\n        this._handleResponse(data);\r\n      } else if (Object.hasOwnProperty.call(data, \"event\")) {\r\n        this._handleEvent(data);\r\n      } else {\r\n        console.warn(\r\n          `Unknown message type received. Message was: ${message.data}`\r\n        );\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof SyntaxError) {\r\n        console.warn(\r\n          `WebSocket message parsing failed. Message was: ${message.data}`\r\n        );\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  _handleResponse(responseMessage) {\r\n    if (\r\n      !Object.hasOwnProperty.call(this._pendingRequests, responseMessage.id)\r\n    ) {\r\n      console.warn(\r\n        \"Unexpected response received. Message was:\",\r\n        responseMessage\r\n      );\r\n      return;\r\n    }\r\n    const { resolve, reject } = this._pendingRequests[responseMessage.id];\r\n    delete this._pendingRequests[responseMessage.id];\r\n    if (Object.hasOwnProperty.call(responseMessage, \"result\")) {\r\n      resolve(responseMessage.result);\r\n    } else if (Object.hasOwnProperty.call(responseMessage, \"error\")) {\r\n      const error = new ServerError(responseMessage.error.message);\r\n      error.code = responseMessage.error.code;\r\n      error.data = responseMessage.error.data;\r\n      reject(error);\r\n      console.warn(\"Server returned error:\", responseMessage.error);\r\n    } else {\r\n      const error = new OtherError(\"Response without 'result' or 'error' received\");\r\n      error.data = { response: responseMessage };\r\n      reject(error);\r\n      console.warn(\r\n        \"Response without 'result' or 'error' received. Message was:\",\r\n        responseMessage\r\n      );\r\n    }\r\n  }\r\n\r\n  _handleEvent(eventMessage) {\r\n    const data = { ...eventMessage };\r\n    delete data.event;\r\n    const eventName = `event:${snakeToCamel(eventMessage.event)}`;\r\n    this.emit(\"event\", [eventName, data]);\r\n    this.emit(eventName, data);\r\n  }\r\n\r\n  _getApiSpec() {\r\n    return this.send({ method: \"core.describe\" })\r\n      .then(this._createApi.bind(this))\r\n      .catch(this._handleWebSocketError.bind(this));\r\n  }\r\n\r\n  _createApi(methods) {\r\n    const caller = (method) => (...args) => {\r\n      let message = { method,\r\n      };\r\n      if (args.length === 0) {\r\n        return this.send(message);\r\n      }\r\n      if (args.length > 1) {\r\n        return Promise.reject(\r\n          new Error(\r\n            \"Expected zero arguments, a single array, or a single object.\"\r\n          )\r\n        );\r\n      }\r\n      if (!Array.isArray(args[0]) && args[0] !== Object(args[0])) {\r\n        return Promise.reject(new TypeError(\"Expected an array or an object.\"));\r\n      }\r\n      let message2 = {\r\n          method,\r\n          params: args\r\n      };\r\n      return this.send(message2);\r\n    };\r\n\r\n    const getPath = (fullName) => {\r\n      let path = fullName.split(\".\");\r\n      if (path.length >= 1 && path[0] === \"core\") {\r\n        path = path.slice(1);\r\n      }\r\n      return path;\r\n    };\r\n\r\n    const createObjects = (objPath) => {\r\n      let parentObj = this;\r\n      objPath.forEach((objName) => {\r\n        const camelObjName = snakeToCamel(objName);\r\n        parentObj[camelObjName] = parentObj[camelObjName] || {};\r\n        parentObj = parentObj[camelObjName];\r\n      });\r\n      return parentObj;\r\n    };\r\n\r\n    const createMethod = (fullMethodName) => {\r\n      const methodPath = getPath(fullMethodName);\r\n      const methodName = snakeToCamel(methodPath.slice(-1)[0]);\r\n      const object = createObjects(methodPath.slice(0, -1));\r\n      object[methodName] = caller(fullMethodName);\r\n      object[methodName].description = methods[fullMethodName].description;\r\n      object[methodName].params = methods[fullMethodName].params;\r\n    };\r\n\r\n    Object.keys(methods).forEach(createMethod);\r\n\r\n    this.emit(\"state\", \"state:online\");\r\n    this.emit(\"state:online\");\r\n  }\r\n\r\n    static idCounter = -1;\r\n    _nextRequestId () {\r\n        return ++Mopidy.idCounter;\r\n    }\r\n\r\n}\r\n\r\nclass ConnectionError extends Error {\r\n    closeEvent?: any;\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"ConnectionError\";\r\n    }\r\n}\r\n\r\nclass ServerError extends Error {\r\n    code: any;\r\n    data: any;\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"ServerError\";\r\n    }\r\n}\r\n\r\nclass OtherError extends Error {\r\n    data: any;\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = \"OtherError\";\r\n    }\r\n}\r\n","// Helper function to provide a reference time in milliseconds.\r\nlet now = /* Sinon does not currently support faking `window.performance`\r\n             (see https://github.com/sinonjs/sinon/issues/803).\r\n             Changing this to only rely on `new Date().getTime()\r\n             in the interim in order to allow testing of the\r\n             progress timer from MMW.\r\n\r\n             typeof window.performance !== 'undefined' &&\r\n             typeof window.performance.now !== 'undefined' &&\r\n             window.performance.now.bind(window.performance) || Date.now ||*/\r\n    function () {\r\n        return new Date().getTime();\r\n    };\r\n\r\ninterface TimerOptions {\r\n    // Your callback for updating UI state, required.\r\n    callback: (position:number, duration: number) => void,\r\n    // Target frame rate when using legacy setTimeout fallback, default: 30.\r\n    fallbackTargetFrameRate: number,\r\n    // Force legacy setTimeout fallback for testing, default: false.\r\n    disableRequestAnimationFrame: boolean\r\n}\r\n\r\ntype TimerCallback = (position:number, duration:number)=> void;\r\n\r\n// Creates a new timer object, works with both 'new ProgressTimer(options)'\r\n// and just 'ProgressTimer(options). Optionally the timer can also be\r\n// called with only the callback instead of options.\r\nexport class ProgressTimer {\r\n    callback: TimerCallback;\r\n    // Target frame rate when using legacy setTimeout fallback, default: 30.\r\n    fallbackTargetFrameRate = 30;\r\n    // Force legacy setTimeout fallback for testing, default: false.\r\n    disableRequestAnimationFrame = false;\r\n\r\n    _updateId = null;\r\n    _state = null;  // Gets initialized by the set() call.\r\n    private readonly _schedule: (timestamp: number) => number;\r\n    private readonly _cancel: any;\r\n\r\n    constructor(options: TimerOptions | TimerCallback) {\r\n        if (typeof options === 'function') {\r\n            this.callback = options;\r\n        } else {\r\n            this.callback = options.callback;\r\n            this.fallbackTargetFrameRate = options.fallbackTargetFrameRate;\r\n            this.disableRequestAnimationFrame = options.disableRequestAnimationFrame;\r\n        }\r\n\r\n        this._updateId = null;\r\n        this._state = null;  // Gets initialized by the set() call.\r\n\r\n        let frameDuration = 1000 / this.fallbackTargetFrameRate;\r\n\r\n        let useFallback = (\r\n            typeof window.requestAnimationFrame === 'undefined' ||\r\n            typeof window.cancelAnimationFrame === 'undefined' ||\r\n            options['disableRequestAnimationFrame'] || false);\r\n\r\n        // Make sure this works in _update.\r\n        let update = this._update.bind(this);\r\n\r\n        if (useFallback) {\r\n            this._schedule = function (timestamp: number) {\r\n                let timeout = Math.max(timestamp + frameDuration - now(), 0);\r\n                return window.setTimeout(update, Math.floor(timeout));\r\n            };\r\n            this._cancel = window.clearTimeout.bind(window);\r\n        } else {\r\n            this._schedule = window.requestAnimationFrame.bind(window, update);\r\n            this._cancel = window.cancelAnimationFrame.bind(window);\r\n        }\r\n\r\n        this.reset(); // Reuse reset code to ensure we start in the same state.\r\n    }\r\n\r\n// If called with one argument the previous duration is preserved. Note\r\n// that the position can be changed while the timer is running.\r\n    set(position: number, duration: number = undefined) {\r\n        if (!duration) {\r\n            // Fallback to previous duration, whatever that was.\r\n            duration = this._state.duration;\r\n        }\r\n\r\n        // Round down and make sure zero and null are treated as inf.\r\n        duration = Math.floor(Math.max(\r\n            duration === null ? Infinity : duration || Infinity, 0));\r\n\r\n        // Make sure '0 <= position <= duration' always holds.\r\n        position = Math.floor(Math.min(Math.max(position || 0, 0), duration));\r\n\r\n        this._state = {\r\n            initialTimestamp: null,\r\n            initialPosition: position,\r\n            position: position,\r\n            duration: duration\r\n        };\r\n\r\n        // Update right away if we don't have anything running.\r\n        if (this._updateId === null) {\r\n            // TODO: Consider wrapping this in a try/catch?\r\n            this.callback(position, duration);\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Start the timer if it is not already running.\r\n    start() {\r\n        if (this._updateId === null) {\r\n            this._updateId = this._schedule(0);\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Cancel the timer if it us currently tracking progress.\r\n    stop() {\r\n        if (this._updateId !== null) {\r\n            this._cancel(this._updateId);\r\n\r\n            // Ensure we correctly reset the initial position and timestamp.\r\n            this.set(this._state.position, this._state.duration);\r\n            this._updateId = null;  // Last step to avoid callback in set()\r\n        }\r\n        return this;\r\n    };\r\n\r\n// Marks the timer as stopped, sets position to zero and duration to inf.\r\n    reset() {\r\n        return this.stop().set(0, Infinity);\r\n    };\r\n\r\n// Calls the user callback with the current position/duration and then\r\n// schedules the next update run via _schedule if we haven't finished.\r\n    _update(timestamp: number) {\r\n        let state = this._state;  // We refer a lot to state, this is shorter.\r\n\r\n        // Make sure setTimeout has a timestamp and store first reference time.\r\n        timestamp = timestamp || now();\r\n        state.initialTimestamp = state.initialTimestamp || timestamp;\r\n\r\n        // Recalculate position according to start location and reference.\r\n        state.position = (\r\n            state.initialPosition + timestamp - state.initialTimestamp);\r\n\r\n        // Ensure callback gets an integer and that 'position <= duration'.\r\n        let userPosisition = Math.min(\r\n            Math.floor(state.position), state.duration);\r\n\r\n        // TODO: Consider wrapping this in a try/catch?\r\n        this.callback(userPosisition, state.duration);\r\n        // Workaround for https://github.com/adamcik/media-progress-timer/issues/3\r\n        // Mopidy <= 1.1.2 does not always return the correct track position as\r\n        // track changes are being done, which can cause the timer to die unexpectedly.\r\n        //if (state.position < state.duration) {\r\n        this._updateId = this._schedule(timestamp);  // Schedule update.\r\n        //} else {\r\n        //    this._updateId = null;  // Unset since we didn't reschedule.\r\n        //}\r\n    }\r\n}\r\n","import {ProgressTimer} from \"./timer\";\r\nimport {Mopidy} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\n\r\nfunction delay_exponential (base: number | 'rand', growthFactor: number, attempts: number) {\r\n    /* Calculate number of beats between syncs based on exponential function.\r\n    The format is::\r\n\r\n        base * growthFactor ^ (attempts - 1)\r\n\r\n    If ``base`` is set to 'rand' then a random number between\r\n    0 and 1 will be used as the base.\r\n    Base must be greater than 0.\r\n    */\r\n    if (base === 'rand') {\r\n        base = Math.random()\r\n    }\r\n    // console.log(base + ' * (Math.pow(' + growthFactor + ', (' + attempts + ' - 1)) = ' + base * (Math.pow(growthFactor, (attempts - 1))))\r\n    return base * (Math.pow(growthFactor, (attempts - 1)))\r\n}\r\n\r\nenum SYNC_STATE {\r\n    NOT_SYNCED=0,\r\n    SYNCING= 1,\r\n    SYNCED= 2\r\n}\r\n\r\nexport class SyncedProgressTimer {\r\n    _maxAttempts: number;\r\n    _mopidy: Mopidy;\r\n    syncState = SYNC_STATE.NOT_SYNCED;\r\n    _isSyncScheduled = false;\r\n    _scheduleID = null;\r\n    _syncAttemptsRemaining: number ;\r\n    _previousSyncPosition = null;\r\n    _duration = null;\r\n    _isConnected = false;\r\n    positionNode: Text;\r\n    durationNode: Text;\r\n    private _progressTimer: ProgressTimer;\r\n\r\n    constructor(maxAttempts: number, mopidy: Mopidy) {\r\n        this._maxAttempts = maxAttempts;\r\n        this._mopidy = mopidy;\r\n        this._syncAttemptsRemaining = this._maxAttempts;\r\n\r\n        this.positionNode = document.createTextNode('');\r\n        this.durationNode = document.createTextNode('');\r\n        //todo\r\n        // $('#songelapsed').empty().append(this.positionNode)\r\n        // $('#songlength').empty().append(this.durationNode)\r\n\r\n        this._progressTimer = new ProgressTimer( (position: number, duration: number) => {\r\n            this.timerCallback(position, duration);\r\n            }\r\n        );\r\n\r\n        //todo\r\n        // this._mopidy.on('state:online', $.proxy(function () { this._isConnected = true }), this)\r\n        // this._mopidy.on('state:offline', $.proxy(function () { this._isConnected = false }), this)\r\n    }\r\n\r\n\r\n    static format(milliseconds: number) {\r\n        if (milliseconds === Infinity) {\r\n            return '';\r\n        } else if (milliseconds === 0) {\r\n            return '0:00';\r\n        }\r\n\r\n        let seconds = Math.floor(milliseconds / 1000);\r\n        const minutes = Math.floor(seconds / 60);\r\n        seconds = seconds % 60;\r\n\r\n        let secondString = seconds < 10 ? '0' + seconds : seconds.toString();\r\n        return minutes + ':' + secondString;\r\n    }\r\n\r\n    timerCallback(position: number, duration: number) {\r\n        this._update(position);\r\n        if (this._isSyncScheduled && this._isConnected) {\r\n            this._doSync(position, duration)\r\n        }\r\n    }\r\n\r\n    _update(position: number) {\r\n        switch (this.syncState) {\r\n            case SYNC_STATE.NOT_SYNCED:\r\n                // Waiting for Mopidy to provide a target position.\r\n                this.positionNode.nodeValue = '(wait)'\r\n                break\r\n            case SYNC_STATE.SYNCING:\r\n                // Busy seeking to new target position.\r\n                this.positionNode.nodeValue = '(sync)'\r\n                break\r\n            case SYNC_STATE.SYNCED:\r\n                this._previousSyncPosition = position\r\n                this.positionNode.nodeValue = SyncedProgressTimer.format(position)\r\n                //todo: document.getElementById('trackslider').val(position).slider('refresh')\r\n                break\r\n        }\r\n    }\r\n\r\n    _scheduleSync(milliseconds: number) {\r\n        // Use an anonymous callback to set a boolean value, which should be faster to\r\n        // check in the timeout callback than doing another function call.\r\n        clearTimeout(this._scheduleID)\r\n        this._isSyncScheduled = false\r\n        if (milliseconds >= 0) {\r\n            this._scheduleID = setTimeout(() => {\r\n                this._isSyncScheduled = true;\r\n            }, milliseconds);\r\n        }\r\n    }\r\n\r\n    _doSync(position: number, duration: number) {\r\n        // let ready = !(duration === Infinity && position === 0);  // Timer has been properly initialized.\r\n        // if (!ready) {\r\n        //     // Don't try to sync if progress timer has not been initialized yet.\r\n        //     return;\r\n        // }\r\n        //\r\n        // this._scheduleSync(-1); // Ensure that only one sync process is active at a time.\r\n        //\r\n        // let _this = this;\r\n        // _this.commands.core.playback.getTimePosition().then(function (targetPosition: number) {\r\n        //     if (_this.syncState === SYNC_STATE.NOT_SYNCED) {\r\n        //         _this.syncState = SYNC_STATE.SYNCING;\r\n        //     }\r\n        //     if (Math.abs(targetPosition - position) <= 500) {\r\n        //         // Less than 500ms == in sync.\r\n        //         _this._syncAttemptsRemaining = Math.max(_this._syncAttemptsRemaining - 1, 0);\r\n        //         if (_this._syncAttemptsRemaining < _this._maxAttempts - 1 && _this._previousSyncPosition !== targetPosition) {\r\n        //             // Need at least two consecutive syncs to know that Mopidy\r\n        //             // is progressing playback and we are in sync.\r\n        //             _this.syncState = SYNC_STATE.SYNCED;\r\n        //         }\r\n        //         _this._previousSyncPosition = targetPosition;\r\n        //         // Step back exponentially while increasing number of callbacks.\r\n        //         _this._scheduleSync(delay_exponential(0.25, 2, _this._maxAttempts - _this._syncAttemptsRemaining) * 1000);\r\n        //     } else {\r\n        //         // Drift is too large, re-sync with Mopidy.\r\n        //         _this.syncState = SYNC_STATE.SYNCING;\r\n        //         _this._syncAttemptsRemaining = _this._maxAttempts;\r\n        //         _this._previousSyncPosition = null;\r\n        //         _this._scheduleSync(1000);\r\n        //         _this._progressTimer.set(targetPosition);\r\n        //     }\r\n        // });\r\n    }\r\n\r\n    set(position: number, duration: number = undefined) {\r\n        this.syncState = SYNC_STATE.NOT_SYNCED;\r\n        this._syncAttemptsRemaining = this._maxAttempts;\r\n        // Workaround for https://github.com/adamcik/media-progress-timer/issues/3\r\n        // This causes the timer to die unexpectedly if the position exceeds\r\n        // the duration slightly.\r\n        if (this._duration && this._duration < position) {\r\n            position = this._duration - 1\r\n        }\r\n        if (arguments.length === 1) {\r\n            this._progressTimer.set(position)\r\n        } else {\r\n            this._duration = duration\r\n            this._progressTimer.set(position, duration)\r\n            this.durationNode.nodeValue = SyncedProgressTimer.format(duration)\r\n        }\r\n\r\n        this.updatePosition(position);\r\n        //todo document.getElementById('trackslider').val(position).slider('refresh')\r\n\r\n        return this\r\n    }\r\n\r\n    start() {\r\n        this.syncState = SYNC_STATE.NOT_SYNCED\r\n        this._scheduleSync(0)\r\n        this._progressTimer.start()\r\n        return this\r\n    }\r\n\r\n    stop() {\r\n        this._progressTimer.stop()\r\n        this._scheduleSync(-1)\r\n        if (this.syncState !== SYNC_STATE.SYNCED && this._previousSyncPosition) {\r\n            // Timer was busy trying to sync when it was stopped, fallback to displaying the last synced position on screen.\r\n            this.positionNode.nodeValue = SyncedProgressTimer.format(this._previousSyncPosition)\r\n        }\r\n        return this\r\n    }\r\n\r\n    reset() {\r\n        this.stop()\r\n        this.set(0, Infinity)\r\n\r\n        return this\r\n    }\r\n\r\n    updatePosition(position: number) {\r\n        if (!(this._duration === Infinity && position === 0)) {\r\n            this.positionNode.nodeValue = SyncedProgressTimer.format(position)\r\n        } else {\r\n            this.positionNode.nodeValue = ''\r\n        }\r\n    }\r\n}","import {models, Mopidy} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport {SyncedProgressTimer} from \"./synced_timer\";\r\nimport {DeepReadonly, ViewModel} from \"./model\";\r\nimport {Commands} from \"../scripts/commands\";\r\nimport {EboPlayerDataType, View} from \"./views/view\";\r\nimport {Controller} from \"./controller\";\r\nimport TlTrack = models.TlTrack;\r\n\r\nexport class State {\r\n    mopidy: Mopidy;\r\n    syncedProgressTimer: SyncedProgressTimer;\r\n\r\n    // values for controls\r\n    play: boolean = false;\r\n    random: boolean = false;\r\n    repeat: boolean = false;\r\n    consume: boolean = false;\r\n    single: boolean = false;\r\n    mute: boolean = false;\r\n    positionChanging: boolean = false;\r\n    popupData = {};  // TODO: Refactor into one shared cache,\r\n    songlength: number = 0;\r\n\r\n    artistsHtml: string = '';\r\n    artistsText: string = '';\r\n    albumHtml: string = '';\r\n    albumText: string = '';\r\n    streamUris = {}; //TODO: EBO added this to make gui.ts compile.\r\n\r\n    songdata: (TlTrack | undefined) = undefined;\r\n\r\n    pageScrollPos = {};\r\n\r\n    uriSchemes = {};\r\n\r\n    // array of cached playlists (not only user-playlists, also search, artist, album-playlists)\r\n    playlists = {};  // TODO: Refactor into one shared cache,\r\n    customTracklists =  [];  // TODO: Refactor into one shared cache,\r\n\r\n    browseStack =  [];\r\n    private readonly model: ViewModel;\r\n    private readonly controller: Controller;\r\n\r\n    constructor(mopidy: Mopidy, syncedProgressTimer: SyncedProgressTimer, model: ViewModel, controller: Controller) {\r\n        this.mopidy = mopidy;\r\n        this.syncedProgressTimer = syncedProgressTimer;\r\n        this.model = model;\r\n        this.controller = controller;\r\n    }\r\n    views: View[] = [];\r\n    getModel = (): DeepReadonly<ViewModel> => this.model;\r\n    getController = () => this.controller;\r\n\r\n    addViews(...views:View[]) {\r\n        this.views.push(...views);\r\n        views.forEach(v => v.bindRecursive());\r\n    }\r\n\r\n    async getRequiredData()  {\r\n        let requiredData = new Set<EboPlayerDataType>();\r\n        this.views.forEach(v => {\r\n            v.getRequiredDataTypesRecursive().forEach((dataType: EboPlayerDataType) => requiredData.add(dataType));\r\n        });\r\n        this.controller.getRequiredDataTypesRecursive().forEach((dataType => requiredData.add(dataType)));\r\n\r\n        for (const dataType of requiredData) {\r\n            await this.controller.getData(dataType);\r\n        }\r\n    }\r\n}\r\n\r\nlet state: State = undefined; //todo: assuming here that all calls to getState() will receive a valid state object.\r\n\r\nexport function setState(newState: State) { state = newState; }\r\nconst getState = () => state;\r\n\r\nexport default getState;","import {models} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport TlTrack = models.TlTrack;\r\n\r\nexport enum TrackType { None, File, Stream}\r\n\r\nexport interface FileTrackModel {\r\n    type: TrackType.File;\r\n    track: models.Track;\r\n    title: string,\r\n    composer?: string,\r\n    performer: string,\r\n    songlenght: number,\r\n    //...more properties?\r\n}\r\n\r\nexport interface StreamTrackModel {\r\n    type: TrackType.Stream;\r\n    track: models.Track;\r\n    name: string,\r\n    infoLines: string[]\r\n}\r\n\r\nexport interface NoneTrackModel {\r\n    type: TrackType.None;\r\n}\r\n\r\nexport enum EboplayerEvents {\r\n    volumeChanged = \"eboplayer.volumeChanged\",\r\n    connectionChanged = \"eboplayer.connectionChanged\",\r\n    playStateChanged = \"eboplayer.playbackStateChanged\",\r\n    messageChanged = \"eboplayer.messageChanged\",\r\n    currentTrackChanged = \"eboplayer.currentTrackChanged\",\r\n    activeStreamLinesChanged = \"eboplayer.activeStreamLinesChanged\",\r\n    historyChanged = \"eboplayer.historyChanged\",\r\n    trackListChanged = \"eboplayer.trackListChanged\",\r\n}\r\n\r\nexport type TrackModel  = NoneTrackModel | FileTrackModel | StreamTrackModel;\r\n\r\nexport type DeepReadonly<T> = T extends Function ? T :\r\n    T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } :\r\n        T;\r\n\r\nexport enum ConnectionState {Offline, Online}\r\n\r\nexport enum MessageType { None, Info, Warning, Error}\r\n\r\ninterface Message {\r\n    type: MessageType,\r\n    message: string\r\n}\r\n\r\ninterface PlaybackModesState {\r\n    repeat:  boolean,\r\n    random: boolean,\r\n    consume: boolean,\r\n    single: boolean\r\n}\r\n\r\nexport enum PlayState  {\r\n    stopped  = \"stopped\",\r\n    playing  =  \"playing\",\r\n    paused = \"paused\"\r\n}\r\n\r\nexport interface ViewModel extends EventTarget {\r\n    getConnectionState: () => ConnectionState;\r\n    getCurrentTrack: () => DeepReadonly<TrackModel>;\r\n    getCurrentMessage: () => Message;\r\n    getVolume: () => number;\r\n    getPlayState: () => PlayState;\r\n    getActiveStreamLines: () => string[];\r\n    getHistory: () => HistoryLine[];\r\n}\r\n\r\nexport interface HistoryRef {\r\n    __model__: string,\r\n    name: string;\r\n    type: string;\r\n    uri: string;\r\n}\r\nexport interface HistoryLine {\r\n    timestamp: number;\r\n    ref: HistoryRef;\r\n}\r\n\r\nexport type LibraryDict = { [index: string]: models.Track[] };\r\n\r\nexport class Model extends EventTarget implements ViewModel {\r\n    static NoTrack: TrackModel = { type: TrackType.None } as NoneTrackModel;\r\n    currentTrack: TrackModel = Model.NoTrack;\r\n    volume: number;\r\n    connectionState: ConnectionState = ConnectionState.Offline;\r\n    currentMessage: Message = {\r\n        type: MessageType.None,\r\n        message: \"\"\r\n    };\r\n\r\n    playbackModesState: PlaybackModesState = {\r\n        repeat: false,\r\n        random: false,\r\n        consume: false,\r\n        single: false\r\n    }\r\n    private playState: PlayState;\r\n    private activeStreamLines: string[];\r\n    private history: HistoryLine[];\r\n    private trackList: TlTrack[] = [];\r\n    private libraryCache: LibraryDict = {};\r\n\r\n    constructor() {\r\n        super();\r\n        this.libraryCache = {};\r\n    }\r\n\r\n    setConnectionState(state: ConnectionState) {\r\n        this.connectionState  = state;\r\n        if(this.connectionState == ConnectionState.Online)\r\n            this.clearMessage();\r\n        else\r\n            this.setErrorMessage(\"Offline\");\r\n        this.dispatchEvent(new Event(EboplayerEvents.connectionChanged));\r\n    }\r\n\r\n    getConnectionState = () => this.connectionState;\r\n\r\n    getCurrentTrack = (): DeepReadonly<TrackModel> => this.currentTrack;\r\n\r\n    setCurrentTrack(track: TrackModel) {\r\n        this.currentTrack = track;\r\n        this.dispatchEvent(new Event(EboplayerEvents.currentTrackChanged));\r\n    }\r\n\r\n    clearCurrentTrack() {\r\n        this.setCurrentTrack(Model.NoTrack);\r\n    }\r\n\r\n    setVolume(volume: number) {\r\n        this.volume = volume;\r\n        this.dispatchEvent(new Event(EboplayerEvents.volumeChanged));\r\n    }\r\n\r\n    private setMessage(message: Message) {\r\n        this.currentMessage = message;\r\n        this.dispatchEvent(new Event(EboplayerEvents.messageChanged));\r\n    }\r\n\r\n    getCurrentMessage = () => this.currentMessage;\r\n\r\n    clearMessage() {\r\n        this.setMessage( { type: MessageType.None, message: \"\"});\r\n    }\r\n    setInfoMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Info, message});\r\n    }\r\n    setWarningMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Warning, message});\r\n    }\r\n    setErrorMessage(message: string) {\r\n        this.setMessage( { type: MessageType.Error, message});\r\n    }\r\n\r\n    setPlaybackState(state: PlaybackModesState) {\r\n        this.playbackModesState = {...state};\r\n        this.dispatchEvent(new Event(EboplayerEvents.playStateChanged));\r\n    }\r\n\r\n    getVolume = () => this.volume;\r\n\r\n    getPlayState(): PlayState {\r\n        return this.playState;\r\n    }\r\n\r\n    setPlayState(state: PlayState) {\r\n        this.playState = state;\r\n        this.dispatchEvent(new Event(EboplayerEvents.playStateChanged));\r\n    }\r\n\r\n    setActiveStreamLinesHistory(lines: string[]) {\r\n        this.activeStreamLines = lines;\r\n        this.dispatchEvent(new Event(EboplayerEvents.activeStreamLinesChanged));\r\n    }\r\n\r\n    getActiveStreamLines = () => this.activeStreamLines;\r\n\r\n    setHistory(history: HistoryLine[]) {\r\n        this.history = history;\r\n        this.dispatchEvent(new Event(EboplayerEvents.historyChanged));\r\n    }\r\n\r\n    getHistory = () => this.history;\r\n\r\n    setTrackList(trackList: TlTrack[]) {\r\n        this.trackList = trackList;\r\n        this.dispatchEvent(new Event(EboplayerEvents.trackListChanged));\r\n    }\r\n    getTrackList = () => this.trackList;\r\n\r\n    addToLibraryCache(tracks: LibraryDict) {\r\n        this.libraryCache = {...this.libraryCache, ...tracks};\r\n    }\r\n\r\n    getTrackFromCache(uri: string) {\r\n        return this.libraryCache[uri];\r\n    }\r\n}\r\n","import {EboPlayerDataType} from \"./view\";\r\n\r\nexport interface Parent<Child> {\r\n    addChildren(...children: Child[]): void;\r\n\r\n    get children(): Child[];\r\n}\r\n\r\nexport interface DataRequester {\r\n    getRequiredDataTypes(): EboPlayerDataType[];\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[];\r\n}\r\n\r\nexport abstract class NestedDataRequester<T extends NestedDataRequester<T>> implements Parent<T>, DataRequester {\r\n    private _children: T[] = [];\r\n\r\n    abstract getRequiredDataTypes(): EboPlayerDataType[];\r\n\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[] {\r\n        return [...this.getRequiredDataTypes(), ...this._children.map(child => child.getRequiredDataTypesRecursive()).flat()];\r\n    }\r\n\r\n    addChildren(...children: T[]) {\r\n        this._children.push(...children);\r\n    }\r\n\r\n    get children(): T[] {\r\n        return this._children;\r\n    }\r\n}","import {NestedDataRequester} from \"./dataRequester\";\r\n\r\nexport enum EboPlayerDataType {\r\n    Volume,\r\n    CurrentTrack,\r\n    PlayState,\r\n    StreamLines,\r\n    TrackList,\r\n}\r\n\r\nexport abstract class View extends NestedDataRequester<View> {\r\n    abstract bind(): void;\r\n    static getSubId(parentId: string, subId: string) {\r\n        return document.getElementById(`${parentId}.${subId}`);\r\n    }\r\n\r\n    bindRecursive() {\r\n        this.children.forEach(child => child.bindRecursive());\r\n        this.bind();\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboplayerEvents, MessageType} from \"../model\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\n\r\nexport class HeaderView extends View {\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.messageChanged, () => {\r\n            this.onMessageChangegd();\r\n        });\r\n    }\r\n\r\n    private onMessageChangegd() {\r\n        let msg = getState().getModel().getCurrentMessage();\r\n        let headerSpan = document.getElementById(\"contentHeadline\");\r\n        headerSpan.innerText = msg.message;\r\n        if (msg.type == MessageType.Error) {\r\n            headerSpan.classList.add(\"warning\"); //todo: implement all MessageTypes\r\n        } else {\r\n            headerSpan.classList.remove(\"warning\", \"error\");\r\n        }\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [];\r\n    }\r\n}","import * as controls from \"./controls\";\r\nimport {ALBUM_TABLE, albumTracksToTable, ARTIST_TABLE, getAlbum, getArtist, getMediaClass, isFavouritesPlaylist, resultsToTables, scrollToTracklist, showLoading} from \"./functionsvars\";\r\nimport * as images from \"./images\";\r\nimport {models} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport getState from \"./playerState\";\r\nimport {TrackModel} from \"./model\";\r\nimport {transformTrackDataToModel} from \"./controller\";\r\nimport TlTrack = models.TlTrack;\r\n\r\nexport function transformTlTrackDataToModel(tlTrack: (TlTrack | null)): TrackModel {\r\n    return transformTrackDataToModel(tlTrack?.track);\r\n}\r\n\r\nexport function processVolume (data: number | null) {\r\n    getState().getController().setVolume(data);\r\n}\r\n\r\nexport function processMute (data: boolean | null) {\r\n    controls.setMute(data);\r\n}\r\n\r\nexport function processCurrentposition (data) {\r\n    controls.setPosition(parseInt(data))\r\n}\r\n\r\nexport function processPlaystate (data) {\r\n    if (data === 'playing') {\r\n        controls.setPlayState(true)\r\n    } else {\r\n        controls.setPlayState(false)\r\n    }\r\n}\r\n\r\nfunction processBrowseDir (resultArr: string | any[]) {\r\n//     document.querySelector(BROWSE_TABLE).innerHTML = \"\";\r\n//     if (getState().browseStack.length > 0) {\r\n//         renderSongLiBackButton(resultArr, BROWSE_TABLE, 'return library.getBrowseDir();');\r\n//     }\r\n//     if (!resultArr || resultArr.length === 0) {\r\n//         showLoading(false);\r\n//         return;\r\n//     }\r\n//     let uris = [];\r\n//     let ref, previousRef, nextRef;\r\n//     let uri = resultArr[0].uri;\r\n//     let length = 0 || resultArr.length;\r\n//     getState().customTracklists[BROWSE_TABLE] = [];\r\n//     let html = '';\r\n//\r\n//     // Render list of tracks\r\n//     for (let i = 0, index = 0; i < resultArr.length; i++) {\r\n//         if (resultArr[i].type === 'track') {\r\n//             previousRef = ref || undefined;\r\n//             nextRef = i < resultArr.length - 1 ? resultArr[i + 1] : undefined;\r\n//             ref = resultArr[i];\r\n//             // TODO: consolidate usage of various arrays for caching URIs, Refs, and Tracks\r\n//             getState().popupData[ref.uri] = ref;\r\n//             getState().customTracklists[BROWSE_TABLE].push(ref);\r\n//             uris.push(ref.uri);\r\n//\r\n//             html += renderSongLi(previousRef, ref, nextRef, BROWSE_TABLE, '', BROWSE_TABLE, index, resultArr.length);\r\n//\r\n//             index++;\r\n//         } else {\r\n//             html += '<li><a href=\"#\" onclick=\"return library.getBrowseDir(this.id);\" id=\"' + resultArr[i].uri + '\">' +\r\n//                     '<h1><i class=\"' + getMediaClass(resultArr[i]) + '\"></i> ' + resultArr[i].name + '</h1></a></li>';\r\n//         }\r\n//     }\r\n//\r\n//     document.querySelector(BROWSE_TABLE).append(html);\r\n//     if (getState().browseStack.length > 0) {\r\n//         window.scrollTo(0, getState().browseStack[getState().browseStack.length - 1].scrollPos || 0)  // Restore scroll position\r\n//     }\r\n//\r\n//     updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction())\r\n//\r\n//     // Look up track details and add album headers\r\n// ;    if (uris.length > 0) {\r\n//         getState().commands.core.library.lookup(uris).then(function (resultDict) {\r\n//             // Break into albums and put in tables\r\n//             let requiredImages = {};\r\n//             let track, previousTrack, nextTrack, uri;\r\n//             for (let i = 0, index = 0; i < resultArr.length; i++) {\r\n//                 if (resultArr[i].type === 'track') {\r\n//                     previousTrack = track || undefined\r\n//                     if (i < resultArr.length - 1 && resultDict[resultArr[i + 1].uri]) {\r\n//                         nextTrack = resultDict[resultArr[i + 1].uri][0]\r\n//                     } else {\r\n//                         nextTrack = undefined\r\n//                     }\r\n//                     track = resultDict[resultArr[i].uri][0]\r\n//                         getState().popupData[track.uri] = track  // Need full track info in popups in order to display albums and artists.\r\n//                     if (uris.length === 1 || (previousTrack && !hasSameAlbum(previousTrack, track) && !hasSameAlbum(track, nextTrack))) {\r\n//                         renderSongLiAlbumInfo(track, BROWSE_TABLE)\r\n//                     }\r\n//                     requiredImages[track.uri] = renderSongLiDivider(previousTrack, track, nextTrack, BROWSE_TABLE)[1]\r\n//                 }\r\n//             }\r\n//             showLoading(false)\r\n//             images.setImages(requiredImages, getState().mopidy, 'small')\r\n//         }, console.error)\r\n//     } else {\r\n//         showLoading(false)\r\n//     }\r\n}\r\n\r\nexport function processGetPlaylists (resultArr) {\r\n    if ((!resultArr) || (resultArr === '')) {\r\n        document.getElementById('playlistslist').innerHTML = \"\";\r\n        return\r\n    }\r\n    let tmp = '';\r\n    let favourites = '';\r\n    let starred = '';\r\n\r\n    for (let i = 0; i < resultArr.length; i++) {\r\n        let li_html = '<li><a href=\"#\" onclick=\"return library.showTracklist(this.id);\" id=\"' + resultArr[i].uri + '\">'\r\n        if (isFavouritesPlaylist(resultArr[i])) {\r\n            favourites = li_html + '&hearts; Musicbox Favourites</a></li>';\r\n        } else {\r\n            tmp = tmp + li_html + '<i class=\"' + getMediaClass(resultArr[i]) + '\"></i> ' + resultArr[i].name + '</a></li>';\r\n        }\r\n    }\r\n    // Prepend the user's Spotify \"Starred\" playlist and favourites to the results. (like Spotify official client).\r\n    tmp = favourites + starred + tmp;\r\n    document.getElementById('playlistslist').innerHTML = tmp;\r\n    scrollToTracklist();\r\n    showLoading(false);\r\n}\r\n\r\n/** ******************************************************\r\n * process results of a returned list of playlist track refs\r\n *********************************************************/\r\nexport function processPlaylistItems (resultDict) {\r\n    // var playlist = resultDict.playlist\r\n    // if (!playlist || playlist === '') {\r\n    //     console.log('Playlist', resultDict.uri, 'is invalid')\r\n    //     showLoading(false)\r\n    //     return\r\n    // }\r\n    // let playlistUri = resultDict.uri;\r\n    // getState().playlists[playlistUri] = {'uri': playlistUri, 'tracks': []}\r\n    // if (playlistUri.startsWith('m3u')) {\r\n    //     console.log('Playlist', playlistUri, 'requires tracks lookup');\r\n    //     let trackUris = [];\r\n    //     for (let i = 0; i < playlist.tracks.length; i++) {\r\n    //         trackUris.push(playlist.tracks[i].uri)\r\n    //     }\r\n    //     return getState().commands.core.library.lookup(trackUris).then(function (tracks) {\r\n    //         for (let i = 0; i < trackUris.length; i++) {\r\n    //             let track = tracks[trackUris[i]][0] || playlist.tracks[i];  // Fall back to using track Ref if lookup failed.\r\n    //             getState().playlists[playlistUri].tracks.push(track);\r\n    //         }\r\n    //         showLoading(false);\r\n    //         return getState().playlists[playlistUri].tracks;\r\n    //     })\r\n    // } else {\r\n    //     for (let i = 0; i < playlist.tracks.length; i++) {\r\n    //         let track = playlist.tracks[i];\r\n    //         getState().playlists[playlistUri].tracks.push(track);\r\n    //     }\r\n    //     showLoading(false);\r\n    //     return getState().playlists[playlistUri].tracks;\r\n    // }\r\n}\r\n\r\n/** ******************************************************\r\n * process results of the queue, the current playlist\r\n *********************************************************/\r\nexport function processCurrentPlaylist (resultArr) {\r\n}\r\n\r\n/** ******************************************************\r\n * process results of an artist lookup\r\n *********************************************************/\r\nfunction processArtistResults (resultArr) {\r\n    if (!resultArr || (resultArr.length === 0)) {\r\n        document.getElementById('h_artistname').textContent = 'Artist not found...';\r\n        images.fetchAlbumImage('', ['artistviewimage', 'artistpopupimage'], getState().mopidy);\r\n        showLoading(false);\r\n        return;\r\n    }\r\n    getState().customTracklists[resultArr.uri] = resultArr\r\n\r\n    resultsToTables(resultArr, ARTIST_TABLE, resultArr.uri)\r\n    let artistname = getArtist(resultArr);\r\n    document.getElementById('h_artistname').innerHTML = artistname;\r\n    document.getElementById('artistpopupname').innerHTML = artistname;\r\n    images.setArtistImage(resultArr.uri, resultArr[0].uri, '#artistviewimage, #artistpopupimage', getState().mopidy);\r\n    showLoading(false)\r\n}\r\n\r\n/** ******************************************************\r\n * process results of an album lookup\r\n *********************************************************/\r\nfunction processAlbumResults (resultArr) {\r\n    if (!resultArr || (resultArr.length === 0)) {\r\n        document.getElementById('h_albumname').textContent = 'Album not found...';\r\n        images.fetchAlbumImage('', ['albumviewcover', 'coverpopupimage'], getState().mopidy);\r\n        showLoading(false)\r\n        return\r\n    }\r\n    getState().customTracklists[resultArr.uri] = resultArr;\r\n\r\n    albumTracksToTable(resultArr, ALBUM_TABLE, resultArr.uri);\r\n    let albumname = getAlbum(resultArr);\r\n    let artistname = getArtist(resultArr);\r\n    document.getElementById('h_albumname').innerHTML = albumname;\r\n    document.getElementById('h_albumartist').innerHTML = artistname;\r\n    document.getElementById('coverpopupalbumname').innerHTML = albumname;\r\n    document.getElementById('coverpopupartist').innerHTML = artistname;\r\n    images.fetchAlbumImage(resultArr[0].uri, ['albumviewcover', 'coverpopupimage'], getState().mopidy);\r\n    showLoading(false);\r\n}\r\n","import getState from \"./playerState\";\r\nimport {processCurrentPlaylist, processGetPlaylists} from \"./process_ws\";\r\n\r\nexport let library = {\r\n\r\n    /** *******************************\r\n     * Search\r\n     *********************************/\r\n    searchPressed: function (key) {\r\n        // var value = document.getElementById('searchinput').val();\r\n        // switchContent('search');\r\n        //\r\n        // if (key === 13) {\r\n        //     library.initSearch()\r\n        //     return false\r\n        // }\r\n        return true\r\n    },\r\n\r\n    // init search\r\n    initSearch: function () {\r\n        // let value = document.getElementById('searchinput').val();\r\n        // let searchService = document.getElementById(#selectSearchService').val();\r\n        // // $.cookie('searchScheme', searchService, {expires: 365})\r\n        //\r\n        // if ((value.length < 100) && (value.length > 0)) {\r\n        //     showLoading(true)\r\n        //     // hide ios/android keyboard\r\n        //     document.activeElement.blur()\r\n        //     $('input').blur()\r\n        //\r\n        //     delete customTracklists[URI_SCHEME + ':trackresultscache']\r\n        //     document.getElementById(#searchartists').hide()\r\n        //     document.getElementById(#searchalbums').hide()\r\n        //     document.getElementById(#searchtracks').hide()\r\n        //\r\n        //     if (searchService !== 'all') {\r\n        //         mopidy.library.search({'query': {any: [value]}, 'uris': [searchService + ':']}).then(library.processSearchResults, console.error)\r\n        //     } else {\r\n        //         mopidy.getUriSchemes().then(function (schemes) {\r\n        //             var query = {}\r\n        //             var uris = []\r\n        //\r\n        //             var regexp = $.map(schemes, function (scheme) {\r\n        //                 return '^' + scheme + ':'\r\n        //             }).join('|')\r\n        //\r\n        //             var match = value.match(regexp)\r\n        //             if (match) {\r\n        //                 var scheme = match[0]\r\n        //                 query = {uri: [value]}\r\n        //                 uris = [scheme]\r\n        //             } else {\r\n        //                 query = {any: [value]}\r\n        //             }\r\n        //             mopidy.library.search({'query': query, 'uris': uris}).then(library.processSearchResults, console.error)\r\n        //         })\r\n        //     }\r\n        // }\r\n    },\r\n\r\n    /** ******************************************************\r\n     * process results of a search\r\n     *********************************************************/\r\n    processSearchResults: function (resultArr) {\r\n        // $(SEARCH_TRACK_TABLE).empty()\r\n        // $(SEARCH_ARTIST_TABLE).empty()\r\n        // $(SEARCH_ALBUM_TABLE).empty()\r\n        //\r\n        // // Merge results from different backends.\r\n        // // TODO  should of coures have multiple tables\r\n        // var results = {'tracks': [], 'artists': [], 'albums': []}\r\n        // var i, j\r\n        // var emptyResult = true\r\n        //\r\n        // for (i = 0; i < resultArr.length; i++) {\r\n        //     if (resultArr[i].tracks) {\r\n        //         for (j = 0; j < resultArr[i].tracks.length; j++) {\r\n        //             results.tracks.push(resultArr[i].tracks[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        //     if (resultArr[i].artists) {\r\n        //         for (j = 0; j < resultArr[i].artists.length; j++) {\r\n        //             results.artists.push(resultArr[i].artists[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        //     if (resultArr[i].albums) {\r\n        //         for (j = 0; j < resultArr[i].albums.length; j++) {\r\n        //             results.albums.push(resultArr[i].albums[j])\r\n        //             emptyResult = false\r\n        //         }\r\n        //     }\r\n        // }\r\n        //\r\n        // customTracklists[URI_SCHEME + ':trackresultscache'] = results.tracks\r\n        //\r\n        // if (emptyResult) {\r\n        //     document.getElementById(#searchtracks').show()\r\n        //     $(SEARCH_TRACK_TABLE).append(\r\n        //         '<li class=\"song albumli\"><a href=\"#\"><h1><i></i>No tracks found...</h1></a></li>'\r\n        //     )\r\n        //     toast('No results')\r\n        //     showLoading(false)\r\n        //     return false\r\n        // }\r\n        //\r\n        // if (results.artists.length > 0) {\r\n        //     document.getElementById(#searchartists').show()\r\n        // }\r\n        //\r\n        // if (results.albums.length > 0) {\r\n        //     document.getElementById(#searchalbums').show()\r\n        // }\r\n        //\r\n        // if (results.tracks.length > 0) {\r\n        //     document.getElementById(#searchtracks').show()\r\n        // }\r\n        //\r\n        // // 'Show more' template\r\n        // var showMoreTemplate = '<li onclick=\"$(this).hide().siblings().show(); return false;\"><a>Show {count} more</a></li>'\r\n        //\r\n        // // Artist results\r\n        // var child = ''\r\n        // var template = '<li><a href=\"#\" onclick=\"return library.showArtist(this.id, mopidy)\" id={id}><i class=\"{class}\"></i> <strong>{name}</strong></a></li>'\r\n        // var tokens\r\n        //\r\n        // for (i = 0; i < results.artists.length; i++) {\r\n        //     tokens = {\r\n        //         'id': results.artists[i].uri,\r\n        //         'name': results.artists[i].name,\r\n        //         'class': getMediaClass(results.artists[i])\r\n        //     }\r\n        //\r\n        //     // Add 'Show all' item after a certain number of hits.\r\n        //     if (i === 4 && results.artists.length > 5) {\r\n        //         child += stringFromTemplate(showMoreTemplate, {'count': results.artists.length - i})\r\n        //         template = template.replace('<li>', '<li class=\"overflow\">')\r\n        //     }\r\n        //\r\n        //     child += stringFromTemplate(template, tokens)\r\n        // }\r\n        //\r\n        // // Inject list items, refresh listview and hide superfluous items.\r\n        // $(SEARCH_ARTIST_TABLE).html(child).listview('refresh').find('.overflow').hide()\r\n        //\r\n        // // Album results\r\n        // child = ''\r\n        // template = '<li><a href=\"#\" onclick=\"return library.showAlbum(this.id, mopidy)\" id=\"{albumId}\">'\r\n        // template += '<h5 data-role=\"heading\"><i class=\"{class}\"></i> {albumName}</h5>'\r\n        // template += '<p data-role=\"desc\">{artistName}</p>'\r\n        // template += '</a></li>'\r\n        //\r\n        // for (i = 0; i < results.albums.length; i++) {\r\n        //     tokens = {\r\n        //         'albumId': results.albums[i].uri,\r\n        //         'albumName': results.albums[i].name,\r\n        //         'artistName': '',\r\n        //         'albumYear': results.albums[i].date,\r\n        //         'class': getMediaClass(results.albums[i])\r\n        //     }\r\n        //     if (results.albums[i].artists) {\r\n        //         for (j = 0; j < results.albums[i].artists.length; j++) {\r\n        //             if (results.albums[i].artists[j].name) {\r\n        //                 tokens.artistName += results.albums[i].artists[j].name + ' '\r\n        //             }\r\n        //         }\r\n        //     }\r\n        //     if (tokens.albumYear) {\r\n        //         tokens.artistName += '(' + tokens.albumYear + ')'\r\n        //     }\r\n        //     // Add 'Show all' item after a certain number of hits.\r\n        //     if (i === 4 && results.albums.length > 5) {\r\n        //         child += stringFromTemplate(showMoreTemplate, {'count': results.albums.length - i})\r\n        //         template = template.replace('<li>', '<li class=\"overflow\">')\r\n        //     }\r\n        //\r\n        //     child += stringFromTemplate(template, tokens)\r\n        // }\r\n        // // Inject list items, refresh listview and hide superfluous items.\r\n        // $(SEARCH_ALBUM_TABLE).html(child).listview('refresh').find('.overflow').hide()\r\n        //\r\n        // // Track results\r\n        // resultsToTables(results.tracks, SEARCH_TRACK_TABLE, URI_SCHEME + ':trackresultscache')\r\n        //\r\n        // showLoading(false)\r\n    },\r\n\r\n    /** *******************************\r\n     * Playlists & Browse\r\n     *********************************/\r\n    getPlaylists: function () {\r\n        //  get playlists without tracks\r\n        getState().commands.core.playlists.asList().then(processGetPlaylists, console.error)\r\n    },\r\n\r\n    getBrowseDir: function (rootdir: string | undefined) {\r\n        // //  get directory to browse\r\n        // showLoading(true)\r\n        // if (!rootdir) {\r\n        //     browseStack.pop()\r\n        //     if (browseStack.length > 0) {\r\n        //         rootdir = browseStack[browseStack.length - 1].uri  // Navigated one level up\r\n        //     } else {\r\n        //         rootdir = null  // Navigated to top of library\r\n        //     }\r\n        // } else if (browseStack.length === 0 || rootdir !== browseStack[browseStack.length - 1].uri) {\r\n        //     browseStack.push({'uri': rootdir, 'scrollPos': 0})  // Navigated one level down\r\n        // }\r\n        // mopidy.library.browse({'uri': rootdir}).then(function (resultArr) {\r\n        //     processBrowseDir(resultArr)\r\n        //     if (rootdir === null) {\r\n        //         $('.refreshLibraryBtnDiv').hide()  // Mopidy does not support refreshing list of backends.\r\n        //     } else {\r\n        //         $('.refreshLibraryBtnDiv').show()\r\n        //         document.getElementById(#refreshLibraryBtn').data('url', rootdir)\r\n        //         document.getElementById(#refreshLibraryBtn').off('click')\r\n        //         document.getElementById(#refreshLibraryBtn').one('click', controls.refreshLibrary)\r\n        //     }\r\n        // }, console.error)\r\n    },\r\n\r\n    /** ******************************************************\r\n     * Show tracks of playlist\r\n     ********************************************************/\r\n    togglePlaylists: function () {\r\n        // if (window.innerWidth <= 960) {\r\n        //     document.getElementById('playlisttracksdiv').toggle();\r\n        //     // Hide other div\r\n        //     (document.getElementById('playlisttracksdiv').is(':visible')) ? document.getElementById('playlistslistdiv').hide() : document.getElementById('playlistslistdiv').show()\r\n        // } else {\r\n        //     document.getElementById('playlisttracksdiv').show()\r\n        //     document.getElementById('playlistslistdiv').show()\r\n        // }\r\n        return true\r\n    },\r\n\r\n    /** **********\r\n     * Lookups\r\n     ************/\r\n    showTracklist: function (uri) {\r\n        // showLoading(true)\r\n        // $(PLAYLIST_TABLE).empty()\r\n        // library.togglePlaylists()\r\n        // var tracks = getPlaylistTracks(uri).then(function (tracks) {\r\n        //     resultsToTables(tracks, PLAYLIST_TABLE, uri, 'return library.togglePlaylists();', true)\r\n        //     showLoading(false)\r\n        // })\r\n        // updatePlayIcons(uri, '', controls.getIconForAction())\r\n        // document.getElementById('playlistslist li a').each(function () {\r\n        //     $(this).removeClass('playlistactive')\r\n        //     if (this.id === uri) {\r\n        //         $(this).addClass('playlistactive')\r\n        //     }\r\n        // })\r\n        return false\r\n    },\r\n\r\n    showArtist: function (nwuri, mopidy) {\r\n        // document.getElementById('popupQueue').popup('close')\r\n        // document.getElementById('popupTracks').popup('close')\r\n        // document.getElementById('controlsmodal').popup('close')\r\n        // $(ARTIST_TABLE).empty()\r\n        //\r\n        // if (!nwuri.length || nwuri === 'undefined') {\r\n        //     return false\r\n        // }\r\n        //\r\n        // // TODO cache\r\n        //\r\n        // document.getElementById('h_artistname').html('')\r\n        // showLoading(true)\r\n        // mopidy.library.lookup({'uris': [nwuri]}).then(function (resultDict) {\r\n        //     var resultArr = resultDict[nwuri]\r\n        //     resultArr.uri = nwuri\r\n        //     processArtistResults(resultArr)\r\n        // }, console.error)\r\n        // switchContent('artists', nwuri)\r\n        // scrollToTop()\r\n        return false\r\n    },\r\n\r\n    showAlbum: function (uri, mopidy) {\r\n        // document.getElementById('popupQueue').popup('close')\r\n        // document.getElementById('popupTracks').popup('close')\r\n        // document.getElementById('controlsmodal').popup('close')\r\n        // $(ALBUM_TABLE).empty()\r\n        //\r\n        // if (!uri.length || uri === 'undefined') {\r\n        //     return false\r\n        // }\r\n        //\r\n        // // fill from cache\r\n        // var pl = getTracksFromUri(uri, true)\r\n        // if (pl.length > 0) {\r\n        //     albumTracksToTable(pl, ALBUM_TABLE, uri)\r\n        //     var albumname = getAlbum(pl)\r\n        //     var artistname = getArtist(pl)\r\n        //     document.getElementById('h_albumname').html(albumname)\r\n        //     document.getElementById('h_albumartist').html(artistname)\r\n        //     document.getElementById('coverpopupalbumname').html(albumname)\r\n        //     document.getElementById('coverpopupartist').html(artistname)\r\n        //     showLoading(false)\r\n        //     mopidy.library.lookup({'uris': [uri]}).then(function (resultDict) {\r\n        //         var resultArr = resultDict[uri]\r\n        //         resultArr.uri = uri\r\n        //         processAlbumResults(resultArr)\r\n        //     }, console.error)\r\n        // } else {\r\n        //     showLoading(true)\r\n        //     document.getElementById('h_albumname').html('')\r\n        //     document.getElementById('h_albumartist').html('')\r\n        //     mopidy.library.lookup({'uris': [uri]}).then(function (resultDict) {\r\n        //         var resultArr = resultDict[uri]\r\n        //         resultArr.uri = uri\r\n        //         processAlbumResults(resultArr)\r\n        //     }, console.error)\r\n        // }\r\n        // // show page\r\n        // switchContent('albums', uri)\r\n        // scrollToTop()\r\n        // return false\r\n    },\r\n\r\n    getSearchSchemes: function (searchBlacklist, mopidy) {\r\n        // var backendName\r\n        // var searchScheme = $.cookie('searchScheme')\r\n        // if (searchScheme) {\r\n        //     searchScheme = searchScheme.replace(/\"/g, '')\r\n        // } else {\r\n        //     searchScheme = 'all'\r\n        // }\r\n        // document.getElementById('selectSearchService').empty()\r\n        // document.getElementById('selectSearchService').append(new Option('All services', 'all'))\r\n        // mopidy.getUriSchemes().then(function (schemesArray) {\r\n        //     schemesArray = schemesArray.filter(function (el) {\r\n        //         return searchBlacklist.indexOf(el) < 0\r\n        //     })\r\n        //     for (var i = 0; i < schemesArray.length; i++) {\r\n        //         backendName = getMediaHuman(schemesArray[i])\r\n        //         if (!backendName) {\r\n        //             // No mapping defined, revert to just showing the scheme with first letter capitalized.\r\n        //             backendName = schemesArray[i].charAt(0).toUpperCase() + schemesArray[i].slice(1)\r\n        //         }\r\n        //         document.getElementById('selectSearchService').append(new Option(backendName, schemesArray[i]))\r\n        //     }\r\n        //     document.getElementById('selectSearchService').val(searchScheme)\r\n        //     document.getElementById('selectSearchService').selectmenu('refresh', true)\r\n        // }, console.error)\r\n    }\r\n};\r\n","import {artistsToString, CURRENT_PLAYLIST_TABLE, getScheme, getTracksFromUri, isStreamUri, STREAMS_PLAYLIST_NAME, STREAMS_PLAYLIST_SCHEME, TRACK_ACTIONS} from \"./functionsvars\";\r\nimport {updatePlayIcons} from \"./functionsvars\";\r\nimport {library} from \"./library\";\r\nimport {processCurrentposition} from \"./process_ws\";\r\nimport getState from \"./playerState\";\r\nimport {models, Mopidy} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport Track = models.Track;\r\n\r\n/**\r\n * 'onClick' handler for tracks that are rendered in a list.\r\n *\r\n * Adds tracks to current tracklist and starts playback if necessary.\r\n *\r\n * @param {string} action - The action to perform. Valid actions are:\r\n *                              PLAY_NOW: add the track at the current queue position and\r\n *                                        start playback immediately.\r\n *                              PLAY_NEXT: insert track after the reference track, if 'index'\r\n *                                         is provided, or after the current track otherwise.\r\n *                              ADD_THIS_BOTTOM: add track to bottom of tracklist.\r\n *                              ADD_ALL_BOTTOM: add all tracks in in the list to bottom of\r\n *                                              tracklist.\r\n *                              PLAY_ALL: clear tracklist and start playback of the track\r\n *                                        with URI provided in 'trackUri'.\r\n * @param {object} mopidy - The Mopidy.js object that should be used to communicate with the\r\n *                          Mopidy server.\r\n * @param {string} trackUri - (Optional) The URI of the specific track that the action should\r\n *                            be performed on. If no URI is provided then the 'data' attribute\r\n *                            of the popup DIV is assumed to contain the track URI.\r\n * @param {string} playlistUri - (Optional) The URI of the playlist containing the tracks\r\n *                               to be played. If no URI is provided then the 'list' attribute\r\n *                               of the popup DIV is assumed to contain the playlist URI.\r\n * @param {string} index - (Optional) The tracklist index of the reference track that the\r\n *                         action should be performed on. Defaults to the index of the currently\r\n *                         playing track.\r\n */\r\n\r\nexport function playTracks(action: TRACK_ACTIONS, mopidy: Mopidy, trackUri: string, playlistUri: string, index: number = null) {\r\n    //todo toast('Updating queue...');\r\n\r\n    trackUri = trackUri ||\r\n        (document.querySelector('#popupTracks') as HTMLElement).dataset.track ||\r\n        (document.querySelector('#popupQueue') as HTMLElement).dataset.track;\r\n    playlistUri = playlistUri ||\r\n        (document.querySelector('#popupTracks') as HTMLElement).dataset.list ||\r\n        (document.querySelector('#popupQueue') as HTMLElement).dataset.list;\r\n\r\n    action = getAction(action);\r\n\r\n    if (action === TRACK_ACTIONS.PLAY_ALL) {\r\n        getState().commands.core.tracklist.clear();\r\n    }\r\n\r\n    let trackUris = _getTrackURIsForAction(action, trackUri, playlistUri);\r\n    // Add the tracks and start playback if necessary.\r\n    switch (action) {\r\n        case TRACK_ACTIONS.PLAY_NOW:\r\n        case TRACK_ACTIONS.PLAY_NEXT:\r\n            getState().commands.core.tracklist.index().then(function (currentIndex) {\r\n                if (currentIndex === null && action === TRACK_ACTIONS.PLAY_NEXT) {\r\n                    // Tracklist is empty, start playing new tracks immediately.\r\n                    action = TRACK_ACTIONS.PLAY_NOW;\r\n                }\r\n                _addTrackAtIndex(action, mopidy, trackUris, currentIndex);\r\n            });\r\n            break;\r\n        case TRACK_ACTIONS.INSERT_AT_INDEX:\r\n            _addTrackAtIndex(action, mopidy, trackUris, index);\r\n            break;\r\n        case TRACK_ACTIONS.ADD_THIS_BOTTOM:\r\n\r\n        case TRACK_ACTIONS.ADD_ALL_BOTTOM:\r\n        case TRACK_ACTIONS.PLAY_ALL:\r\n            getState().commands.core.tracklist.add(undefined, -1, trackUris).then(function () {\r\n                if (action === TRACK_ACTIONS.PLAY_ALL) {  // Start playback of selected track immediately.\r\n                    getState().commands.core.tracklist.filter({criteria: {uri: [trackUri]}}).then(function (tlTracks) {\r\n                        getState().commands.core.playback.stop().then(function () {\r\n                            getState().commands.core.playback.play(null, tlTracks[0].tlid);\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n            break;\r\n        default:\r\n            throw new Error('Unexpected tracklist action identifier: ' + action)\r\n    }\r\n\r\n    if (action !== TRACK_ACTIONS.INSERT_AT_INDEX) {  // TODO: Add support for 'INSERT_AT_INDEX' to allow user to insert tracks in any playlist.\r\n        if (window[document.body.dataset.onTrackClick] === TRACK_ACTIONS.DYNAMIC) {\r\n            // Save last 'action' - will become default for future 'onClick' events\r\n            let previousAction =  TRACK_ACTIONS.ADD_ALL_BOTTOM; //todo $.cookie('onTrackClick');\r\n            if (typeof previousAction === 'undefined' || action !== previousAction) {\r\n                //todo $.cookie('onTrackClick', action, {expires: 365})\r\n                updatePlayIcons('', -1, getIconForAction(action));\r\n            }\r\n        }\r\n    }\r\n\r\n    // document.querySelector('#popupTracks').popup('close')\r\n    // document.querySelector('#popupQueue').popup('close')\r\n}\r\n\r\n/* Getter function for 'action' variable. Also checks config settings and cookies if required. */\r\nexport function getAction(action: TRACK_ACTIONS) {\r\n    if (action == TRACK_ACTIONS.UNDEFINED) {  // Action parameter not provided, use defaults\r\n        action = window[document.body.dataset.onTrackClick] as TRACK_ACTIONS;\r\n    }\r\n    if (action === TRACK_ACTIONS.DYNAMIC) {  // Re-use last action stored in cookie.\r\n        //todo action = $.cookie('onTrackClick') as TRACK_ACTIONS;\r\n        // @ts-ignore\r\n        if (action == TRACK_ACTIONS.UNDEFINED) {\r\n            action = TRACK_ACTIONS.PLAY_ALL;  // Backwards-compatible default value.\r\n        }\r\n    }\r\n    return action;\r\n}\r\n\r\n/* Retrieves the Font Awesome character for the given action. */\r\nexport function getIconForAction(action: TRACK_ACTIONS = TRACK_ACTIONS.UNDEFINED) {\r\n    action = getAction(action);\r\n\r\n    switch (action) {\r\n        case TRACK_ACTIONS.PLAY_ALL:\r\n            return 'fa fa-play-circle'\r\n        case TRACK_ACTIONS.PLAY_NOW:\r\n            return 'fa fa-play-circle-o'\r\n        case TRACK_ACTIONS.INSERT_AT_INDEX:\r\n            return 'fa fa-long-arrow-left'\r\n        case TRACK_ACTIONS.PLAY_NEXT:\r\n            return 'fa fa-level-down'\r\n        case TRACK_ACTIONS.ADD_THIS_BOTTOM:\r\n            return 'fa fa-plus-square-o'\r\n        case TRACK_ACTIONS.ADD_ALL_BOTTOM:\r\n            return 'fa fa-plus-square'\r\n    }\r\n}\r\n\r\n/* Retrieves the relevant track URIs for the given action. */\r\nexport function _getTrackURIsForAction(action: TRACK_ACTIONS, trackUri: string, playlistUri: string): string[] {\r\n    let trackUris: string[] = [];\r\n    // Fill 'trackUris', by determining which tracks should be added.\r\n    switch (action) {\r\n        case TRACK_ACTIONS.PLAY_NOW:\r\n        case TRACK_ACTIONS.PLAY_NEXT:\r\n        case TRACK_ACTIONS.INSERT_AT_INDEX:\r\n        case TRACK_ACTIONS.ADD_THIS_BOTTOM:\r\n            // Process single track\r\n            trackUris.push(trackUri)\r\n            break\r\n        case TRACK_ACTIONS.PLAY_ALL:\r\n        case TRACK_ACTIONS.ADD_ALL_BOTTOM:\r\n            // Process all tracks in playlist\r\n            trackUris = getTracksFromUri(playlistUri, false);\r\n            break\r\n    }\r\n    return trackUris;\r\n}\r\n\r\nexport function _addTrackAtIndex(action: TRACK_ACTIONS, mopidy: Mopidy, trackUris: string[], index: number = null) {\r\n    let pos = index;\r\n    if (pos === null) {\r\n        pos = 0;\r\n    } else {\r\n        pos += 1;\r\n    }\r\n\r\n    getState().commands.core.tracklist.add(undefined, pos, trackUris).then(function (tlTracks) {\r\n        if (action === TRACK_ACTIONS.PLAY_NOW) {  // Start playback immediately.\r\n            getState().commands.core.playback.stop().then(function () {\r\n                getState().commands.core.playback.play(null, tlTracks[0].tlid)\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\n/** ******************************************************\r\n * play an uri from the queue\r\n *********************************************************/\r\n\r\n/** *\r\n * Plays a Track from a Playlist.\r\n * @param tlid\r\n * @returns {boolean}\r\n */\r\nexport function playQueueTrack(tlid) {\r\n    // Stop directly, for user feedback\r\n\r\n    getState().commands.core.playback.stop();\r\n    // toast('Loading...')\r\n\r\n    tlid = tlid || (document.querySelector('#popupQueue') as HTMLElement).dataset.tlid;\r\n    getState().commands.core.playback.play(null, parseInt(tlid));\r\n    // document.querySelector('#popupQueue').popup('close')\r\n}\r\n\r\n/** *********************************\r\n *  remove a track from the queue  *\r\n ***********************************/\r\nexport function removeTrack(tlid, mopidy) {\r\n    // toast('Deleting...')\r\n\r\n    tlid = tlid || (document.querySelector('#popupQueue') as HTMLElement).dataset.tlid;\r\n    //todo: figure out how to pass the criteria in a type-safe way: getState().commands.core.tracklist.remove({criteria: {'tlid': [parseInt(tlid)]}});\r\n    // document.querySelector('#popupQueue').popup('close')\r\n}\r\n\r\nexport function clearQueue() {\r\n    getState().commands.core.tracklist.clear();\r\n    return false;\r\n}\r\n\r\nexport function checkDefaultButtonClick(key, parentElement: HTMLElement) {\r\n    // Click the default button on parentElement when the user presses the enter key.\r\n    if (key === 13) {\r\n        (parentElement.querySelector('button' + '[data-default-btn=\"true\"]') as HTMLElement).click();\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function showAddTrackPopup(tlid) {\r\n    // todo\r\n    // (document.querySelector('#addTrackInput') as HTMLInputElement).value = \"\";\r\n    // document.querySelector('#select-add').innerHTML = \"\";\r\n    // tlid = tlid || (document.querySelector('#popupQueue') as HTMLElement).dataset.tlid;\r\n    // if (typeof tlid !== 'undefined' && tlid !== '') {\r\n    //     // Store the tlid of the track after which we want to perform the insert\r\n    //     (document.querySelector('#popupAddTrack') as HTMLElement).dataset.tlid = (document.querySelector('#popupQueue') as HTMLElement).dataset.tlid;\r\n    //     document.querySelector('#popupAddTrack').one('popupafterclose', function (event, ui) {\r\n    //         // Ensure that popup attributes are reset when the popup is closed.\r\n    //         $(this).removeData('tlid')\r\n    //     })\r\n    //     let trackName = popupData[document.querySelector('#popupQueue').data('track')].name\r\n    //     document.querySelector('#select-add').append('<option value=\"6\" selected=\"selected\">Add Track Below \\'' + trackName + '\\'</option>')\r\n    // }\r\n    // if (typeof songdata.track.uri !== 'undefined' && songdata.track.uri !== '') {\r\n    //     document.querySelector('#getPlayingBtn').button('enable')\r\n    // } else {\r\n    //     document.querySelector('#getPlayingBtn').button('disable')\r\n    // }\r\n    //\r\n    // document.querySelector('#select-add').append('<option value=\"1\">Play Added Track Next</option>') // PLAY_NEXT\r\n    // document.querySelector('#select-add').append('<option value=\"2\">Add Track to Bottom of Queue</option>') // ADD_THIS_BOTTOM\r\n    // document.querySelector('#select-add').trigger('change')\r\n    //\r\n    // document.querySelector('#popupQueue').popup('close')\r\n    // document.querySelector('#popupAddTrack').popup('open')\r\n}\r\n\r\nexport function addTrack(trackUri: string, mopidy: Mopidy) {\r\n    let selection = parseInt((document.querySelector('#select-add') as HTMLInputElement).value);\r\n\r\n    if (selection === TRACK_ACTIONS.ADD_THIS_BOTTOM) {\r\n        addTrackToBottom(trackUri, mopidy);\r\n    } else if (selection === TRACK_ACTIONS.PLAY_NEXT) {\r\n        insertTrack(trackUri, mopidy);\r\n    } else if (selection === TRACK_ACTIONS.INSERT_AT_INDEX) {\r\n        let tlid = (document.querySelector('#popupAddTrack') as HTMLElement).dataset.tlid;\r\n        insertTrack(trackUri, mopidy, tlid);\r\n    }\r\n}\r\n\r\nexport function insertTrack(trackUri: string, mopidy: Mopidy, tlid: string = undefined) {\r\n    if (typeof tlid !== 'undefined' && tlid !== '') {\r\n        getState().commands.core.tracklist.index(null, parseInt(tlid)).then(function (index) {\r\n            playTracks(TRACK_ACTIONS.INSERT_AT_INDEX, mopidy, trackUri, CURRENT_PLAYLIST_TABLE, index)\r\n        })\r\n    } else {\r\n        // No tlid provided, insert after current track.\r\n        playTracks(TRACK_ACTIONS.PLAY_NEXT, mopidy, trackUri, CURRENT_PLAYLIST_TABLE)\r\n    }\r\n    // document.querySelector('#popupAddTrack').popup('close')\r\n    return false;\r\n}\r\n\r\nexport function addTrackToBottom(trackUri, mopidy) {\r\n    if (typeof trackUri === 'undefined' || trackUri === '') {\r\n        throw new Error('No track URI provided to add.')\r\n    }\r\n\r\n    playTracks(TRACK_ACTIONS.ADD_THIS_BOTTOM, mopidy, trackUri, CURRENT_PLAYLIST_TABLE);\r\n    // document.querySelector('#popupAddTrack').popup('close')\r\n    return false;\r\n}\r\n\r\nexport function showSavePopup() {\r\n    getState().commands.core.tracklist.getTracks().then(function (tracks) {\r\n        if (tracks.length > 0) {\r\n            (document.querySelector('#saveinput') as HTMLInputElement).value = '';\r\n            // document.querySelector('#popupSave').popup('open')\r\n        }\r\n    })\r\n}\r\n\r\nexport function saveQueue() {\r\n    getState().commands.core.tracklist.getTracks().then(function (tracks) {\r\n        let playlistName = (document.querySelector('#saveinput') as HTMLInputElement).value.trim();\r\n        if (playlistName !== null && playlistName !== '') {\r\n            getPlaylistByName(playlistName, 'm3u', false).then(function (exists) {\r\n                if (exists) {\r\n                    // document.querySelector('#popupSave').popup('close')\r\n                    // document.querySelector('#popupOverwrite').popup('open')\r\n                    (document.querySelector('#overwriteConfirmBtn') as HTMLElement).click = () => {\r\n                        initSave(playlistName, tracks);\r\n                    };\r\n                } else {\r\n                    initSave(playlistName, tracks)\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return false;\r\n}\r\n\r\nexport function initSave(playlistName: string, tracks) {\r\n    // document.querySelector('#popupOverwrite').popup('close')\r\n    // document.querySelector('#popupSave').popup('close')\r\n    (document.querySelector('#saveinput') as HTMLInputElement).value = '';\r\n    // toast('Saving...')\r\n    getState().commands.core.playlists.create(playlistName, 'm3u')\r\n        .then(function (playlist) {\r\n            playlist.tracks.push(...tracks);\r\n            // playlist.tracks = tracks;\r\n            getState().commands.core.playlists.save(playlist).then();\r\n            });\r\n}\r\n\r\nexport function showInfoPopup(uri, popupId, mopidy) {\r\n    // showLoading(true)\r\n    // let trackUri = uri || $(popupId).data('track')\r\n    // if (popupId && popupId.length > 0) {\r\n    //     $(popupId).popup('close')\r\n    // }\r\n    // document.querySelector('#popupShowInfo tbody').empty()\r\n    //\r\n    // commands.core.library.lookup({'uris': [trackUri]}).then(function (resultDict) {\r\n    //     let uri = Object.keys(resultDict)[0]\r\n    //     let track = resultDict[uri][0]\r\n    //     let html = ''\r\n    //     let rowTemplate = '<tr><td class=\"label\">{label}:</td><td id=\"{label}-cell\">{text}</td></tr>'\r\n    //     let row = {'label': '', 'text': ''}\r\n    //\r\n    //     row.label = 'Name'\r\n    //     if (track.name) {\r\n    //         row.text = track.name\r\n    //     } else {\r\n    //         row.text = '(Not available)'\r\n    //     }\r\n    //     html += stringFromTemplate(rowTemplate, row)\r\n    //\r\n    //     row.label = 'Album'\r\n    //     if (track.album && track.album.name) {\r\n    //         row.text = track.album.name\r\n    //     } else {\r\n    //         row.text = '(Not available)'\r\n    //     }\r\n    //     html += stringFromTemplate(rowTemplate, row)\r\n    //\r\n    //     let artists = artistsToString(track.artists)\r\n    //     // Fallback to album artists.\r\n    //     if (artists.length === 0 && track.album && track.album.artists) {\r\n    //         artists = artistsToString(track.album.artists)\r\n    //     }\r\n    //\r\n    //     if (artists.length > 0) {\r\n    //         row.label = 'Artist'\r\n    //         if (track.artists && track.artists.length > 1 || track.album && track.album.artists && track.album.artists.length > 1) {\r\n    //             row.label += 's'\r\n    //         }\r\n    //         row.text = artists\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     let composers = artistsToString(track.composers)\r\n    //     if (composers.length > 0) {\r\n    //         row.label = 'Composer'\r\n    //         if (track.composers.length > 1) {\r\n    //             row.label += 's'\r\n    //         }\r\n    //         row.text = composers\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     let performers = artistsToString(track.performers)\r\n    //     if (performers.length > 0) {\r\n    //         row.label = 'Performer'\r\n    //         if (track.performers.length > 1) {\r\n    //             row.label += 's'\r\n    //         }\r\n    //         row.text = performers\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.genre) {\r\n    //         row = {'label': 'Genre', 'text': track.genre}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.track_no) {\r\n    //         row = {'label': 'Track #', 'text': track.track_no}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.disc_no) {\r\n    //         row = {'label': 'Disc #', 'text': track.disc_no}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.date) {\r\n    //         row = {'label': 'Date', 'text': new Date(track.date).toLocaleString()}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.length) {\r\n    //         row = {'label': 'Length', 'text': timeFromSeconds(track.length / 1000)}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.bitrate) {\r\n    //         row = {'label': 'Bitrate', 'text': track.bitrate}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.comment) {\r\n    //         row = {'label': 'Comment', 'text': track.comment}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.musicbrainz_id) {\r\n    //         row = {'label': 'MusicBrainz ID', 'text': track.musicbrainz_id}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     if (track.last_modified) {\r\n    //         row = {'label': 'Modified', 'text': track.last_modified}\r\n    //         html += stringFromTemplate(rowTemplate, row)\r\n    //     }\r\n    //\r\n    //     rowTemplate = '<tr><td class=\"label label-center\">{label}:</td><td><input type=\"text\" id=\"uri-input\" value=\"{text}\"></input></td></tr>'\r\n    //     row = {'label': 'URI', 'text': uri}\r\n    //     html += stringFromTemplate(rowTemplate, row)\r\n    //\r\n    //     document.querySelector('#popupShowInfo tbody').append(html)\r\n    //\r\n    //     showLoading(false)\r\n    //     document.querySelector('#popupShowInfo').popup('open')\r\n    //     if (!isMobile) {\r\n    //         // Set focus and select URI text on desktop systems (don't want the keyboard to pop up automatically on mobile devices)\r\n    //         document.querySelector('#popupShowInfo #uri-input').focus()\r\n    //         document.querySelector('#popupShowInfo #uri-input').select()\r\n    //     }\r\n    // }, console.error)\r\n    return false\r\n}\r\n\r\nexport function refreshPlaylists() {\r\n    getState().commands.core.playlists.refresh().then(function () {\r\n        getState().playlists = {};\r\n        (document.querySelector('#playlisttracksdiv') as HTMLElement).style.display = 'none';\r\n        (document.querySelector('#playlistslistdiv') as HTMLElement).style.display = 'block';\r\n    })\r\n    return false;\r\n}\r\n\r\nexport function refreshLibrary() {\r\n    let uri = (document.querySelector('#refreshLibraryBtn') as HTMLElement).dataset.url;\r\n    getState().commands.core.library.refresh(uri).then(function () {\r\n        library.getBrowseDir(uri);\r\n    })\r\n    return false;\r\n}\r\n\r\n/** ***********\r\n *  Buttons  *\r\n *************/\r\n\r\nexport function doShuffle() {\r\n    getState().commands.core.playback.stop();\r\n    getState().commands.core.tracklist.shuffle();\r\n    getState().commands.core.playback.play();\r\n}\r\n\r\n/* Toggle state of play button */\r\nexport function setPlayState(nwplay) {\r\n    // if (nwplay) {\r\n    //     document.querySelector('#btplayNowPlaying >i').classList.remove('fa-play');\r\n    //     document.querySelector('#btplayNowPlaying >i').classList.add('fa-pause');\r\n    //     document.querySelector('#btplayNowPlaying').setAttribute('title', 'Pause');\r\n    //     (document.querySelector('#btplay >i') as HTMLElement).classList.remove('fa-play');\r\n    //     (document.querySelector('#btplay >i') as HTMLElement).classList.add('fa-pause');\r\n    //     document.querySelector('#btplay').setAttribute('title', 'Pause');\r\n    //     getState().commands.core.playback.getTimePosition().then(processCurrentposition, console.error)\r\n    //     getState().syncedProgressTimer.start();\r\n    // } else {\r\n    //     document.querySelector('#btplayNowPlaying >i').classList.remove('fa-pause');\r\n    //     document.querySelector('#btplayNowPlaying >i').classList.add('fa-play');\r\n    //     document.querySelector('#btplayNowPlaying').setAttribute('title', 'Play');\r\n    //     document.querySelector('#btplay >i').classList.remove('fa-pause');\r\n    //     document.querySelector('#btplay >i').classList.add('fa-play');\r\n    //     document.querySelector('#btplay').setAttribute('title', 'Play');\r\n    //     getState().syncedProgressTimer.stop();\r\n    // }\r\n    // getState().play = nwplay;\r\n}\r\n\r\n// play or pause\r\nexport function doPlay() {\r\n    setPlayState(!getState().play);\r\n}\r\n\r\nexport function doPrevious() {\r\n    // toast('Playing previous track...')\r\n    getState().commands.core.playback.previous();\r\n}\r\n\r\nexport function doNext() {\r\n    // toast('Playing next track...')\r\n    getState().commands.core.playback.next();\r\n}\r\n\r\nexport function backbt() {\r\n    history.back();\r\n    return false;\r\n}\r\n\r\n/** ***********\r\n *  Options  *\r\n *************/\r\nexport function setTracklistOption(name: string, new_value: boolean) {\r\n    if (!new_value) {\r\n        document.querySelector('#' + name + 'bt').setAttribute('style', 'color:#2489ce');\r\n    } else {\r\n        document.querySelector('#' + name + 'bt').setAttribute('style', 'color:#66DD33');\r\n    }\r\n    return new_value;\r\n}\r\n\r\nexport function doRandom() {\r\n    getState().commands.core.tracklist.setRandom(!getState().random).then();\r\n}\r\n\r\nexport function doRepeat() {\r\n    getState().commands.core.tracklist.setRepeat(!getState().repeat).then();\r\n}\r\n\r\nexport function doConsume() {\r\n    getState().commands.core.tracklist.setConsume(!getState().consume).then();\r\n}\r\n\r\nexport function doSingle() {\r\n    getState().commands.core.tracklist.setSingle(!getState().single).then();\r\n}\r\n\r\n/** *********************************************\r\n * Track Slider                                *\r\n * Use a timer to prevent looping of commands  *\r\n ***********************************************/\r\nexport function doSeekPos(value) {\r\n    if (!getState().positionChanging) {\r\n        getState().positionChanging = value; //todo: number or boolean\r\n        getState().commands.core.playback.seek(Math.round(value)).then(function () {\r\n            getState().positionChanging = null;\r\n        })\r\n    }\r\n}\r\n\r\nexport function setPosition(pos) {\r\n    if (!getState().positionChanging && (document.querySelector('#trackslider') as HTMLInputElement).value !== pos) {\r\n        getState().syncedProgressTimer.set(pos);\r\n    }\r\n}\r\n\r\n/** *********************************************\r\n * Volume slider                               *\r\n * Use a timer to prevent looping of commands  *\r\n ***********************************************/\r\n\r\n//todo separate the controls gui setters from the send functions?\r\nexport function setMute(nwmute) {\r\n    // if (mute !== nwmute) {\r\n    //     mute = nwmute\r\n    //     if (mute) {\r\n    //         document.querySelector('#mutebt').attr('class', 'fa fa-volume-off')\r\n    //     } else {\r\n    //         document.querySelector('#mutebt').attr('class', 'fa fa-volume-up')\r\n    //     }\r\n    // }\r\n}\r\n\r\nexport function doMute() {\r\n    getState().commands.core.mixer.setMute(!getState().mute);\r\n}\r\n\r\n/** **********\r\n *  Stream  *\r\n ************/\r\nexport function streamPressed(key) {\r\n    if (key === 13) {\r\n        playStreamUri();\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function playStreamUri(uri: string = undefined) {\r\n    // value of name is based on the passing of an uri as a parameter or not\r\n    let nwuri = uri || (document.querySelector('#streamuriinput') as HTMLInputElement).value.trim();\r\n    let service = (document.querySelector('#selectstreamservice') as HTMLInputElement).value;\r\n    if (!uri && service) {\r\n        nwuri = service + ':' + nwuri\r\n    }\r\n    // toast('Playing...')\r\n    // stop directly, for user feedback\r\n    getState().commands.core.playback.stop()\r\n    // hide ios/android keyboard\r\n    // document.activeElement.blur()\r\n    clearQueue();\r\n    document.querySelector('input').blur()\r\n    getState().commands.core.tracklist.add(undefined, null, [nwuri]);\r\n    getState().commands.core.playback.play();\r\n    return false;\r\n}\r\n\r\nexport function getCurrentlyPlaying(uriInput, nameInput) {\r\n    (document.querySelector('#' + uriInput) as HTMLInputElement).value = getState().songdata.track.uri;\r\n    let name = getState().songdata.track.name\r\n    if (getState().songdata.track.artists) {\r\n        let artistStr = artistsToString(getState().songdata.track.artists);\r\n        if (artistStr) {\r\n            name = artistStr + ' - ' + name;\r\n        }\r\n    }\r\n    (document.querySelector('#' + nameInput) as HTMLInputElement).value = name;\r\n    return true;\r\n}\r\n\r\nexport function getUriSchemes() {\r\n    getState().uriSchemes = {};\r\n    return getState().commands.core.getUriSchemes().then(function (schemes) {\r\n        for (let i = 0; i < schemes.length; i++) {\r\n            getState().uriSchemes[schemes[i].toLowerCase()] = true;\r\n        }\r\n    })\r\n}\r\n\r\nexport async function getPlaylistByName(name, scheme, create: boolean) {\r\n    let uri_scheme = scheme || '';\r\n    let uri = '';\r\n    if (uri_scheme && !getState().uriSchemes[uri_scheme]) {\r\n        //todo return Mopidy.when(false)\r\n        throw new Error(\"Dunno...\");\r\n    }\r\n    let plists = await getState().commands.core.playlists.asList().catch(console.error.bind(console));\r\n    for (let i = 0; i < plists.length; i++) {\r\n        if ((plists[i].name === name) && (uri_scheme === '' || getScheme(plists[i].uri) === uri_scheme)) {\r\n            return plists[i];\r\n        }\r\n    }\r\n    if (create) {\r\n        let pList = await getState().commands.core.playlists.create(name, uri_scheme);\r\n        console.log(\"Created playlist '%s'\", pList.name);\r\n        return pList;\r\n        }\r\n    throw new Error(\"Can't find playist \"+ name);\r\n    // return Mopidy.when(false)\r\n}\r\n\r\nexport function getPlaylistFull(uri) {\r\n    return getState().commands.core.playlists.lookup(uri).then(function (pl) {\r\n        getState().playlists[uri] = pl;\r\n        return pl;\r\n    })\r\n}\r\n\r\nexport function getFavourites() {\r\n    return getPlaylistByName(\r\n        STREAMS_PLAYLIST_NAME,\r\n        STREAMS_PLAYLIST_SCHEME,\r\n        true\r\n    ).then(function (playlist) {\r\n        if (playlist) {\r\n            return getPlaylistFull(playlist.uri);\r\n        }\r\n        // return Mopidy.when(false)\r\n        return;\r\n    })\r\n}\r\n\r\nexport function addToFavourites(newTracks: Track[]) {\r\n    getFavourites().catch(console.error.bind(console)).then(function (favourites) {\r\n        if (favourites) {\r\n            if (favourites.tracks) {\r\n                favourites.tracks.push(...newTracks);\r\n            } else {\r\n                favourites.tracks.length = 0;\r\n                favourites.tracks.push(...newTracks);\r\n            }\r\n            getState().commands.core.playlists.save(favourites).then(function (s) {\r\n                showFavourites();\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\nexport function addFavourite(uri, name) {\r\n    uri = uri || (document.querySelector('#streamuriinput') as  HTMLInputElement).value.trim();\r\n    name = name || (document.querySelector('#streamnameinput') as HTMLInputElement).value.trim();\r\n    getState().commands.core.library.lookup([uri]).then(function (results) {\r\n        let newTracks = results[uri];\r\n        if (newTracks.length === 1) {\r\n            // TODO: Supporting adding an entire playlist?\r\n            if (name) {\r\n                // @ts-ignore todo: name is read-only. Is there a clean way to do this?\r\n                newTracks[0].name = name // User overrides name.\r\n            }\r\n            addToFavourites(newTracks);\r\n        } else {\r\n            if (newTracks.length === 0) {\r\n                console.log('No tracks to add');\r\n            } else {\r\n                console.log('Too many tracks (%d) to add', newTracks.length);\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nexport function showDeleteStreamPopup(index) {\r\n    getFavourites().then(function (favourites) {\r\n        if (favourites && favourites.tracks && index < favourites.tracks.length) {\r\n            let name = favourites.tracks[index].name\r\n            document.querySelector('.popupStreamName').innerHTML = favourites.tracks[index].name;\r\n            (document.querySelector('#popupConfirmDelete') as HTMLElement).dataset.index =  index;\r\n            // document.querySelector('#popupConfirmDelete').popup('open')\r\n        }\r\n    })\r\n}\r\n\r\nexport function deleteFavourite(index) {\r\n    index = index || (document.querySelector('#popupConfirmDelete') as HTMLElement).dataset.index;\r\n    getFavourites().then(function (favourites) {\r\n        if (favourites && favourites.tracks && index < favourites.tracks.length) {\r\n            favourites.tracks.splice(index, 1)\r\n            getState().commands.core.playlists.save(favourites).then(function () {\r\n                showFavourites();\r\n            });\r\n            // document.querySelector('#popupConfirmDelete').popup('close')\r\n        }\r\n    })\r\n}\r\n\r\nexport function showFavourites() {\r\n    document.querySelector('#streamuristable').innerHTML = \"\";\r\n    getFavourites().then(function (favourites) {\r\n        if (!favourites) {\r\n            return;\r\n        }\r\n        let tmp = '';\r\n\r\n        // $.cookie.json = true\r\n        // if ($.cookie('streamUris')) {\r\n        //     tmp = '<button class=\"btn\" style=\"padding: 5px; width: 100%\" type=\"button\" onclick=\"return upgradeStreamUrisToFavourites();\">Convert StreamUris</button>'\r\n        // }\r\n        if (favourites.tracks) {\r\n            let child = ''\r\n            for (let i = 0; i < favourites.tracks.length; i++) {\r\n                child =\r\n                    '<li><span class=\"ui-icon ui-icon-delete ui-icon-shadow\" style=\"float:right; margin: .5em; margin-top: .8em;\">' +\r\n                    '<a href=\"#\" onclick=\"return showDeleteStreamPopup(' + i + ');\">&nbsp;</a></span>' +\r\n                    '<i class=\"fa fa-rss\" style=\"float: left; padding: .5em; padding-top: 1em;\"></i>' +\r\n                    ' <a style=\"margin-left: 20px\" href=\"#\" onclick=\"return playStreamUri(\\'' + favourites.tracks[i].uri + '\\');\">'\r\n                child += '<h1>' + favourites.tracks[i].name + '</h1></a></li>'\r\n                tmp += child\r\n            }\r\n        } else {\r\n            tmp = '<span style=\"display:table; margin:0 auto;\">Your saved favourite streams/tracks will be shown here</span>'\r\n        }\r\n        document.querySelector('#streamuristable').innerHTML = tmp;\r\n    })\r\n}\r\n\r\n// TODO: Remove this upgrade path in next major release.\r\nexport function upgradeStreamUrisToFavourites() {\r\n    // toast('Converting streamUris...')\r\n    // $.cookie.json = true\r\n    // let streamUris = $.cookie('streamUris') // Read the cookie.\r\n    // if (streamUris) {\r\n    //     let uris = [] // Prepare a list of uris to lookup.\r\n    //     for (let key in streamUris) {\r\n    //         let rs = streamUris[key]\r\n    //         if (rs) {\r\n    //             uris.push(rs[1])\r\n    //         }\r\n    //     }\r\n    //     commands.core.library.lookup({'uris': uris}).then(function (results) {\r\n    //         let tracks = [] // Prepare a list of tracks to add.\r\n    //         for (let key in streamUris) {\r\n    //             let rs = streamUris[key]\r\n    //             if (rs) {\r\n    //                 let track = results[rs[1]][0]\r\n    //                 if (track) {\r\n    //                     track.name = rs[0] || track.name // Use custom name if provided.\r\n    //                     tracks.push(track)\r\n    //                 } else {\r\n    //                     console.log('Skipping unplayable streamUri ' + rs[1])\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //         addToFavourites(tracks)\r\n    //         $.cookie('streamUris', null) // Delete the cookie now we're done.\r\n    //         console.log(tracks.length + ' streamUris added to favourites')\r\n    //     })\r\n    // } else {\r\n    //     console.log('No streamUris cookie found')\r\n    // }\r\n}\r\n","import * as images from \"./images\";\r\nimport {processPlaylistItems} from \"./process_ws\";\r\nimport * as controls from \"./controls\";\r\nimport getState from \"./playerState\";\r\nimport {models} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport TlTrack = models.TlTrack;\r\n\r\n// interface ArtistInfo {\r\n//     name: string;\r\n//     uri: string;\r\n// }\r\n//\r\n// interface AlbumInfo {\r\n//     name: string;\r\n//     uri: string;\r\n// }\r\n//\r\n// interface TrackInfo {\r\n//     name: string;\r\n//     artists: ArtistInfo[];\r\n//     length: number;\r\n//     uri: string;\r\n//     album: AlbumInfo;\r\n// }\r\n\r\ninterface StreamInfo {\r\n    tlid: number;\r\n    track: TlTrack;\r\n    stream: string;\r\n}\r\n\r\n\r\n// constants\r\nexport const STREAMS_PLAYLIST_NAME = '[Radio Streams]';\r\nexport const STREAMS_PLAYLIST_SCHEME = 'm3u';\r\nexport const HOSTNAME = document.body.dataset.hostname;\r\nexport const ARTIST_TABLE = '#artiststable';\r\nexport const ALBUM_TABLE = '#albumstable';\r\nexport const BROWSE_TABLE = '#browsetable';\r\nexport const PLAYLIST_TABLE = '#playlisttracks';\r\nexport const CURRENT_PLAYLIST_TABLE = '#currenttable';\r\nexport const SEARCH_ALL_TABLE = '#allresulttable';\r\nexport const SEARCH_ALBUM_TABLE = '#albumresulttable';\r\nexport const SEARCH_ARTIST_TABLE = '#artistresulttable';\r\nexport const SEARCH_TRACK_TABLE = '#trackresulttable';\r\n\r\nconst URI_SCHEME = 'mbw';\r\n\r\nexport enum TRACK_ACTIONS {\r\n    UNDEFINED = -1,\r\n    PLAY_NOW = 0,\r\n    PLAY_NEXT = 1,\r\n    ADD_THIS_BOTTOM = 2,\r\n    ADD_ALL_BOTTOM = 3,\r\n    PLAY_ALL = 4,\r\n    DYNAMIC = 5,\r\n    INSERT_AT_INDEX = 6,\r\n}\r\n\r\n// the first part of Mopidy extensions which serve radio streams\r\nlet radioExtensionsList = ['somafm', 'tunein', 'dirble', 'audioaddict']\r\n\r\nlet uriClassList = [\r\n    ['spotify', 'fa-spotify'],\r\n    ['spotifytunigo', 'fa-spotify'],\r\n    ['spotifyweb', 'fa-spotify'],\r\n    ['local', 'fa-file-sound-o'],\r\n    ['file', 'fa-file-sound-o'],\r\n    ['m3u', 'fa-file-sound-o'],\r\n    ['podcast', 'fa-rss-square'],\r\n    ['podcast+file', 'fa-rss-square'],\r\n    ['podcast+itunes', 'fa-apple'],\r\n    ['dirble', 'fa-microphone'],\r\n    ['tunein', 'fa-headphones'],\r\n    ['soundcloud', 'fa-soundcloud'],\r\n    ['sc', 'fa-soundcloud'],\r\n    ['gmusic', 'fa-google'],\r\n    ['internetarchive', 'fa-university'],\r\n    ['somafm', 'fa-flask'],\r\n    ['youtube', 'fa-youtube'],\r\n    ['yt', 'fa-youtube'],\r\n    ['audioaddict', 'fa-bullhorn'],\r\n    ['subsonic', 'fa-folder-open']\r\n]\r\n\r\n// TODO: It should be possible to retrieve a user-friendly name for a given Mopidy scheme dynamically by\r\n//       calling mopidy.library.browse() on the root dir:\r\n//       1. each backend contained in the result will have a 'name' attribute that can be shown as-is in the UI.\r\n//       2. the URI prefix of the backend result should === mopidy.getUriSchemes(), which can be used for the mapping.\r\n//       3. only backends that cannot be 'browsed' (e.g. youtube) should have a static mapping defined here.\r\nlet uriHumanList = [\r\n    ['spotify', 'Spotify'],\r\n    ['spotifytunigo', 'Spotify browse'],\r\n    ['spotifyweb', 'Spotify browse'],\r\n    ['local', 'Local media'],\r\n    ['m3u', 'Local playlists'],\r\n    ['podcast', 'Podcasts'],\r\n    ['podcast+itunes', 'iTunes Store: Podcasts'],\r\n    ['dirble', 'Dirble'],\r\n    ['tunein', 'TuneIn'],\r\n    ['soundcloud', 'SoundCloud'],\r\n    ['gmusic', 'Google Music'],\r\n    ['internetarchive', 'Internet Archive'],\r\n    ['somafm', 'Soma FM'],\r\n    ['youtube', 'YouTube'],\r\n    ['audioaddict', 'AudioAddict'],\r\n    ['subsonic', 'Subsonic']\r\n]\r\n\r\n// List of Mopidy URI schemes that should not be searched directly.\r\n// Also blacklists 'yt' in favour of using the other 'youtube' supported scheme.\r\nexport const searchBlacklist = [\r\n    'file',\r\n    'http',\r\n    'https',\r\n    'mms',\r\n    'rtmp',\r\n    'rtmps',\r\n    'rtsp',\r\n    'yt'\r\n]\r\n\r\n// List of known audio file extensions\r\n// TODO: consider querying GStreamer for supported audio formats - see:https://discuss.mopidy.com/t/supported-codecs-file-formats/473\r\nconst VALID_AUDIO_EXT = [\r\n    'aa', 'aax',  // Audible.com\r\n    'aac',  // Advanced Audio Coding format\r\n    'aiff',  // Apple\r\n    'au',  // Sun Microsystems\r\n    'flac',  // Free Lossless Audio Codec\r\n    'gsm',\r\n    'iklax',\r\n    'ivs',\r\n    'm4a',\r\n    'm4b',\r\n    'm4p',\r\n    'mp3',\r\n    'mpc',  // Musepack\r\n    'ogg', 'oga', 'mogg',  // Ogg-Vorbis\r\n    'opus',  // Internet Engineering Task Force (IETF)\r\n    'ra', 'rm',  // RealAudio\r\n    'raw',\r\n    'tta',  // True Audio\r\n    'vox',\r\n    'wav',\r\n    'wma',  // Microsoft\r\n    'wv',\r\n    'webm'  // HTML5 video\r\n]\r\n\r\nfunction scrollToTop () {\r\n    //todo\r\n    // $('body,html').animate({\r\n    //     scrollTop: 0\r\n    // }, 250)\r\n}\r\n\r\nexport function scrollToTracklist () {\r\n    //todo\r\n    // let divtop = $('#playlisttracksdiv').offset().top - 120\r\n    // $('body,html').animate({\r\n    //     scrollTop: divtop\r\n    // }, 250)\r\n}\r\n\r\n// A hack to find the name of the first artist of a playlist. this is not yet returned by mopidy\r\n// does not work wel with multiple artists of course\r\nexport function getArtist (pl) {\r\n    for (let i = 0; i < pl.length; i++) {\r\n        for (let j = 0; j < pl[i].artists.length; j++) {\r\n            if (pl[i].artists[j].name !== '') {\r\n                return pl[i].artists[j].name\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// A hack to find the first album of a playlist. this is not yet returned by mopidy\r\nexport function getAlbum (pl) {\r\n    for (let i = 0; i < pl.length; i++) {\r\n        if (pl[i].album.name !== '') {\r\n            return pl[i].album.name\r\n        }\r\n    }\r\n}\r\n\r\nexport function artistsToString (artists, max = 3) {\r\n    let result = '';\r\n    if (artists && artists.length > 0) {\r\n        for (let i = 0; i < artists.length && i < max; i++) {\r\n            if (artists[i].name) {\r\n                if (i > 0) {\r\n                    result += ', ';\r\n                }\r\n                result += artists[i].name;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/** ******************************************************\r\n * break up results and put them in album tables\r\n *********************************************************/\r\nexport function albumTracksToTable (pl, target, uri) {\r\n    let track, previousTrack, nextTrack;\r\n    let html = '';\r\n    document.querySelector(target).innerHTML = \"\";\r\n    document.querySelector(target).attr('data', uri);\r\n    for (let i = 0; i < pl.length; i++) {\r\n        previousTrack = track || undefined;\r\n        nextTrack = i < pl.length - 1 ? pl[i + 1] : undefined;\r\n        track = pl[i];\r\n        getState().popupData[track.uri] = track;\r\n        html += renderSongLi(previousTrack, track, nextTrack, uri, '', target, i, pl.length);\r\n    }\r\n    document.querySelector(target).append(html);\r\n    updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction());\r\n}\r\n\r\nexport function renderSongLi (previousTrack, track, nextTrack, uri, tlid, target, currentIndex, listLength) {\r\n    let tlidParameter = '';\r\n    let onClick = '';\r\n    let html = '';\r\n    track.name = validateTrackName(track, currentIndex);\r\n    // Streams\r\n    if (track.length === -1) {\r\n        html += '<li class=\"albumli\"><a href=\"#\"><h1><i class=\"' + getMediaClass(track) + '\"></i> ' + track.name + ' [Stream]</h1></a></li>';\r\n        return html;\r\n    }\r\n\r\n    if (target === CURRENT_PLAYLIST_TABLE && typeof tlid === 'number' && tlid >= 0) {  // Current queue: Show popup menu icon. onClick plays track.\r\n        tlidParameter = '\\',\\'' + tlid;\r\n        onClick = 'return controls.playQueueTrack(' + tlid + ');';\r\n    } else {  // All other tracklist: Show default action icon. onClick performs default action\r\n        onClick = 'return controls.playTracks(\\'\\', mopidy, \\'' + track.uri + '\\', \\'' + uri + '\\');';\r\n    }\r\n\r\n    html += '<li class=\"song albumli\" id=\"' + getUniqueId(target, track.uri) + '\" tlid=\"' + tlid + '\">';\r\n    if (isPlayable(track)) {\r\n        // Show popup icon for audio files or 'tracks' of other scheme types\r\n        html += '<a href=\"#\" class=\"moreBtn\" onclick=\"return popupTracks(event, \\'' + uri + '\\',\\'' + track.uri + tlidParameter + '\\');\">' +\r\n        '<i class=\"fa fa-play-circle-o\"></i></a>';\r\n    }\r\n    html += '<a href=\"#\" onclick=\"' + onClick + '\"><h1><i class=\"' + getMediaClass(track) + '\"></i> ' + track.name + '</h1>';\r\n\r\n    if (listLength === 1 || (!hasSameAlbum(previousTrack, track) && !hasSameAlbum(track, nextTrack))) {\r\n        html += renderSongLiAlbumInfo(track);\r\n    }\r\n    html += '</a></li>';\r\n    return html;\r\n}\r\n\r\n/* Tracklist renderer for track artist and album name. */\r\nexport function renderSongLiAlbumInfo (track, target: string = undefined) {\r\n    let html = renderSongLiTrackArtists(track);\r\n    if (track.album && track.album.name) {\r\n        html += ' - <em>' + track.album.name + '</em></p>';\r\n    }\r\n    if (typeof target !== 'undefined' && target.length > 0) {\r\n        target = getUniqueId(target, track.uri, true);\r\n        document.querySelector(target).querySelectorAll('a')[1].append(html);\r\n    }\r\n    return html;\r\n}\r\n\r\n/* Tracklist renderer for track artist information. */\r\nfunction renderSongLiTrackArtists (track) {\r\n    let html = ''\r\n    if (track.artists) {\r\n        for (let i = 0; i < track.artists.length; i++) {\r\n            html += track.artists[i].name\r\n            html += (i === track.artists.length - 1) ? '' : ' / '\r\n            // Stop after 3\r\n            if (i > 2) {\r\n                html += '...'\r\n                break\r\n            }\r\n        }\r\n    }\r\n    return html\r\n}\r\n\r\n/* Tracklist renderer to insert dividers between albums. */\r\nexport function renderSongLiDivider (previousTrack, track, nextTrack, target) {\r\n    // let html = ''\r\n    // let imageID\r\n    // // Render differently if part of an album.\r\n    // if (!hasSameAlbum(previousTrack, track) && hasSameAlbum(track, nextTrack)) {\r\n    //     // Large divider with album cover.\r\n    //     let showAlbum = '';\r\n    //     if (typeof track.album.uri !== 'undefined') {\r\n    //         showAlbum = 'onclick=\"return library.showAlbum(\\'' + track.album.uri + '\\', mopidy);\"'\r\n    //     }\r\n    //     html +=\r\n    //         '<li class=\"albumdivider\"><a href=\"#\" ' + showAlbum + '>' +\r\n    //         '<img id=\"' + getUniqueId(target + '-cover', track.uri) + '\" class=\"artistcover\" width=\"30\" height=\"30\"/>' +\r\n    //         '<h1>' + track.album.name + '</h1><p>' +\r\n    //         renderSongLiTrackArtists(track) + '</p></a></li>'\r\n    //     // The element ID to populate with an album cover.\r\n    //     imageID = getUniqueId(target + '-cover', track.uri, true)\r\n    // } else if (previousTrack && !hasSameAlbum(previousTrack, track)) {\r\n    //     // Small divider\r\n    //     html += '<li class=\"smalldivider\"> &nbsp;</li>'\r\n    // }\r\n    // if (html.length > 0 && typeof target !== 'undefined' && target.length > 0) {\r\n    //     target = getUniqueId(target, track.uri, true)\r\n    //     document.querySelector(target).before(html);\r\n    // }\r\n    // return [html, imageID];\r\n}\r\n\r\nexport function renderSongLiBackButton (results, target, onClick, optional = undefined) {\r\n    if (onClick && onClick.length > 0) {\r\n        if (!results || results.length === 0) {\r\n            document.querySelector(target).innerHTML= \"\";\r\n            document.querySelector(target).append(\r\n                '<li class=\"song albumli\"><a href=\"#\" onclick=\"' + onClick + '\"><h1><i></i>No tracks found...</h1></a></li>'\r\n            );\r\n        }\r\n        let opt = '';\r\n        if (optional) {\r\n            opt = ' backnav-optional';\r\n        }\r\n        document.querySelector(target).prepend(\r\n            '<li class=\"backnav' + opt + '\"><a href=\"#\" onclick=\"' + onClick + '\"><h1><i class=\"fa fa-arrow-circle-left\"></i> Back</h1></a></li>'\r\n        );\r\n    }\r\n}\r\n\r\nexport function hasSameAlbum (track1, track2) {\r\n    // 'true' if album for each track exists and has the same name\r\n    let name1 = track1 ? (track1.album ? track1.album.name : undefined) : undefined\r\n    let name2 = track2 ? (track2.album ? track2.album.name : undefined) : undefined\r\n    return name1 && name2 && (name1 === name2)\r\n}\r\n\r\nfunction validateTrackName (track, trackNumber) {\r\n    // Create name if there is none\r\n    let name = ''\r\n    if (!track.name || track.name === '') {\r\n        name = track.uri.split('/')\r\n        name = decodeURI(name[name.length - 1]) || 'Track ' + String(trackNumber)\r\n    } else {\r\n        name = track.name\r\n    }\r\n    return name\r\n}\r\n\r\nexport function resultsToTables (results, target: string, uri: string = undefined, onClickBack = undefined, backIsOptional = undefined) {\r\n    // document.querySelector(target).innerHTML = \"\";\r\n    // renderSongLiBackButton(results, target, onClickBack, backIsOptional)\r\n    // if (!results || results.length === 0) {\r\n    //     return;\r\n    // }\r\n    // document.querySelector(target).setAttribute('data', uri);\r\n    //\r\n    // let track, previousTrack, nextTrack, tlid;\r\n    // let html = '';\r\n    // let requiredImages = {};\r\n    //\r\n    // // Break into albums and put in tables\r\n    // for (let i = 0; i < results.length; i++) {\r\n    //     previousTrack = track || undefined;\r\n    //     nextTrack = i < results.length - 1 ? results[i + 1] : undefined;\r\n    //     track = results[i];\r\n    //     if (track) {\r\n    //         if ('tlid' in track) {\r\n    //             // Get track information from TlTrack instance\r\n    //             tlid = track.tlid;\r\n    //             track = track.track;\r\n    //             nextTrack = nextTrack ? nextTrack.track : undefined;\r\n    //         }\r\n    //         getState().popupData[track.uri] = track;\r\n    //         let divider = renderSongLiDivider(previousTrack, track, nextTrack, target);\r\n    //         html += divider[0] + renderSongLi(previousTrack, track, nextTrack, uri, tlid, target, i, results.length);\r\n    //         requiredImages[track.uri] = divider[1];\r\n    //     }\r\n    // }\r\n    // document.querySelector(target).append(html);\r\n    // updatePlayIcons(getState().songdata.track.uri, getState().songdata.tlid, controls.getIconForAction())\r\n    // images.setImages(requiredImages, getState().mopidy, 'small');\r\n}\r\n\r\nfunction getUris (tracks) {\r\n    let results = []\r\n    for (let i = 0; i < tracks.length; i++) {\r\n        results.push(tracks[i].uri)\r\n    }\r\n    return results\r\n}\r\n\r\nexport function getTracksFromUri (uri, full_track_data) {\r\n    let returnTracksOrUris = function (tracks) {\r\n        return full_track_data ? tracks : getUris(tracks)\r\n    }\r\n    if (getState().customTracklists[uri]) {\r\n        return returnTracksOrUris(getState().customTracklists[uri])\r\n    } else if (getState().playlists[uri] && getState().playlists[uri].tracks) {\r\n        return returnTracksOrUris(getState().playlists[uri].tracks)\r\n    }\r\n    return []\r\n}\r\n\r\n// convert time to human readable format\r\nfunction timeFromSeconds (length) {\r\n    let d = Number(length);\r\n    let h = Math.floor(d / 3600);\r\n    let m = Math.floor(d % 3600 / 60);\r\n    let s = Math.floor(d % 3600 % 60);\r\n    return ((h > 0 ? h + ':' : '') + (m > 0 ? (h > 0 && m < 10 ? '0' : '') + m + ':' : '0:') + (s < 10 ? '0' : '') + s);\r\n}\r\n\r\n/** ***** Toast ***/\r\nfunction toast (message, delay, textOnly) {\r\n    //todo\r\n    // let textOnl = textOnly || false;\r\n    // message = message || 'Loading...'\r\n    // delay = delay || 1000\r\n    // $.mobile.loading('show', {\r\n    //     text: message,\r\n    //     textVisible: true,\r\n    //     theme: 'a',\r\n    //     textonly: textOnl\r\n    // })\r\n    // if (delay > 0) {\r\n    //     setTimeout(function () {\r\n    //         $.mobile.loading('hide')\r\n    //     }, delay)\r\n    // }\r\n}\r\n\r\n/** ****************\r\n * Modal dialogs  *\r\n ******************/\r\nexport function showLoading (on) {\r\n    //todo\r\n    // if (on) {\r\n    //     document.body.classList.add('cursor', 'progress');\r\n    //     $.mobile.loading('show', {\r\n    //         text: 'Loading data from ' + HOSTNAME + '. Please wait...',\r\n    //         textVisible: true,\r\n    //         theme: 'a'\r\n    //     })\r\n    // } else {\r\n    //     $('body').css('cursor', 'default')\r\n    //     $.mobile.loading('hide')\r\n    // }\r\n}\r\n\r\n// from http://dzone.com/snippets/validate-url-regexp\r\nexport function validUri (uri: string) {\r\n    let regexp = /^(http|https|mms|rtmp|rtmps|rtsp):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?/;\r\n    return regexp.test(uri);\r\n}\r\n\r\nfunction validServiceUri (str: string) {\r\n    return validUri(str) || isServiceUri(str);\r\n}\r\n\r\nexport function getScheme (uri: string) {\r\n    return uri.split(':')[0].toLowerCase();\r\n}\r\n\r\nfunction isPlayable (track) {\r\n    if (typeof track.type === 'undefined' || track.type === 'track') {\r\n        if (track.uri && getScheme(track.uri) === 'file') {\r\n            let ext = track.uri.split('.').pop().toLowerCase();\r\n            // Files must have the correct extension\r\n            return VALID_AUDIO_EXT.includes(ext);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function isStreamUri (uri) {\r\n    return validUri(uri) || radioExtensionsList.indexOf(getScheme(uri)) >= 0\r\n}\r\n\r\nexport function getMediaClass (track) {\r\n    let defaultIcon = 'fa-file-sound-o'\r\n    let type = track.type\r\n    if (typeof type === 'undefined' || type === 'track') {\r\n        if (!isPlayable(track)) {\r\n            return 'fa fa-file-o'  // Unplayable file\r\n        } else if (isStreamUri(track.uri)) {\r\n            return 'fa fa-rss'  // Stream\r\n        }\r\n    } else if (type === 'directory') {\r\n        return 'fa fa-folder-o'\r\n    } else if (type === 'album') {\r\n        // return 'fa fa-bullseye'  // Album\r\n        defaultIcon = 'fa-folder-o'\r\n    } else if (type === 'artist') {\r\n        // return 'fa fa-user-circle-o'  // Artist\r\n        defaultIcon = 'fa-folder-o'\r\n    } else if (type === 'playlist') {\r\n        // return 'fa fa-star'  // Playlist\r\n    }\r\n    if (track.uri) {\r\n        let scheme = getScheme(track.uri)\r\n        for (let i = 0; i < uriClassList.length; i++) {\r\n            if (scheme === uriClassList[i][0]) {\r\n                return 'fa ' + uriClassList[i][1]\r\n            }\r\n        }\r\n        return 'fa ' + defaultIcon\r\n    }\r\n    return ''\r\n}\r\n\r\nfunction getMediaHuman (uri) {\r\n    let scheme = getScheme(uri)\r\n    for (let i = 0; i < uriHumanList.length; i++) {\r\n        if (scheme.toLowerCase() === uriHumanList[i][0].toLowerCase()) {\r\n            return uriHumanList[i][1]\r\n        }\r\n    }\r\n    return ''\r\n}\r\n\r\nfunction isServiceUri (uri) {\r\n    let scheme = getScheme(uri)\r\n    let i = 0\r\n    for (i = 0; i < uriClassList.length; i++) {\r\n        if (scheme === uriClassList[i][0]) {\r\n            return true\r\n        }\r\n    }\r\n    for (i = 0; i < radioExtensionsList.length; i++) {\r\n        if (scheme === radioExtensionsList[i]) {\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function isFavouritesPlaylist (playlist) {\r\n    return (playlist.name === STREAMS_PLAYLIST_NAME &&\r\n            getScheme(playlist.uri) === STREAMS_PLAYLIST_SCHEME)\r\n}\r\n\r\n// Returns a string where {x} in template is replaced by tokens[x].\r\nfunction stringFromTemplate (template, tokens) {\r\n    return template.replace(/{[^}]+}/g, function (match) {\r\n        return tokens[match.slice(1, -1)]\r\n    })\r\n}\r\n\r\n/**\r\n * Converts a URI to a jQuery-safe identifier. jQuery identifiers need to be\r\n * unique per page and cannot contain special characters.\r\n *\r\n * @param {string} identifier - Identifier string to prefix to the URI. Can\r\n * be used to ensure that the generated ID will be unique for the page that\r\n * it will be included on. Also accepts jQuery identifiers starting with '#'.\r\n *\r\n * @param {string} uri - URI to encode, usually the URI of a Mopidy track.\r\n *\r\n * @param {boolean} includePrefix - Will prefix the generated identifier\r\n * with the '#' character if set to 'true', ready to be passed to $() or\r\n * jQuery().\r\n *\r\n * @return {string} - a string in the format '[#]identifier-encodedURI' that\r\n * is safe to use as a jQuery identifier.\r\n */\r\nexport function getUniqueId (identifier: string, uri: string, includePrefix: boolean = false) {\r\n    if (identifier.charAt(0) === '#' && !includePrefix) {\r\n        identifier = identifier.substring(1);\r\n    } else if (identifier.charAt(0) !== '#' && includePrefix) {\r\n        identifier = '#' + identifier\r\n    }\r\n    return identifier + '-' + fixedEncodeURIComponent(uri).replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '')  // eslint-disable-line no-useless-escape\r\n}\r\n\r\n// Strict URI encoding as per https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\r\nfunction fixedEncodeURIComponent (str) {\r\n    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\r\n        return '%' + c.charCodeAt(0).toString(16)\r\n    })\r\n}\r\n\r\nexport function updatePlayIcons(uri: string, tlid: number, popupMenuIcon) {\r\n    // Update styles of listviews\r\n    let listviews = [PLAYLIST_TABLE, SEARCH_TRACK_TABLE, ARTIST_TABLE, ALBUM_TABLE, BROWSE_TABLE];\r\n    let target = CURRENT_PLAYLIST_TABLE.substring(1);\r\n    if (uri && typeof tlid === 'number' && tlid >= 0) {\r\n        document.querySelector(CURRENT_PLAYLIST_TABLE).querySelectorAll('li.song.albumli').forEach((el) => {\r\n            let eachTlid = parseInt(el.getAttribute('tlid'));\r\n            if (this.id === getUniqueId(target, uri) && eachTlid === tlid) {\r\n                if (!el.classList.contains('currenttrack')) {\r\n                    el.classList.add('currenttrack');\r\n                }\r\n            } else if (el.classList.contains('currenttrack')) {\r\n                el.classList.remove('currenttrack');\r\n            }\r\n        })\r\n    }\r\n\r\n    let popupElement;\r\n\r\n    for (let i = 0; i < listviews.length; i++) {\r\n        target = listviews[i].substring(1)\r\n        document.querySelector(listviews[i]).querySelectorAll('li.song.albumli').forEach((el) => {\r\n            if (uri) {\r\n                if (this.id === getUniqueId(target, uri)) {\r\n                    el.classList.add('currenttrack2');\r\n                } else {\r\n                    el.classList.remove('currenttrack2');\r\n                }\r\n            }\r\n            if (popupMenuIcon) {\r\n                popupElement = el.querySelector('a.moreBtn').querySelectorAll('i').item(0);\r\n                if (!popupElement.hasClass(popupMenuIcon)) {\r\n                    popupElement.removeClass()\r\n                    popupElement.addClass(popupMenuIcon)\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport function switchContent(divid: string, uri: string = undefined) {\r\n    let hash = divid;\r\n    if (uri) {\r\n        hash += '?' + uri\r\n    }\r\n    location.hash = '#' + hash\r\n}","//GENERATED by build_commands.ts (although probably customized, so do a diff when regenerating).\nimport {core, models, Mopidy} from \"../mopidy_eboplayer2/static/js/mopidy\";\nimport TlTrack = models.TlTrack;\nimport PlaybackState = core.PlaybackState;\nimport Playlist = models.Playlist;\n\nexport class Commands {\n    protected mopidy: Mopidy;\n    \n    constructor(mopidy: Mopidy) {\n        this.mopidy = mopidy;\n        this.core.commands = this;\n        this.core.history.commands = this;\n        this.core.library.commands = this;\n        this.core.mixer.commands = this;\n        this.core.playback.commands = this;\n        this.core.playlists.commands = this;\n        this.core.tracklist.commands = this;\n\n    }\n    \n    send(method: string, params: Object) {\n        if(params)\n            return this.mopidy.send({method, params});\n        else\n            return this.mopidy.send({method});\n    }\n    core = {\n        commands: undefined as Commands,\n\n            //Get list of URI schemes we can handle\n        getUriSchemes() {\n            return this.commands.send(\"core.get_uri_schemes\");\n        },\n            //Get version of the Mopidy core API\n        getVersion() {\n            return this.commands.send(\"core.get_version\");\n        },\n        history: {\n            commands: undefined as Commands,\n                //Get the track history.\n                //\n                //The timestamps are milliseconds since epoch.\n                //\n                //:returns: the track history\n                //:rtype: list of (timestamp, :class:`mopidy.models.Ref`) tuples\n            getHistory() {\n                return this.commands.send(\"core.history.get_history\");\n            },\n                //Get the number of tracks in the history.\n                //\n                //:returns: the history length\n                //:rtype: int\n            getLength() {\n                return this.commands.send(\"core.history.get_length\");\n            },\n        },\n        library: {\n            commands: undefined as Commands,\n                //Browse directories and tracks at the given ``uri``.\n                //\n                //``uri`` is a string which represents some directory belonging to a\n                //backend. To get the intial root directories for backends pass\n                //:class:`None` as the URI.\n                //\n                //Returns a list of :class:`mopidy.models.Ref` objects for the\n                //directories and tracks at the given ``uri``.\n                //\n                //The :class:`~mopidy.models.Ref` objects representing tracks keep the\n                //track's original URI. A matching pair of objects can look like this::\n                //\n                //    Track(uri='dummy:/foo.mp3', name='foo', artists=..., album=...)\n                //    Ref.track(uri='dummy:/foo.mp3', name='foo')\n                //\n                //The :class:`~mopidy.models.Ref` objects representing directories have\n                //backend specific URIs. These are opaque values, so no one but the\n                //backend that created them should try and derive any meaning from them.\n                //The only valid exception to this is checking the scheme, as it is used\n                //to route browse requests to the correct backend.\n                //\n                //For example, the dummy library's ``/bar`` directory could be returned\n                //like this::\n                //\n                //    Ref.directory(uri='dummy:directory:/bar', name='bar')\n                //\n                //:param string uri: URI to browse\n                //:rtype: list of :class:`mopidy.models.Ref`\n                //\n                //.. versionadded:: 0.18\n            browse(uri?: string) {\n                return this.commands.send(\"core.library.browse\", {uri});\n            },\n                //List distinct values for a given field from the library.\n                //\n                //This has mainly been added to support the list commands the MPD\n                //protocol supports in a more sane fashion. Other frontends are not\n                //recommended to use this method.\n                //\n                //:param string field: Any one of ``uri``, ``track_name``, ``album``,\n                //    ``artist``, ``albumartist``, ``composer``, ``performer``,\n                //    ``track_no``, ``genre``, ``date``, ``comment``, ``disc_no``,\n                //    ``musicbrainz_albumid``, ``musicbrainz_artistid``, or\n                //    ``musicbrainz_trackid``.\n                //:param dict query: Query to use for limiting results, see\n                //    :meth:`search` for details about the query format.\n                //:rtype: set of values corresponding to the requested field type.\n                //\n                //.. versionadded:: 1.0\n            getDistinct(field?: string, query?: string) {\n                return this.commands.send(\"core.library.get_distinct\", {field, query});\n            },\n                //Lookup the images for the given URIs\n                //\n                //Backends can use this to return image URIs for any URI they know about\n                //be it tracks, albums, playlists. The lookup result is a dictionary\n                //mapping the provided URIs to lists of images.\n                //\n                //Unknown URIs or URIs the corresponding backend couldn't find anything\n                //for will simply return an empty list for that URI.\n                //\n                //:param uris: list of URIs to find images for\n                //:type uris: list of string\n                //:rtype: {uri: tuple of :class:`mopidy.models.Image`}\n                //\n                //.. versionadded:: 1.0\n            getImages(uris?: string[]) {\n                return this.commands.send(\"core.library.get_images\", {uris});\n            },\n                //Lookup the given URIs.\n                //\n                //If the URI expands to multiple tracks, the returned list will contain\n                //them all.\n                //\n                //:param uris: track URIs\n                //:type uris: list of string\n                //:rtype: {uri: list of :class:`mopidy.models.Track`}\n            lookup(uris?: string[]) {\n                return this.commands.send(\"core.library.lookup\", {uris});\n            },\n                //Refresh library. Limit to URI and below if an URI is given.\n                //\n                //:param uri: directory or track URI\n                //:type uri: string\n            refresh(uri?: string) {\n                return this.commands.send(\"core.library.refresh\", {uri});\n            },\n                //Search the library for tracks where ``field`` contains ``values``.\n                //\n                //``field`` can be one of ``uri``, ``track_name``, ``album``, ``artist``,\n                //``albumartist``, ``composer``, ``performer``, ``track_no``, ``genre``,\n                //``date``, ``comment``, ``disc_no``, ``musicbrainz_albumid``,\n                //``musicbrainz_artistid``, ``musicbrainz_trackid`` or ``any``.\n                //\n                //If ``uris`` is given, the search is limited to results from within the\n                //URI roots. For example passing ``uris=['file:']`` will limit the search\n                //to the local backend.\n                //\n                //Examples::\n                //\n                //    # Returns results matching 'a' in any backend\n                //    search({'any': ['a']})\n                //\n                //    # Returns results matching artist 'xyz' in any backend\n                //    search({'artist': ['xyz']})\n                //\n                //    # Returns results matching 'a' and 'b' and artist 'xyz' in any\n                //    # backend\n                //    search({'any': ['a', 'b'], 'artist': ['xyz']})\n                //\n                //    # Returns results matching 'a' if within the given URI roots\n                //    # \"file:///media/music\" and \"spotify:\"\n                //    search({'any': ['a']}, uris=['file:///media/music', 'spotify:'])\n                //\n                //    # Returns results matching artist 'xyz' and 'abc' in any backend\n                //    search({'artist': ['xyz', 'abc']})\n                //\n                //:param query: one or more queries to search for\n                //:type query: dict\n                //:param uris: zero or more URI roots to limit the search to\n                //:type uris: list of string or :class:`None`\n                //:param exact: if the search should use exact matching\n                //:type exact: :class:`bool`\n                //:rtype: list of :class:`mopidy.models.SearchResult`\n                //\n                //.. versionadded:: 1.0\n                //    The ``exact`` keyword argument.\n            search(query?: string, uris?: string[], exact: boolean = false) {\n                return this.commands.send(\"core.library.search\", {query, uris, exact});\n            },\n        },\n        mixer: {\n            commands: undefined as Commands,\n                //Get mute state.\n                //\n                //:class:`True` if muted, :class:`False` unmuted, :class:`None` if\n                //unknown.\n            getMute() {\n                return this.commands.send(\"core.mixer.get_mute\");\n            },\n                //Get the volume.\n                //\n                //Integer in range [0..100] or :class:`None` if unknown.\n                //\n                //The volume scale is linear.\n            getVolume() {\n                return this.commands.send(\"core.mixer.get_volume\");\n            },\n                //Set mute state.\n                //\n                //:class:`True` to mute, :class:`False` to unmute.\n                //\n                //Returns :class:`True` if call is successful, otherwise :class:`False`.\n            setMute(mute?: boolean) {\n                return this.commands.send(\"core.mixer.set_mute\", {mute});\n            },\n                //Set the volume.\n                //\n                //The volume is defined as an integer in range [0..100].\n                //\n                //The volume scale is linear.\n                //\n                //Returns :class:`True` if call is successful, otherwise :class:`False`.\n            setVolume(volume?: number) {\n                return this.commands.send(\"core.mixer.set_volume\", {volume});\n            },\n        },\n        playback: {\n            commands: undefined as Commands,\n                //Get the currently playing or selected track.\n                //\n                //Returns a :class:`mopidy.models.TlTrack` or :class:`None`.\n            getCurrentTlTrack() {\n                return this.commands.send(\"core.playback.get_current_tl_track\");\n            },\n                //Get the currently playing or selected TLID.\n                //\n                //Extracted from :meth:`get_current_tl_track` for convenience.\n                //\n                //Returns a :class:`int` or :class:`None`.\n                //\n                //.. versionadded:: 1.1\n            getCurrentTlid() {\n                return this.commands.send(\"core.playback.get_current_tlid\");\n            },\n                //Get the currently playing or selected track.\n                //\n                //Extracted from :meth:`get_current_tl_track` for convenience.\n                //\n                //Returns a :class:`mopidy.models.Track` or :class:`None`.\n            getCurrentTrack() {\n                return this.commands.send(\"core.playback.get_current_track\");\n            },\n                //Get The playback state.\n            getState() {\n                return this.commands.send(\"core.playback.get_state\");\n            },\n                //Get the current stream title or :class:`None`.\n            getStreamTitle() {\n                return this.commands.send(\"core.playback.get_stream_title\");\n            },\n                //Get time position in milliseconds.\n            getTimePosition() {\n                return this.commands.send(\"core.playback.get_time_position\");\n            },\n                //Change to the next track.\n                //\n                //The current playback state will be kept. If it was playing, playing\n                //will continue. If it was paused, it will still be paused, etc.\n            next() {\n                return this.commands.send(\"core.playback.next\");\n            },\n                //Pause playback.\n            pause() {\n                return this.commands.send(\"core.playback.pause\");\n            },\n                //Play the given track, or if the given tl_track and tlid is\n                //:class:`None`, play the currently active track.\n                //\n                //Note that the track **must** already be in the tracklist.\n                //\n                //.. deprecated:: 3.0\n                //    The ``tl_track`` argument. Use ``tlid`` instead.\n                //\n                //:param tl_track: track to play\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:param tlid: TLID of the track to play\n                //:type tlid: :class:`int` or :class:`None`\n            play(tl_track?: TlTrack, tlid?: number) {\n                return this.commands.send(\"core.playback.play\", {tl_track, tlid});\n            },\n                //Change to the previous track.\n                //\n                //The current playback state will be kept. If it was playing, playing\n                //will continue. If it was paused, it will still be paused, etc.\n            previous() {\n                return this.commands.send(\"core.playback.previous\");\n            },\n                //If paused, resume playing the current track.\n            resume() {\n                return this.commands.send(\"core.playback.resume\");\n            },\n                //Seeks to time position given in milliseconds.\n                //\n                //:param time_position: time position in milliseconds\n                //:type time_position: int\n                //:rtype: :class:`True` if successful, else :class:`False`\n            seek(time_position?: number) {\n                return this.commands.send(\"core.playback.seek\", {time_position});\n            },\n                //Set the playback state.\n                //\n                //Must be :attr:`PLAYING`, :attr:`PAUSED`, or :attr:`STOPPED`.\n                //\n                //Possible states and transitions:\n                //\n                //.. digraph:: state_transitions\n                //\n                //    \"STOPPED\" -> \"PLAYING\" [ label=\"play\" ]\n                //    \"STOPPED\" -> \"PAUSED\" [ label=\"pause\" ]\n                //    \"PLAYING\" -> \"STOPPED\" [ label=\"stop\" ]\n                //    \"PLAYING\" -> \"PAUSED\" [ label=\"pause\" ]\n                //    \"PLAYING\" -> \"PLAYING\" [ label=\"play\" ]\n                //    \"PAUSED\" -> \"PLAYING\" [ label=\"resume\" ]\n                //    \"PAUSED\" -> \"STOPPED\" [ label=\"stop\" ]\n            setState(new_state?: PlaybackState) {\n                return this.commands.send(\"core.playback.set_state\", {new_state});\n            },\n                //Stop playing.\n            stop() {\n                return this.commands.send(\"core.playback.stop\");\n            },\n        },\n        playlists: {\n            commands: undefined as Commands,\n                //Get a list of the currently available playlists.\n                //\n                //Returns a list of :class:`~mopidy.models.Ref` objects referring to the\n                //playlists. In other words, no information about the playlists' content\n                //is given.\n                //\n                //:rtype: list of :class:`mopidy.models.Ref`\n                //\n                //.. versionadded:: 1.0\n            asList() {\n                return this.commands.send(\"core.playlists.as_list\");\n            },\n                //Create a new playlist.\n                //\n                //If ``uri_scheme`` matches an URI scheme handled by a current backend,\n                //that backend is asked to create the playlist. If ``uri_scheme`` is\n                //:class:`None` or doesn't match a current backend, the first backend is\n                //asked to create the playlist.\n                //\n                //All new playlists must be created by calling this method, and **not**\n                //by creating new instances of :class:`mopidy.models.Playlist`.\n                //\n                //:param name: name of the new playlist\n                //:type name: string\n                //:param uri_scheme: use the backend matching the URI scheme\n                //:type uri_scheme: string\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            create(name?: string, uri_scheme?: string) {\n                return this.commands.send(\"core.playlists.create\", {name, uri_scheme});\n            },\n                //Delete playlist identified by the URI.\n                //\n                //If the URI doesn't match the URI schemes handled by the current\n                //backends, nothing happens.\n                //\n                //Returns :class:`True` if deleted, :class:`False` otherwise.\n                //\n                //:param uri: URI of the playlist to delete\n                //:type uri: string\n                //:rtype: :class:`bool`\n                //\n                //.. versionchanged:: 2.2\n                //    Return type defined.\n            delete(uri?: string) {\n                return this.commands.send(\"core.playlists.delete\", {uri});\n            },\n                //Get the items in a playlist specified by ``uri``.\n                //\n                //Returns a list of :class:`~mopidy.models.Ref` objects referring to the\n                //playlist's items.\n                //\n                //If a playlist with the given ``uri`` doesn't exist, it returns\n                //:class:`None`.\n                //\n                //:rtype: list of :class:`mopidy.models.Ref`, or :class:`None`\n                //\n                //.. versionadded:: 1.0\n            getItems(uri?: string) {\n                return this.commands.send(\"core.playlists.get_items\", {uri});\n            },\n                //Get the list of URI schemes that support playlists.\n                //\n                //:rtype: list of string\n                //\n                //.. versionadded:: 2.0\n            getUriSchemes() {\n                return this.commands.send(\"core.playlists.get_uri_schemes\");\n            },\n                //Lookup playlist with given URI in both the set of playlists and in any\n                //other playlist sources. Returns :class:`None` if not found.\n                //\n                //:param uri: playlist URI\n                //:type uri: string\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            lookup(uri?: string) {\n                return this.commands.send(\"core.playlists.lookup\", {uri});\n            },\n                //Refresh the playlists in :attr:`playlists`.\n                //\n                //If ``uri_scheme`` is :class:`None`, all backends are asked to refresh.\n                //If ``uri_scheme`` is an URI scheme handled by a backend, only that\n                //backend is asked to refresh. If ``uri_scheme`` doesn't match any\n                //current backend, nothing happens.\n                //\n                //:param uri_scheme: limit to the backend matching the URI scheme\n                //:type uri_scheme: string\n            refresh(uri_scheme?: string) {\n                return this.commands.send(\"core.playlists.refresh\", {uri_scheme});\n            },\n                //Save the playlist.\n                //\n                //For a playlist to be saveable, it must have the ``uri`` attribute set.\n                //You must not set the ``uri`` atribute yourself, but use playlist\n                //objects returned by :meth:`create` or retrieved from :attr:`playlists`,\n                //which will always give you saveable playlists.\n                //\n                //The method returns the saved playlist. The return playlist may differ\n                //from the saved playlist. E.g. if the playlist name was changed, the\n                //returned playlist may have a different URI. The caller of this method\n                //must throw away the playlist sent to this method, and use the\n                //returned playlist instead.\n                //\n                //If the playlist's URI isn't set or doesn't match the URI scheme of a\n                //current backend, nothing is done and :class:`None` is returned.\n                //\n                //:param playlist: the playlist\n                //:type playlist: :class:`mopidy.models.Playlist`\n                //:rtype: :class:`mopidy.models.Playlist` or :class:`None`\n            save(playlist?: Playlist) {\n                return this.commands.send(\"core.playlists.save\", {playlist});\n            },\n        },\n        tracklist: {\n            commands: undefined as Commands,\n                //Add tracks to the tracklist.\n                //\n                //If ``uris`` is given instead of ``tracks``, the URIs are\n                //looked up in the library and the resulting tracks are added to the\n                //tracklist.\n                //\n                //If ``at_position`` is given, the tracks are inserted at the given\n                //position in the tracklist. If ``at_position`` is not given, the tracks\n                //are appended to the end of the tracklist.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param tracks: tracks to add\n                //:type tracks: list of :class:`mopidy.models.Track` or :class:`None`\n                //:param at_position: position in tracklist to add tracks\n                //:type at_position: int or :class:`None`\n                //:param uris: list of URIs for tracks to add\n                //:type uris: list of string or :class:`None`\n                //:rtype: list of :class:`mopidy.models.TlTrack`\n                //\n                //.. versionadded:: 1.0\n                //    The ``uris`` argument.\n                //\n                //.. deprecated:: 1.0\n                //    The ``tracks`` argument. Use ``uris``.\n            add(tracks?: undefined, at_position?: number, uris?: string[]) {\n                return this.commands.send(\"core.tracklist.add\", {tracks, at_position, uris});\n            },\n                //Clear the tracklist.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n            clear() {\n                return this.commands.send(\"core.tracklist.clear\");\n            },\n                //The track that will be played after the given track.\n                //\n                //Not necessarily the same track as :meth:`next_track`.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_eot_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            eotTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.eot_track\", {tl_track});\n            },\n                //Filter the tracklist by the given criteria.\n                //\n                //Each rule in the criteria consists of a model field and a list of\n                //values to compare it against. If the model field matches any of the\n                //values, it may be returned.\n                //\n                //Only tracks that match all the given criteria are returned.\n                //\n                //Examples::\n                //\n                //    # Returns tracks with TLIDs 1, 2, 3, or 4 (tracklist ID)\n                //    filter({'tlid': [1, 2, 3, 4]})\n                //\n                //    # Returns track with URIs 'xyz' or 'abc'\n                //    filter({'uri': ['xyz', 'abc']})\n                //\n                //    # Returns track with a matching TLIDs (1, 3 or 6) and a\n                //    # matching URI ('xyz' or 'abc')\n                //    filter({'tlid': [1, 3, 6], 'uri': ['xyz', 'abc']})\n                //\n                //:param criteria: one or more rules to match by\n                //:type criteria: dict, of (string, list) pairs\n                //:rtype: list of :class:`mopidy.models.TlTrack`\n            filter(criteria?: any /*TODO: a dict*/) {\n                return this.commands.send(\"core.tracklist.filter\", {criteria});\n            },\n                //Get consume mode.\n                //\n                //:class:`True`\n                //    Tracks are removed from the tracklist when they have been played.\n                //:class:`False`\n                //    Tracks are not removed from the tracklist.\n            getConsume() {\n                return this.commands.send(\"core.tracklist.get_consume\");\n            },\n                //The TLID of the track that will be played after the current track.\n                //\n                //Not necessarily the same TLID as returned by :meth:`get_next_tlid`.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getEotTlid() {\n                return this.commands.send(\"core.tracklist.get_eot_tlid\");\n            },\n                //Get length of the tracklist.\n            getLength() {\n                return this.commands.send(\"core.tracklist.get_length\");\n            },\n                //The tlid of the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.next()`.\n                //\n                //For normal playback this is the next track in the tracklist. If repeat\n                //is enabled the next track can loop around the tracklist. When random is\n                //enabled this should be a random track, all tracks should be played once\n                //before the tracklist repeats.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getNextTlid() {\n                return this.commands.send(\"core.tracklist.get_next_tlid\");\n            },\n                //Returns the TLID of the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.previous()`.\n                //\n                //For normal playback this is the previous track in the tracklist. If\n                //random and/or consume is enabled it should return the current track\n                //instead.\n                //\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n            getPreviousTlid() {\n                return this.commands.send(\"core.tracklist.get_previous_tlid\");\n            },\n                //Get random mode.\n                //\n                //:class:`True`\n                //    Tracks are selected at random from the tracklist.\n                //:class:`False`\n                //    Tracks are played in the order of the tracklist.\n            getRandom() {\n                return this.commands.send(\"core.tracklist.get_random\");\n            },\n                //Get repeat mode.\n                //\n                //:class:`True`\n                //    The tracklist is played repeatedly.\n                //:class:`False`\n                //    The tracklist is played once.\n            getRepeat() {\n                return this.commands.send(\"core.tracklist.get_repeat\");\n            },\n                //Get single mode.\n                //\n                //:class:`True`\n                //    Playback is stopped after current song, unless in ``repeat`` mode.\n                //:class:`False`\n                //    Playback continues after current song.\n            getSingle() {\n                return this.commands.send(\"core.tracklist.get_single\");\n            },\n                //Get tracklist as list of :class:`mopidy.models.TlTrack`.\n            getTlTracks() {\n                return this.commands.send(\"core.tracklist.get_tl_tracks\");\n            },\n                //Get tracklist as list of :class:`mopidy.models.Track`.\n            getTracks() {\n                return this.commands.send(\"core.tracklist.get_tracks\");\n            },\n                //Get the tracklist version.\n                //\n                //Integer which is increased every time the tracklist is changed. Is not\n                //reset before Mopidy is restarted.\n            getVersion() {\n                return this.commands.send(\"core.tracklist.get_version\");\n            },\n                //The position of the given track in the tracklist.\n                //\n                //If neither *tl_track* or *tlid* is given we return the index of\n                //the currently playing track.\n                //\n                //:param tl_track: the track to find the index of\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:param tlid: TLID of the track to find the index of\n                //:type tlid: :class:`int` or :class:`None`\n                //:rtype: :class:`int` or :class:`None`\n                //\n                //.. versionadded:: 1.1\n                //    The *tlid* parameter\n            index(tl_track?: TlTrack, tlid?: number) {\n                return this.commands.send(\"core.tracklist.index\", {tl_track, tlid});\n            },\n                //Move the tracks in the slice ``[start:end]`` to ``to_position``.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param start: position of first track to move\n                //:type start: int\n                //:param end: position after last track to move\n                //:type end: int\n                //:param to_position: new position for the tracks\n                //:type to_position: int\n            move(start?: number, end?: number, to_position?: number) {\n                return this.commands.send(\"core.tracklist.move\", {start, end, to_position});\n            },\n                //The track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.next()`.\n                //\n                //For normal playback this is the next track in the tracklist. If repeat\n                //is enabled the next track can loop around the tracklist. When random is\n                //enabled this should be a random track, all tracks should be played once\n                //before the tracklist repeats.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_next_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            nextTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.next_track\", {tl_track});\n            },\n                //Returns the track that will be played if calling\n                //:meth:`mopidy.core.PlaybackController.previous()`.\n                //\n                //For normal playback this is the previous track in the tracklist. If\n                //random and/or consume is enabled it should return the current track\n                //instead.\n                //\n                //.. deprecated:: 3.0\n                //    Use :meth:`get_previous_tlid` instead.\n                //\n                //:param tl_track: the reference track\n                //:type tl_track: :class:`mopidy.models.TlTrack` or :class:`None`\n                //:rtype: :class:`mopidy.models.TlTrack` or :class:`None`\n            previousTrack(tl_track?: TlTrack) {\n                return this.commands.send(\"core.tracklist.previous_track\", {tl_track});\n            },\n                //Remove the matching tracks from the tracklist.\n                //\n                //Uses :meth:`filter()` to lookup the tracks to remove.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param criteria: one or more rules to match by\n                //:type criteria: dict, of (string, list) pairs\n                //:rtype: list of :class:`mopidy.models.TlTrack` that were removed\n            remove(criteria?: string /*TODO: or list */) {\n                return this.commands.send(\"core.tracklist.remove\", {criteria});\n            },\n                //Set consume mode.\n                //\n                //:class:`True`\n                //    Tracks are removed from the tracklist when they have been played.\n                //:class:`False`\n                //    Tracks are not removed from the tracklist.\n            setConsume(value?: boolean) {\n                return this.commands.send(\"core.tracklist.set_consume\", {value});\n            },\n                //Set random mode.\n                //\n                //:class:`True`\n                //    Tracks are selected at random from the tracklist.\n                //:class:`False`\n                //    Tracks are played in the order of the tracklist.\n            setRandom(value?: boolean) {\n                return this.commands.send(\"core.tracklist.set_random\", {value});\n            },\n                //Set repeat mode.\n                //\n                //To repeat a single track, set both ``repeat`` and ``single``.\n                //\n                //:class:`True`\n                //    The tracklist is played repeatedly.\n                //:class:`False`\n                //    The tracklist is played once.\n            setRepeat(value?: boolean) {\n                return this.commands.send(\"core.tracklist.set_repeat\", {value});\n            },\n                //Set single mode.\n                //\n                //:class:`True`\n                //    Playback is stopped after current song, unless in ``repeat`` mode.\n                //:class:`False`\n                //    Playback continues after current song.\n            setSingle(value?: boolean) {\n                return this.commands.send(\"core.tracklist.set_single\", {value});\n            },\n                //Shuffles the entire tracklist. If ``start`` and ``end`` is given only\n                //shuffles the slice ``[start:end]``.\n                //\n                //Triggers the :meth:`mopidy.core.CoreListener.tracklist_changed` event.\n                //\n                //:param start: position of first track to shuffle\n                //:type start: int or :class:`None`\n                //:param end: position after last track to shuffle\n                //:type end: int or :class:`None`\n            shuffle(start?: number, end?: number) {\n                return this.commands.send(\"core.tracklist.shuffle\", {start, end});\n            },\n                //Returns a slice of the tracklist, limited by the given start and end\n                //positions.\n                //\n                //:param start: position of first track to include in slice\n                //:type start: int\n                //:param end: position after last track to include in slice\n                //:type end: int\n                //:rtype: :class:`mopidy.models.TlTrack`\n            slice(start?: number, end?: number) {\n                return this.commands.send(\"core.tracklist.slice\", {start, end});\n            },\n        },\n    }\n}\n","import getState from \"./playerState\";\r\nimport {showLoading, validUri} from \"./functionsvars\";\r\nimport {library} from \"./library\";\r\nimport * as controls from \"./controls\";\r\nimport {transformTlTrackDataToModel} from \"./process_ws\";\r\nimport {ConnectionState, FileTrackModel, HistoryLine, LibraryDict, Model, NoneTrackModel, PlayState, StreamTrackModel, TrackModel, TrackType} from \"./model\";\r\nimport {Commands} from \"../scripts/commands\";\r\nimport {models, Mopidy} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport {EboPlayerDataType} from \"./views/view\";\r\nimport {DataRequester} from \"./views/dataRequester\";\r\nimport TlTrack = models.TlTrack;\r\n\r\nexport class Controller extends Commands implements DataRequester{\r\n    private model: Model;\r\n    private commands: Commands;\r\n\r\n    constructor(model: Model, mopidy: Mopidy) {\r\n        super(mopidy);\r\n        this.model  = model;\r\n        this.commands = new Commands(mopidy);\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.CurrentTrack];\r\n    }\r\n    getRequiredDataTypesRecursive(): EboPlayerDataType[] {\r\n        return this.getRequiredDataTypes();\r\n    }\r\n\r\n    initSocketevents () {\r\n        this.mopidy.on('state:online', async () => {\r\n            this.model.setConnectionState(ConnectionState.Online);\r\n            await getState().getRequiredData();\r\n            await this.fetchHistory();\r\n        });\r\n\r\n        this.mopidy.on('state:offline', () => {\r\n            this.model.setConnectionState(ConnectionState.Offline);\r\n        });\r\n\r\n        this.mopidy.on('event:optionsChanged', this.fetchPlaybackOptions);\r\n\r\n        this.mopidy.on('event:trackPlaybackStarted', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n            controls.setPlayState(true);\r\n        });\r\n\r\n        this.mopidy.on('event:trackPlaybackResumed', async (data) => {\r\n            await this.setCurrentTrackAndFetchDetails(data.tl_track);\r\n            controls.setPlayState(true); //todo: pass this through the model and it's listeners.\r\n        });\r\n\r\n        this.mopidy.on('event:playlistsLoaded', ()  => {\r\n            showLoading(true);\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:playlistChanged', (data) => {\r\n            (document.getElementById('playlisttracksdiv') as HTMLElement).style.display = 'none';\r\n            (document.getElementById('playlistslistdiv') as HTMLElement).style.display = 'block';\r\n            delete getState().playlists[data.playlist.uri];\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:playlistDeleted', (data) => {\r\n            (document.getElementById('playlisttracksdiv') as HTMLElement).style.display = 'none';\r\n            (document.getElementById('playlistslistdiv') as HTMLElement).style.display = 'block';\r\n            delete getState().playlists[data.uri];\r\n            library.getPlaylists();\r\n        });\r\n\r\n        this.mopidy.on('event:volumeChanged', (data) => {\r\n            this.model.setVolume(data.volume);\r\n        });\r\n\r\n        this.mopidy.on('event:muteChanged', (data) => {\r\n            controls.setMute(data.mute);\r\n        });\r\n\r\n        this.mopidy.on('event:playbackStateChanged', (data) => {\r\n            getState().getController().setPlayState(data.new_state);\r\n        });\r\n\r\n        this.mopidy.on('event:tracklistChanged', async () => {\r\n            await this.fetchTracklistAndDetails();\r\n        });\r\n\r\n        this.mopidy.on('event:seeked', (data) => {\r\n            controls.setPosition(data.time_position);\r\n            if (getState().play) {\r\n                getState().syncedProgressTimer.start();\r\n            }\r\n        });\r\n\r\n        this.mopidy.on(\"event:streamHistoryChanged\", (data) => {\r\n            let lines = Object.values<string>(data.data);\r\n            this.model.setActiveStreamLinesHistory(lines);\r\n        });\r\n\r\n        //log all events:\r\n        this.mopidy.on((data) => {\r\n            if(data instanceof MessageEvent) {\r\n                try {\r\n                    let dataObject = JSON.parse(data.data);\r\n                    if((dataObject.event ?? \"\") == \"stream_title_changed\")\r\n                        return;\r\n                } catch (e) {} //not valid json.\r\n            }\r\n            if(typeof(data) == \"object\") {\r\n                if((data.title && Object.keys(data).length) == 1)\r\n                    return;\r\n            }\r\n            if(data instanceof Array) {\r\n                if (data.length && data[0] == \"event:streamTitleChanged\")\r\n                    return;\r\n            }\r\n            console.log(data);\r\n        });\r\n\r\n    }\r\n\r\n    async fetchTracklistAndDetails() {\r\n        let tracks = await this.commands.core.tracklist.getTlTracks();\r\n        this.model.setTrackList(tracks);\r\n    }\r\n\r\n    async fetchCurrentTrackAndDetails() {\r\n        let currentTrack = await this.commands.core.playback.getCurrentTlTrack(); //todo: likely to result in null, as the track probably hasn't been started yet. Remoove this line?\r\n        await this.setCurrentTrackAndFetchDetails(currentTrack);\r\n    }\r\n\r\n    async setCurrentTrackAndFetchDetails(data: (TlTrack | null)) {\r\n        this.model.setCurrentTrack(transformTlTrackDataToModel(data));\r\n        await this.fetchActiveStreamLines();\r\n        //todo: do this only when a track is started?s\r\n        // this.core.playback.getTimePosition().then(processCurrentposition, console.error)\r\n        // this.core.playback.getState().then(processPlaystate, console.error)\r\n        // this.core.mixer.getVolume().then(processVolume, console.error)\r\n        // this.core.mixer.getMute().then(processMute, console.error)\r\n    }\r\n\r\n    fetchPlaybackOptions () {\r\n        let promises = [\r\n            this.commands.core.tracklist.getRepeat(),\r\n            this.commands.core.tracklist.getRandom(),\r\n            this.commands.core.tracklist.getConsume(),\r\n            this.commands.core.tracklist.getSingle(),\r\n        ];\r\n        Promise.all(promises).then((results) => {\r\n            this.model.setPlaybackState({\r\n                repeat: results[0],\r\n                random: results[1],\r\n                consume: results[2],\r\n                single: results[3]\r\n            });\r\n        })\r\n    }\r\n\r\n    setVolume(volume: number) {\r\n        this.model.setVolume(volume);\r\n    }\r\n\r\n    setPlayState(state: string) {\r\n        this.model.setPlayState(state as PlayState);\r\n    }\r\n\r\n    setTracklist(trackList: TlTrack[]) {\r\n        this.model.setTrackList(trackList);\r\n    }\r\n\r\n    async getData(dataType: EboPlayerDataType) {\r\n        switch (dataType) {\r\n            case EboPlayerDataType.Volume:\r\n                let volume = await this.commands.core.mixer.getVolume() as number;  //todo: make fetch functions of these switch cases.\r\n                this.setVolume(volume);\r\n                break;\r\n            case  EboPlayerDataType.CurrentTrack:\r\n                let track = await this.commands.core.playback.getCurrentTlTrack() as TlTrack;\r\n                await this.setCurrentTrackAndFetchDetails(track);\r\n                break;\r\n            case  EboPlayerDataType.PlayState:\r\n                let state = await this.commands.core.playback.getState() as string;\r\n                this.setPlayState(state);\r\n                break;\r\n            case  EboPlayerDataType.StreamLines:\r\n                await this.fetchActiveStreamLines();\r\n                break;\r\n            case  EboPlayerDataType.TrackList:\r\n                await this.fetchTracklistAndDetails();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private async fetchActiveStreamLines() {\r\n        let res = await fetch(`http://${getHostAndPort()}/eboplayer/stream/activeLines`);\r\n        let lines = await res.json();\r\n        this.model.setActiveStreamLinesHistory(lines);\r\n    }\r\n\r\n    async fetchHistory()  {\r\n        let historyObject: Object = await this.commands.core.history.getHistory();\r\n        let historyLines = numberedDictToArray<HistoryLine>(historyObject, line => {\r\n            return {\r\n                timestamp: line[\"0\"],\r\n                ref: line[\"1\"]\r\n            };\r\n        });\r\n\r\n\r\n        //Make sure a stream is only listed once.\r\n        let foundStreams = new Set<string>();\r\n        let filtered = historyLines.filter(line => {\r\n            if(!line.ref.uri.startsWith(\"http:\"))\r\n                return true; //assume not a stream\r\n            if(foundStreams.has(line.ref.uri))\r\n                return false;\r\n            foundStreams.add(line.ref.uri);\r\n            return true;\r\n        });\r\n\r\n\r\n        let prev = {ref: {uri:\"\"}};\r\n        let dedupLines = filtered.filter((line) => {\r\n            if(line.ref.uri == prev.ref.uri)\r\n                return false;\r\n            prev = line;\r\n            return true;\r\n        });\r\n\r\n        let unique = [...new Set(dedupLines)];\r\n        let dict: LibraryDict = await this.commands.core.library.lookup(unique.map(l => l.ref.uri));\r\n        this.model.addToLibraryCache(dict);\r\n\r\n        this.model.setHistory(dedupLines);\r\n    }\r\n\r\n    async lookupCached(uri: string) {\r\n        let tracks = this.model.getTrackFromCache(uri);\r\n        if(tracks)\r\n            return tracks;\r\n        let dict: LibraryDict = await this.commands.core.library.lookup([uri]);\r\n        this.model.addToLibraryCache(dict);\r\n        return this.model.getTrackFromCache(uri);\r\n    }\r\n\r\n    async playTrack(uri: string) {\r\n        await this.commands.core.tracklist.clear();\r\n        let tracks = await this.commands.core.tracklist.add(null, null, [uri]);\r\n        let trackList = numberedDictToArray(tracks) as models.TlTrack[];\r\n        this.setTracklist(trackList);\r\n        this.commands.core.playback.play(null, trackList[0].tlid);\r\n        await this.setCurrentTrackAndFetchDetails(trackList[0]);\r\n    }\r\n\r\n    async sendVolume(value: number) {\r\n        await this.commands.core.mixer.setVolume(Math.floor(quadratic100(value)));\r\n    }\r\n\r\n    async sendStop() {\r\n        return this.commands.core.playback.stop();\r\n    }\r\n    async sendPause() {\r\n        return this.commands.core.playback.pause();\r\n    }\r\n    async sendPlay() {\r\n        return this.commands.core.playback.play();\r\n    }\r\n}\r\n\r\nexport function quadratic100(x:number) { return (x*x)/100;}\r\nexport function inverseQuadratic100(y:number) { return Math.floor(Math.sqrt(y*100));}\r\n// noinspection JSUnusedLocalSymbols\r\nexport function cubic100(x:number) { return (x*x*x)/10000;}\r\n\r\nexport function numberedDictToArray<T>(dict: Object, converter?: (object: any) => T): T[] {\r\n    let length = dict[\"length\"];\r\n    let array: any[] = [];\r\n    for(let index = 0; index < length; index++) {\r\n        let line = dict[index.toString()];\r\n        array.push(line);\r\n    }\r\n    if(!converter)\r\n        return array;\r\n    return array.map(converter);\r\n}\r\n\r\nexport function getHostAndPort() {\r\n    let hostName = document.body.dataset.hostname;\r\n    if (!hostName.startsWith(\"{{\"))\r\n        return hostName;\r\n\r\n    hostName = localStorage.getItem(\"eboplayer.hostName\");\r\n    if(hostName)\r\n        return hostName;\r\n    return document.location.host;\r\n}\r\n\r\nexport function isStream(track: models.Track) {\r\n    return track?.track_no == undefined;\r\n}\r\nexport function transformTrackDataToModel(track: (models.Track | undefined)): TrackModel {\r\n    if (!track) {\r\n        // noinspection UnnecessaryLocalVariableJS\r\n        let model: NoneTrackModel = {\r\n            type: TrackType.None\r\n        };\r\n        return model;\r\n    }\r\n    if (isStream(track)) {\r\n        // noinspection UnnecessaryLocalVariableJS\r\n        let model: StreamTrackModel = {\r\n            type: TrackType.Stream,\r\n            track,\r\n            name: track.name,\r\n            infoLines: []\r\n        };\r\n        return model;\r\n    }\r\n    //for now, assume it's a file track\r\n    let model: FileTrackModel = {\r\n        type: TrackType.File,\r\n        composer: \"\",\r\n        track,\r\n        title: track.name,\r\n        performer: \"\",\r\n        songlenght: 0\r\n    };\r\n    if (!track.name || track.name === '') {\r\n        let parts = track.uri.split('/');\r\n        model.title = decodeURI(parts[parts.length - 1])\r\n    }\r\n\r\n    if (validUri(track.name)) {\r\n        for (let key in getState().streamUris) {\r\n            let rs = getState().streamUris[key]\r\n            if (rs && rs[1] === track.name) {\r\n                model.title = (rs[0] || rs[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!track.length || track.length === 0) {\r\n        model.songlenght = getState().songlength = Infinity;\r\n    } else {\r\n        model.songlenght = getState().songlength = track.length;\r\n    }\r\n\r\n    //todo: fetch the image, set it in the model and the model should send an event: eboplayer:imageLoaded with the id of the track\r\n    // images.fetchAlbumImage(track.uri, ['infocover', 'albumCoverImg'], getState().mopidy);\r\n\r\n    return model;\r\n}\r\n\r\n","import getState from \"../playerState\";\r\nimport {EboplayerEvents, TrackType} from \"../model\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\n\r\nexport class BigTrackView extends View {\r\n    private id: string;\r\n    private streamLines: string;\r\n\r\n    constructor(id: string) {\r\n        super();\r\n        this.id = id;\r\n        this.streamLines = \"\";\r\n    }\r\n\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChangegd();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.trackListChanged, () => {\r\n            this.onTrackListChangegd();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.activeStreamLinesChanged, () => {\r\n            this.onStreamLinesChangegd();\r\n        });\r\n    }\r\n\r\n    private onStreamLinesChangegd() {\r\n        this.streamLines = getState().getModel().getActiveStreamLines().join(\"<br/>\");\r\n        document.getElementById(this.id).setAttribute(\"stream_lines\", this.streamLines);\r\n    }\r\n\r\n    private onTrackListChangegd() {\r\n        getState().getController().fetchCurrentTrackAndDetails();\r\n    }\r\n\r\n    private onCurrentTrackChangegd() {\r\n        let track  = getState().getModel().getCurrentTrack();\r\n        if(track.type == TrackType.None)\r\n            return; // don't clear the screen as this is probably temporary and will cause a flicker.\r\n        let div = document.getElementById(this.id);\r\n        let name = \"no current track\";\r\n        let info = \"\";\r\n        let position: string;\r\n        let button: string;\r\n        switch (track.type) {\r\n            case TrackType.Stream:\r\n                name = track.name;\r\n                position = \"100\";\r\n                button = \"false\";\r\n                break;\r\n            case TrackType.File:\r\n                name = track.title;\r\n                info = track.track.album.name;\r\n                position = \"60\"; //todo: just a test\r\n                button = \"true\";\r\n                let artists = track.track.artists.map(a => a.name).join(\", \");\r\n                let composers = track.track.composers.map(c => c.name).join(\", \");\r\n                if(artists)\r\n                    info += \"<br>\" + artists;\r\n                if(composers)\r\n                    info += \"<br>\" + composers;\r\n                break;\r\n        }\r\n        document.getElementById(this.id).setAttribute(\"name\", name);\r\n        document.getElementById(this.id).setAttribute(\"info\", info);\r\n        document.getElementById(this.id).setAttribute(\"position\", position);\r\n        document.getElementById(this.id).setAttribute(\"button\", button);\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.CurrentTrack, EboPlayerDataType.TrackList, EboPlayerDataType.StreamLines];\r\n    }\r\n\r\n}","import getState from \"../playerState\";\r\nimport {EboplayerEvents} from \"../model\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {inverseQuadratic100} from \"../controller\";\r\n\r\nexport class VolumeView extends View {\r\n    private readonly sliderId: string;\r\n    private isSourceOfChange: boolean = false;\r\n\r\n    constructor(sliderId: string) {\r\n        super();\r\n        this.sliderId = sliderId;\r\n    }\r\n\r\n    getSlider = () => (document.getElementById(this.sliderId) as HTMLInputElement);\r\n\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.volumeChanged, () => {\r\n            this.onVolumeChanged();\r\n        });\r\n\r\n        let slider = this.getSlider();\r\n        slider.oninput = (ev) => {\r\n            this.sendVolume(parseInt((ev.target as HTMLInputElement).value)).then();\r\n        };\r\n        slider.onmousedown = slider.ontouchstart = () => { this.isSourceOfChange = true;};\r\n        slider.onmouseup = slider.ontouchend = () => { this.isSourceOfChange = false;};\r\n    }\r\n\r\n    private onVolumeChanged() {\r\n        if(this.isSourceOfChange) {\r\n            return;\r\n        }\r\n        let volume = getState().getModel().getVolume();\r\n        let slider = document.getElementById(this.sliderId) as HTMLInputElement;\r\n        let visualVolume = inverseQuadratic100(volume); //todo: hide this in Controller?\r\n        slider.value = Math.floor(visualVolume).toString();\r\n    }\r\n\r\n    async sendVolume(value: number) {\r\n        await getState().getController().sendVolume(value);\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.Volume];\r\n    }\r\n}\r\n","import getState from \"../playerState\";\r\nimport {EboplayerEvents, PlayState, TrackType} from \"../model\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {VolumeView} from \"./volumeView\";\r\n\r\nexport class ButtonBarView extends View {\r\n    private containerId: string;\r\n    private volumeView: VolumeView;\r\n\r\n    constructor(containerId: string) {\r\n        super();\r\n        this.containerId = containerId;\r\n        this.volumeView = new VolumeView(`${this.containerId}.volumeslider`);\r\n        this.addChildren(this.volumeView);\r\n    }\r\n\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.playStateChanged, () => {\r\n            this.onPlaybackStateChangegd();\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChanged();\r\n        });\r\n\r\n        document.getElementById(`${this.containerId}.btnPlay`).onclick = () => {\r\n            this.playOrStopOrPause().then(r => {});\r\n        };\r\n    }\r\n\r\n    private onPlaybackStateChangegd() {\r\n        let state = getState().getModel().getPlayState();\r\n        switch (state) {\r\n            case PlayState.paused:\r\n            case PlayState.stopped:\r\n                this.setPlayButton('Play', ['fa-pause', 'fa-stop'], 'fa-play');\r\n                break;\r\n            case PlayState.playing:\r\n                if(getState().getModel().getCurrentTrack().type == TrackType.Stream)\r\n                    this.setPlayButton('Pause', ['fa-play'], 'fa-stop');\r\n                else\r\n                    this.setPlayButton('Pause', ['fa-play'], 'fa-pause');\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onCurrentTrackChanged() {\r\n        let currentTrack = getState().getModel().getCurrentTrack();\r\n        if(currentTrack.type == TrackType.Stream) {\r\n            View.getSubId(this.containerId, \"btnNext\").style.opacity = \"0.5\";\r\n            View.getSubId(this.containerId, \"btnPrev\").style.opacity = \"0.5\";\r\n        }\r\n    }\r\n\r\n    private async playOrStopOrPause() {\r\n        let playState = getState().getModel().getPlayState();\r\n        if (playState == PlayState.playing) {\r\n            if(getState().getModel().getCurrentTrack().type == TrackType.Stream)\r\n                return getState().getController().sendStop();\r\n            else\r\n                return getState().getController().sendPause();\r\n        } else {\r\n                return getState().getController().sendPlay();\r\n            }\r\n        }\r\n\r\n    private setPlayButton(title: string, removeClasses: string[], addClass: string) {\r\n        let btnPlayIcon = View.getSubId(this.containerId, 'btnPlay').querySelector('i');\r\n        btnPlayIcon.classList.remove(...removeClasses);\r\n        btnPlayIcon.classList.add(addClass);\r\n        btnPlayIcon.setAttribute('title', title);\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.PlayState];\r\n    }\r\n}\r\n\r\nfunction toggleButton(enabled: boolean) {\r\n    View.getSubId(this.containerId, \"btnPrev\").style.opacity =  enabled ? \"1\" : \"0.3\";\r\n }","\r\nexport interface HasName {\r\n    tagName: string;\r\n}\r\n\r\nexport abstract class EboComponent extends HTMLElement implements HasName {\r\n    //todo abstract static registerComponent(ctor: EboComponent);\r\n\r\n    protected constructor() {\r\n        super();\r\n    }\r\n        // noinspection JSUnusedGlobalSymbols\r\n    attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n        if(oldValue === newValue)\r\n            return;\r\n        this.attributeReallyChangedCallback(name, oldValue, newValue);\r\n    }\r\n\r\n    abstract attributeReallyChangedCallback(name: string, oldValue: string, newValue: string): void;\r\n}","import {EboComponent} from \"./EboComponent\";\r\n\r\nexport class EboProgressBar extends EboComponent {\r\n    static readonly tagName=  \"ebo-progressbar\";\r\n    private shadow: ShadowRoot;\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    private position: number = 51;\r\n    private min: number = 0;\r\n    private max: number = 100;\r\n    private active: boolean = false;\r\n    private button: boolean = true;\r\n    private styleTemplate: HTMLTemplateElement;\r\n\r\n    private divTemplate: HTMLTemplateElement;\r\n\r\n    constructor() {\r\n        super();\r\n        this.styleTemplate = document.createElement(\"template\");\r\n        // noinspection CssUnresolvedCustomProperty\r\n        this.styleTemplate.innerHTML = `\r\n<style>\r\n.movingGradient {\r\n    background-color: #555;\r\n}\r\n.active .movingGradient {\r\n    --darkGradient: #555;\r\n    background: linear-gradient(to right, var(--darkGradient),\r\n    #2a84a5, var(--darkGradient), #ffffff,\r\n        var(--darkGradient), #ca497c, var(--darkGradient), #9e9c2d, var(--darkGradient), #ee7752, var(--darkGradient),\r\n        #2a84a5\r\n    );\r\n    background-size: 1100% 1100%;  /*Must be a multiple of the number of colors above for a smooth transistion and the last color must be the first*/\r\n    animation: gradient 15s forwards infinite linear;\r\n    animation-timing-function: linear;\r\n    animation-direction: normal;\r\n}\r\n.button #button {\r\n        background-color: white;\r\n        width: 3px; \r\n        display: inline-block;\r\n        box-shadow: 0 0 5px white, 0 0 5px white,  0 0 5px white, 0 0 5px white, 0 0 15px white;\r\n}\r\n@keyframes gradient {\r\n    0% {\r\n        background-position: 0% 50%;\r\n    }\r\n    100% {\r\n        background-position: 100% 50%;\r\n    }\r\n}\r\n</style>`;\r\n        this.divTemplate = document.createElement(\"template\");\r\n        this.divTemplate.innerHTML = `\r\n<div style=\"\r\n    background-color: #444; \r\n    height: 1px; \r\n    display: flex; \r\n    \">\r\n    <div class=\"movingGradient\" style=\"\r\n        height: 1px;\r\n        display: inline-block;\">\r\n    </div>\r\n    <div id=\"button\"></div>\r\n</div>\r\n`;\r\n        this.shadow = this.attachShadow({mode: \"open\"});\r\n\r\n        this.render();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, oldValue: string, newValue: string) {\r\n        switch (name) {\r\n            case \"position\":\r\n            case \"min\":\r\n            case \"max\":\r\n                let test = parseInt(newValue);\r\n                if (isNaN(test))\r\n                    throw `\"${name}\" attribute should be a number. Current value: \"${newValue}\"`;\r\n                this[name] = test;\r\n                break;\r\n            case \"active\":\r\n            case \"button\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        if(!(this.min <= this.position && this.position <= this.max))\r\n            throw `Attribute position=\"${this.position}\" should be between min=\"${this.min}\" and max=\"${this.max}\".`;\r\n        this.render();\r\n        }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n    }\r\n\r\n    render() {\r\n        let percent = (this.position - this.min) / (this.max-this.min) * 100;\r\n        this.shadow.innerHTML=\"\";\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let styleElement = this.shadow.appendChild(document.createElement(\"style\"));\r\n        styleElement.innerHTML = `.movingGradient { width: ${percent}%; } `;\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        this.setClassFromBoolAttribute(\"button\", fragment.firstElementChild as HTMLElement);\r\n        this.setClassFromBoolAttribute(\"active\", fragment.firstElementChild as HTMLElement);\r\n        this.shadow.appendChild(fragment);\r\n    }\r\n\r\n    setClassFromBoolAttribute(attName: string, el: HTMLElement) {\r\n        if (this[attName] == true)\r\n            el.classList.add(attName);\r\n        else\r\n            el.classList.remove(attName);\r\n    }\r\n}","import getState from \"../playerState\";\r\nimport {EboplayerEvents, HistoryLine, TrackType} from \"../model\";\r\nimport {EboPlayerDataType, View} from \"./view\";\r\nimport {transformTrackDataToModel} from \"../controller\";\r\nimport {models} from \"../../mopidy_eboplayer2/static/js/mopidy\";\r\n\r\nexport class TimelineView extends View {\r\n    private clickedRow: HTMLTableRowElement;\r\n    bind() {\r\n        getState().getModel().addEventListener(EboplayerEvents.historyChanged, () => {\r\n            this.onHistoryChangegd().then(r => {});\r\n        });\r\n        getState().getModel().addEventListener(EboplayerEvents.currentTrackChanged, () => {\r\n            this.onCurrentTrackChanged();\r\n        });\r\n    }\r\n\r\n\r\n    private async onHistoryChangegd() {\r\n        let history = getState().getModel().getHistory();\r\n        let timelineTable = document.getElementById(\"timelineTable\") as HTMLTableElement;\r\n        let body = timelineTable.tBodies[0];\r\n        body.innerHTML = \"\";\r\n\r\n        let allLookups: Promise<void>[] = [];\r\n        for(let line of history) {\r\n            allLookups.push(this.insertTrackLine(line, body));\r\n        }\r\n\r\n        // noinspection ES6MissingAwait\r\n        getState().getController().fetchCurrentTrackAndDetails();\r\n\r\n        Promise.all(allLookups).then(()=> {\r\n            this.setActiveTrack();\r\n        });\r\n\r\n        body.querySelectorAll(\"tr\").forEach(tr => {\r\n            tr.addEventListener(\"click\", ev => {this.onRowDoubleClicked(ev)});\r\n            tr.addEventListener(\"dblclick\", ev => {this.onRowClicked(ev)});\r\n        });\r\n    }\r\n\r\n    private onRowClicked(ev: MouseEvent) {\r\n        this.clickedRow = ev.currentTarget as HTMLTableRowElement;\r\n    }\r\n\r\n    private async onRowDoubleClicked(ev: MouseEvent) {\r\n        await getState().getController().playTrack(this.clickedRow.dataset.uri);\r\n    }\r\n\r\n    private setActiveTrack() {\r\n        let timelineTable = document.getElementById(\"timelineTable\") as HTMLTableElement;\r\n        let currentTrack = getState().getModel().getCurrentTrack();\r\n        if (currentTrack.type == TrackType.None)\r\n            return; // don't clear the screen as this is probably temporary and will cause a flicker.\r\n        /*if (currentTrack.type != TrackType.None)*/ {\r\n            let currentUri = currentTrack.track.uri;\r\n            let tr = timelineTable.querySelector(`tr[data-uri=\"${currentUri}\"]`);\r\n            if(!tr)\r\n                return;\r\n            if(this.clickedRow?.dataset?.uri != currentTrack.track.uri)\r\n                tr.scrollIntoView( { block: \"nearest\" });\r\n            timelineTable.querySelectorAll(\"tr\").forEach(tr  => tr.classList.remove(\"active\", \"textGlow\"));\r\n            tr.classList.add(\"active\", \"textGlow\");\r\n        }\r\n    }\r\n\r\n    private insertTrackLine(line: HistoryLine, body: HTMLTableSectionElement) {\r\n        let slices = line.ref.name.split(\" - \");\r\n        let title = slices.pop();\r\n\r\n        let tr = document.createElement(\"tr\");\r\n        body.insertAdjacentElement('afterbegin', tr);\r\n        tr.classList.add(\"trackLine\");\r\n        tr.dataset.uri = line.ref.uri;\r\n        this.setTrackLineContent(tr, title);\r\n        body.insertAdjacentHTML('afterbegin', `\r\n<tr>\r\n    <td colspan=\"2\">\r\n        <div class=\"progressBar\"></div>\r\n    </td>\r\n</tr>\r\n            `);\r\n\r\n        //delayed update of track info.\r\n        return getState().getController().lookupCached(line.ref.uri).then(tracks => {\r\n            this.updateTrackLineFromLookup(tr, tracks, title);\r\n        });\r\n    }\r\n\r\n    private updateTrackLineFromLookup(tr: HTMLTableRowElement, tracks: models.Track[], title: string) {\r\n        let track = transformTrackDataToModel(tracks[0]);\r\n        let artist =  \"⚬⚬⚬\";\r\n        let album =  \"⚬⚬⚬\";\r\n        switch (track.type) {\r\n            case TrackType.File:\r\n                title = track.title;\r\n                artist = track.track.artists[0].name; //todo: add other names?\r\n                album = track.track.album.name;\r\n                break;\r\n            case TrackType.Stream:\r\n                title = track.name;\r\n                break;\r\n        }\r\n        this.setTrackLineContent(tr, title, artist, album);\r\n    }\r\n\r\n    private setTrackLineContent(tr: HTMLTableRowElement, title: string, artist: string = \"⚬⚬⚬\", album: string = \"⚬⚬⚬\") {\r\n        tr.innerHTML = `\r\n    <td>\r\n        <h1>${title}</h1>\r\n        <small>${artist} • ${album}</small>\r\n    </td>\r\n    <td>\r\n        <button><i class=\"fa fa fa-ellipsis-v\"></i></button>\r\n    </td>\r\n            `;\r\n    }\r\n\r\n    getRequiredDataTypes(): EboPlayerDataType[] {\r\n        return [EboPlayerDataType.TrackList];\r\n    }\r\n\r\n    private onCurrentTrackChanged() {\r\n        this.setActiveTrack();\r\n    }\r\n\r\n}\r\n","import {EboComponent} from \"./EboComponent\";\r\n\r\nexport class EboBigTrackView extends EboComponent {\r\n    static readonly tagName=  \"ebo-big-track-view\";\r\n    private shadow: ShadowRoot;\r\n    static progressBarAttributes = [\"position\", \"min\", \"max\", \"button\", \"active\"];\r\n    // noinspection JSUnusedGlobalSymbols\r\n    static observedAttributes = [\r\n        \"name\", \"stream_lines\", \"extra\", \"img\", \"disabled\",\r\n        ...EboBigTrackView.progressBarAttributes\r\n    ];\r\n    private name: string = \"\";\r\n    private stream_lines: string = \"\";\r\n    private extra: string = \"\";\r\n    private enabled: boolean = false;\r\n    //for progressBar\r\n    private position: string = \"40\";\r\n    private min: string = \"0\";\r\n    private max: string = \"100\";\r\n    private button: string = \"false\";\r\n    private active: string = \"true\";\r\n\r\n    private img: string  = \"images/default_cover.png\";\r\n    private styleTemplate: HTMLTemplateElement;\r\n    private divTemplate: HTMLTemplateElement;\r\n\r\n    constructor() {\r\n        super();\r\n        this.styleTemplate = document.createElement(\"template\");\r\n        // noinspection CssUnresolvedCustomProperty\r\n        this.styleTemplate.innerHTML = `\r\n            <style>\r\n                .albumCoverContainer {\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    flex-wrap: wrap;\r\n                    align-content: center;\r\n                }\r\n                ebo-progressbar {\r\n                    margin-top: .5em;\r\n                }\r\n                .selectable {\r\n                    -webkit-user-select: text;\r\n                    -moz-user-select: text;\r\n                    -ms-user-select: text;\r\n                    -o-user-select: text;\r\n                    user-select: text;\r\n                }\r\n            </style>\r\n        `;\r\n        this.divTemplate = document.createElement(\"template\");\r\n        this.divTemplate.innerHTML = `\r\n            <div class=\"albumCoverContainer\">\r\n                <img id=\"img\" src=\"${this.img}\" alt=\"Album cover\"/>\r\n                <ebo-progressbar position=\"${this.position}\" active=\"${this.active}\" button=\"${this.button}\"></ebo-progressbar>\r\n            </div>\r\n\r\n            <div id=\"info\">\r\n                <h3 id=\"name\"></h3>\r\n                <p id=\"stream_lines\" class=\"selectable\"></p>\r\n                <p id=\"extra\" class=\"selectable\"></p>\r\n            </div>\r\n        `;\r\n        this.shadow = this.attachShadow({mode: \"open\"});\r\n\r\n        this.render();\r\n    }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    attributeReallyChangedCallback(name: string, _oldValue: string, newValue: string) {\r\n        if(EboBigTrackView.progressBarAttributes.includes(name)) {\r\n            this[name] = newValue;\r\n            this.shadow.querySelector(\"ebo-progressbar\").setAttribute(name, newValue);\r\n            return;\r\n        }\r\n        switch (name) {\r\n            case \"name\":\r\n            case \"stream_lines\":\r\n            case \"extra\":\r\n            case \"img\":\r\n                this[name] = newValue;\r\n                break;\r\n            case \"enabled\":\r\n                if (![\"true\", \"false\"].includes(newValue))\r\n                    throw `\"${name}\" attribute should be \"true\" or \"false\". Current value: \"${newValue}\"`;\r\n                this[name] = newValue == \"true\";\r\n                break;\r\n        }\r\n        this.render();\r\n        }\r\n\r\n    // noinspection JSUnusedGlobalSymbols\r\n    connectedCallback() {\r\n    }\r\n\r\n    render() {\r\n        this.shadow.innerHTML=\"\";\r\n        this.shadow.appendChild(this.styleTemplate.content.cloneNode(true));\r\n        let fragment = this.divTemplate.content.cloneNode(true) as DocumentFragment;\r\n        [\"name\", \"stream_lines\", \"extra\"].forEach(attName => {\r\n            fragment.getElementById(attName).innerHTML = this[attName];\r\n        });\r\n        let progressBarElement = fragment.querySelector(\"ebo-progressbar\") as HTMLElement;\r\n        //todo: try casting to EboProgressBar class and set attributes directly? Without re-rendering?\r\n        EboBigTrackView.progressBarAttributes.forEach(attName => {\r\n            progressBarElement.setAttribute(attName, this[attName]);//todo: check if each of these causes a re-rendering.\r\n        });\r\n        //todo: image.\r\n        this.shadow.appendChild(fragment);\r\n    }\r\n\r\n    //todo: move in a base class.\r\n    setClassFromBoolAttribute(attName: string, el: HTMLElement) {\r\n        if (this[attName] == true)\r\n            el.classList.add(attName);\r\n        else\r\n            el.classList.remove(attName);\r\n    }\r\n}","import {Mopidy, Options} from \"../mopidy_eboplayer2/static/js/mopidy\";\r\nimport {SyncedProgressTimer} from \"./synced_timer\";\r\nimport getState, {setState, State} from \"./playerState\";\r\nimport {Model} from \"./model\";\r\nimport {HeaderView} from \"./views/headerView\";\r\nimport {Controller, getHostAndPort} from \"./controller\";\r\nimport {BigTrackView} from \"./views/bigTrackView\";\r\nimport {ButtonBarView} from \"./views/buttonBarView\";\r\nimport {EboProgressBar} from \"./components/eboProgressBar\";\r\nimport {TimelineView} from \"./views/timelineView\";\r\nimport {EboBigTrackView} from \"./components/eboBigTrackView\";\r\n\r\nexport function getWebSocketUrl() {\r\n    let webSocketUrl = document.body.dataset.websocketUrl;\r\n    if (webSocketUrl.startsWith(\"{{\"))\r\n        webSocketUrl = `ws://${getHostAndPort()}/mopidy/ws`;\r\n    return webSocketUrl;\r\n}\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\",function () {\r\n    let webSocketUrl = getWebSocketUrl();\r\n    let connectOptions: Options = {\r\n        webSocketUrl,\r\n        autoConnect: false //important: delay connection until all bindings, listeners and dependencies are setup.\r\n    };\r\n    let mopidy = new Mopidy(connectOptions);\r\n    let timer = new SyncedProgressTimer(8, mopidy);\r\n    let model = new Model();\r\n\r\n    let controller = new Controller(model, mopidy);\r\n\r\n    controller.initSocketevents();\r\n\r\n    let state = new State(mopidy, timer, model, controller);\r\n    setState(state);\r\n\r\n    let headerView = new HeaderView();\r\n    let currentTrackView = new BigTrackView(\"currentTrackBigView\");\r\n    let buttonBarView = new ButtonBarView(\"buttonBar\");\r\n    let historyView = new TimelineView();\r\n    getState().addViews(headerView, currentTrackView, buttonBarView, historyView);\r\n\r\n    mopidy.connect();\r\n\r\n    // document.getElementById(\"showBrowse\").onclick = async () => {\r\n        // let browse = await getState().commands.core.library.browse(null);\r\n        // console.log({browse});\r\n    // };\r\n});\r\n\r\nexport function console_yellow(msg: string) {\r\n    console.log(`%c${msg}`, 'background-color: yellow');\r\n}\r\nfunction updateDocumentTitle (headline) {\r\n    headline = headline || document.getElementById('contentHeadline').textContent;\r\n    document.title = headline + ' | ' + document.body.dataset.title;\r\n}\r\n\r\ncustomElements.define(EboProgressBar.tagName, EboProgressBar);\r\ncustomElements.define(EboBigTrackView.tagName, EboBigTrackView);\r\n"],"mappings":"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"}