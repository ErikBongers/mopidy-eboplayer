import * as fs from "node:fs";

//ARGUMENTS
let inputFile = "D:\\Documents\\Programming\\mopidy\\mopidy-eboplayer2\\scripts\\commands.json";
let outputFileName = "D:\\Documents\\Programming\\mopidy\\mopidy-eboplayer2\\mopidy_eboplayer2\\www\\typescript\\commands.ts";
let outFile: fs.WriteStream;
let includeComments: boolean = true;

main();

interface Param {
    name: string,
    default?: string | null
}

interface FuncDef {
    module: string;
    name: string;
    key: string;
    description: string;
    params: Param[] 
}

function main() {
    process.argv.forEach(function (val, index, array) {
        // console.log(index + ': ' + val);
    });

    let obj = JSON.parse(fs.readFileSync(inputFile, 'utf8'));

    // console.log(obj);

    let modules = new Map<string, Set<FuncDef>>();

    for(let key in obj.result) {
        let funcDefJson = obj.result[key];
        let parts = key.split(".");
        parts.shift(); //first item is always core.
        let moduleName = "";
        if(parts.length == 2)
            moduleName = parts.shift();

        let moduleSet = modules.get(moduleName);
        if(!moduleSet) {
            moduleSet = new Set<FuncDef>;
            modules.set(moduleName, moduleSet);
        }

        let functionName = parts.shift();
        functionName = snakeToCamel(functionName);

        let funcDef = {
            module: moduleName,
            name: functionName,
            key,
            description: funcDefJson.description,
            params: funcDefJson.params
        };

        moduleSet.add(funcDef);
    }

    outFile = fs.createWriteStream(outputFileName);

    writeLine(`//GENERATED by build_commands.ts (although probably customized, so do a diff when regenerating).
import models, {core, Mopidy} from "../js/mopidy";
import TlTrack = models.TlTrack;
import PlaybackState = core.PlaybackState;
import Playlist = models.Playlist;
import Track = models.Track;
import {SearchResult} from "./refs";
import Ref = models.Ref;
import {AllUris, LibraryDict} from "./modelTypes";

export class Commands {
    protected mopidy: Mopidy;
    
    constructor(mopidy: Mopidy) {
        this.mopidy = mopidy;
        this.core.commands = this;`, 0);

    modules.forEach((module,key) => {
        if(key)
            writeLine(`this.core.${key}.commands = this;`,8);
    });

    writeLine(
 `    }
    
    send(method: string, params?: Object) {
        if(params)
            return this.mopidy.send({method, params});
        else
            return this.mopidy.send({method});
    }
    core = {
        commands: undefined as Commands,
`, 0);

    modules.forEach((funcDefs, modName) => {
        writeModule(modName, funcDefs, 8);
    });

    writeLine("    }", 0);
    writeLine("}", 0);
    outFile.close();
}

function writeModule(modName: string, funcDefs: Set<FuncDef>, indent: number) {
    if (modName) {
        writeLine(`${modName}: {`, indent);
        writeLine(`commands: undefined as Commands,`, indent+4);
    }

    funcDefs.forEach(funcDef => {
        writeFunction(funcDef, indent+(modName? 4: 0));
    });

    if (modName)
        writeLine(`},`, indent);
}

function writeComments(funcDef: FuncDef, indent: number) {
    let dscrLines = funcDef.description.split("\n");
    dscrLines.forEach((line) => {
        writeLine(`//${line}`, indent+4);
    });
}

function extractReturnType(funcDef: FuncDef) {
    let rxReturnType = /\s*:rtype:(.*)/gm;
    let typeLine = rxReturnType.exec(funcDef.description)?.[1] ?? "";
    if (typeLine) {
        if(typeLine.includes("{uri: list of :class:`mopidy.models.Track`}"))
            return `Promise<LibraryDict>`;
        let optional = typeLine.includes(" or :class:`None`");
        let rxListOf = /\s*list\s+of\s+(.*)/gm;
        let listOf = rxListOf.exec(typeLine)?.[1] ?? "";
        listOf = stripOrNoneAndModuleName(listOf);
        if (listOf) {
            let rxClass = new RegExp("^:class:`(.*?)`", "gm");
            let classType = rxClass.exec(listOf)?.[1] ?? "";
            if (classType) {
                if(classType == "Ref")
                    classType = "Ref<AllUris>";
                return `Promise<${classType}[]>`;
            }
            let rxString = /^\s*(string)(?=\s|$)/gm;
            let stringType = rxString.exec(listOf)?.[1] ?? "";
            if (stringType) {
                return `Promise<${stringType}[]>`;
            }
            console.log(`Todo: Unknown returntype: "${listOf}"`);
        }
    }
    return "Promise<any>";
}

function writeFunction(funcDef: FuncDef, indent: number) {
    if(includeComments)
        writeComments(funcDef, indent);
    write(`${funcDef.name}(`, indent);
    
    writeParams(funcDef, indent);

    let paramsObject = "";
    if(funcDef.params.length) {
        paramsObject = `, {${funcDef.params.map(p => p.name).join(", ")}}`;
    }

    // get return type from description.
    let returnType = extractReturnType(funcDef);
    writeLine(`): ${returnType} {`,0);
    writeLine(`return this.commands.send("${funcDef.key}"${paramsObject}) as ${returnType};`, indent+4);
    writeLine("},", indent);
}

function snakeToCamel(name: string) {
    return name.replace(/(_[a-z])/g, (match) =>
        match.toUpperCase().replace("_", "")
    );
}

function write(text: string, indent?: number) {
    let indentString = indent ? ' '.repeat(indent) : '';
    outFile.write(`${indentString}${text}`);
}

function writeLine(line: string, indent: number) {
    write(`${line}\n`, indent);
}

function writeParams(funcDef: FuncDef, indent: number) {
    let paramList = funcDef.params
        .map((param) => {
            let paramString = "";
            let optional = "";
            let defaultValue = "";
            let type = guessParamType(funcDef, param);
            if(type != "Object") {
                if (param.default == null) {
                    //optional = "?"; //todo: this makes way too many params optional.
                } else {
                    defaultValue = ` = ${param.default}`;
                }
            }
            if(parseSphinxFields(param.name, funcDef.description).optional)
                optional = "?";
            paramString += ``;
            if(type)
                type = `: ${type}`;
            return `${param.name}${optional}${type}${defaultValue}`;
        })
        .join(", ");
    write(paramList);
}

type Result<T, E> = { success: true, value: T } | { success: false, error: E };
function Success<T>(value: T): Result<T, never> { return { success: true, value }; }
function Failure<E>(error: E): Result<never, E> { return { success: false, error }; }

function stripOrNoneAndModuleName(type: string) {
    type = type.replace(" or :class:`None`", "");
    return type.replace("mopidy.models.", "");
}

function findParamTypeInDescription(funcDef: FuncDef, param: Param): Result<string, undefined> {
    let result = findTypeExceptions(funcDef, param);
    if(result.success)
        return result;

    // e.g.  //:type query: dict
    let descLines = funcDef.description.split("\n");
    let paramLine = descLines.find(line => line.includes(`:type ${param.name}:`));
    let type = "";
    if (paramLine) {
        type = paramLine.replace(`:type ${param.name}: `, "");
        type = stripOrNoneAndModuleName(type);
        let rxClass = new RegExp(":class:`(.*?)`", "gm");
        type = rxClass.exec(type)?.[1] ?? type;
    } else {
        //2d try for pattern: ":param dict query:..."
        descLines.find(line => {
            let rxParamLine = new RegExp(`:param (\\S+) ${param.name}:`, "gm");
            let res = rxParamLine.exec(line);
            type = res?.[1] ?? type;
            return type != "";
        });
        if (type == "")
            return Failure(undefined);
    }
    switch (type) {
        case "dict": return Success("Object");
        case "list of string": return Success("string[]"); //todo: make generic
        case "bool":
        case "True":
        case "False":
            return Success("boolean"); //todo: make generic
        case "int": return Success("number"); //todo: make generic
        default: return Success(type);
    }
}

function guessParamType(funcDef: FuncDef, param: Param) {
    let result = findParamTypeInDescription(funcDef, param);
    if(result.success) {
        let type = result.value;
        switch (param.name) {
            case "tracks":
                return "undefined";
        }
        return type;
    }

    switch (param.name) {
        case "uri":
            return "string";
        case "mute":
        case "exact":
        case "value":
            return "boolean"
        case "volume":
            return "number";
        case "new_state":
            return "PlaybackState";
        case "playlist":
            return "Playlist";
        default:
            return "TODO";
    }

}

function findTypeExceptions(funcDef: FuncDef, param: Param): Result<string, undefined> {
    switch (funcDef.key) {
        case "core.tracklist.remove":
            return Success("string /*TODO: or list */");
        case "core.tracklist.filter":
            return Success("any /*TODO: a dict*/");
        default:
            return Failure(undefined);
    }
}

interface SphinxParamDef {
    optional: boolean,
    //type: string,,  //we currently don't care about other Sphinx definitions.
}
function parseSphinxFields(paramName: string, commentLines: string): SphinxParamDef {
    let rxTypeFollowedByNone = new RegExp(`.*:type.* ${paramName}:.+:class:\`None\``, "gm");
    return {
        optional: rxTypeFollowedByNone.test(commentLines)
    };
}