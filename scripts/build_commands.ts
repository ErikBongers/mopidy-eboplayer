import * as fs from "node:fs";

//ARGUMENTS
let inputFile = "D:\\Documents\\Programming\\mopidy\\mopidy-eboplayer2\\scripts\\commands.json";
let outputFileName = "D:\\Documents\\Programming\\mopidy\\mopidy-eboplayer2\\mopidy_eboplayer2\\www\\typescript\\commands.ts";
let includeComments: boolean = true;

interface Module {
    parent: Module | null,
    name: string,
    funcDefs: Set<FuncDef>,
    children: Module[]
}

interface Param {
    name: string,
    default?: string | null
}

interface FuncDef {
    module: Module;
    name: string;
    key: string;
    description: string;
    params: Param[] 
}

function getOrCreateModule(namespaces: string[], root: Module) {
    let currentModule = root;
    for (let nspace of namespaces ) {
        let foundModule = currentModule.children.find(m => m.name == nspace);
        if(foundModule) {
            //great, let's dive deeper
            currentModule = foundModule;
            continue;
        }
        //not found: create:
        let newModule: Module = {parent: currentModule, name: nspace, funcDefs: new Set(), children: []};
        currentModule.children.push(newModule);
        currentModule = newModule;
    }
    return currentModule;
}

function* treeIterator(root: Module): IterableIterator<Module> {
    yield root;
    if(root.children.length) {
        for(let child of root.children) {
            yield* treeIterator(child);
        }
    }
}

class Writer {
    private outFile: fs.WriteStream;

    constructor(outFile: fs.WriteStream) {
        this.outFile = outFile;
    }

    indent: number = 0;
    write(text: string, indent?: number) {
        let indentString = indent ? ' '.repeat(indent) : '';
        this.outFile.write(`${indentString}${text}`);
    }

    writeLine(line: string, indent: number) {
        this.write(`${line}\n`, indent);
    }

    indentLine(line: string) {
        this.write(`${' '.repeat(this.indent)}${line}\n`);
    }
}

main();

function main() {
    process.argv.forEach(function (val, index, array) {
        // console.log(index + ': ' + val);
    });

    let obj = JSON.parse(fs.readFileSync(inputFile, 'utf8'));
    let rootModule: Module = {parent: null, name: "", funcDefs: new Set(), children: []};

    for(let key in obj.result) {
        let parts = key.split(".");
        let module = getOrCreateModule(parts.slice(0, -1), rootModule);
        let funcDefJson = obj.result[key];
        let functionName = parts.pop() as string;
        functionName = snakeToCamel(functionName);

        let funcDef = {
            module: module,
            name: functionName,
            key,
            description: funcDefJson.description,
            params: funcDefJson.params
        };

        module.funcDefs.add(funcDef);
    }

    let writer = new Writer(fs.createWriteStream(outputFileName));

    writer.writeLine(`//GENERATED by build_commands.ts (although probably customized, so do a diff when regenerating).
import models, {core, Mopidy} from "../js/mopidy";
import {SearchResult} from "./refs";
import {AllUris, LibraryDict} from "./modelTypes";
import TlTrack = models.TlTrack;
import PlaybackState = core.PlaybackState;
import Playlist = models.Playlist;
import Ref = models.Ref;
`, 0);

    for(let module of treeIterator(rootModule)) {
        writeModule(writer, module);
    }
}
// Source - https://stackoverflow.com/a/1026087
// Posted by Steve Harrison, modified by community. See post 'Timeline' for change history
// Retrieved 2026-01-07, License - CC BY-SA 4.0

function capitalizeFirstLetter(text: string) {
    return String(text).charAt(0).toUpperCase() + String(text).slice(1);
}

function getModuleClassName(childModule: Module): string {
    if(childModule.parent && childModule.parent.parent != null)
        return `${getModuleClassName(childModule.parent)}_${capitalizeFirstLetter(childModule.name)}`;
    return capitalizeFirstLetter(childModule.name);
}

function writeModule(writer: Writer, module: Module) {
    let modName = module.name;
    let exportWord = "";
    let protectedWord = "";
    if(!modName) {
        modName = "Commands";
        exportWord = "export ";
        protectedWord = "protected ";
    }
    let moduleClassName = getModuleClassName(module);
    if(!moduleClassName)
        moduleClassName = "Commands";
    writer.writeLine(`${exportWord}class ${moduleClassName} {`, 0);
    writer.writeLine(`${protectedWord}mopidy: Mopidy;`, 4);

    for(let childModule of module.children) {
        writer.writeLine(`${childModule.name}: ${getModuleClassName(childModule)};`, 4);
    }

    writer.writeLine("", 0);
    writer.writeLine(`constructor(mopidy: Mopidy) {`, 4);
    writer.writeLine(`this.mopidy = mopidy;`, 8);
    for(let childModule of module.children) {
        writer.writeLine(`this.${childModule.name} = new ${getModuleClassName(childModule)}(mopidy);`, 8);
    }
    writer.writeLine("}", 4);
    if(module.funcDefs.size)
        writer.writeLine("", 0);

    module.funcDefs.forEach(funcDef => {
        writeFunction(writer, funcDef, 4);
    });

    writer.writeLine(`}`, 0);
    writer.writeLine("", 0);
}

function writeComments(writer: Writer, funcDef: FuncDef, indent: number) {
    let dscrLines = funcDef.description.split("\n");
    dscrLines.forEach((line) => {
        writer.writeLine(`//${line}`, indent);
    });
}

function extractReturnType(funcDef: FuncDef) {
    let rxReturnType = /\s*:rtype:(.*)/gm;
    let typeLine = rxReturnType.exec(funcDef.description)?.[1] ?? "";
    if (typeLine) {
        if(typeLine.includes("{uri: list of :class:`mopidy.models.Track`}"))
            return `Promise<LibraryDict>`;
        let optional = typeLine.includes(" or :class:`None`");
        let rxListOf = /\s*list\s+of\s+(.*)/gm;
        let listOf = rxListOf.exec(typeLine)?.[1] ?? "";
        listOf = stripOrNoneAndModuleName(listOf);
        if (listOf) {
            let baseType = extractBaseType(listOf);
            if (baseType)
                return `Promise<${baseType}[]>`;
            //Ain't no list.
            console.log(`Todo: Unknown list returntype: "${listOf}"`);
        }
        typeLine = stripOrNoneAndModuleName(typeLine);
        let baseType = extractBaseType(typeLine);
        if (baseType)
            return `Promise<${baseType}>`;
        console.log(`Todo: Unknown returntype: "${typeLine}"`);
    }
    return "Promise<any>";
}

function extractBaseType(typeLine:string) {
    let rxClass = /^\s*:class:`(.*?)`/gm;
    let classType = rxClass.exec(typeLine)?.[1] ?? "";
    if (classType) {
        if(classType == "Ref")
            classType = "Ref<AllUris>";
        return convertBaseType(classType);
    }
    let rxString = /^\s*(string)(?=\s|$)/gm;
    let stringType = rxString.exec(typeLine)?.[1] ?? "";
    if (stringType) {
        return stringType;
    }
    return "";
}

function convertBaseType(baseType: string) {
    switch (baseType) {
        case "bool" : return "boolean";
        case "int" : return "number";
        case "True" : return "boolean";
        case "False" : return "boolean";
        default: return baseType;
    }
}
function writeFunction(writer: Writer, funcDef: FuncDef, indent: number) {
    if(includeComments)
        writeComments(writer, funcDef, indent);
    writer.write(`${funcDef.name}(`, indent);
    
    writeParams(writer, funcDef, indent);

    let paramsObject = "";
    if(funcDef.params.length) {
        paramsObject = `, {${funcDef.params.map(p => p.name).join(", ")}}`;
    }

    // get return type from description.
    let returnType = extractReturnType(funcDef);
    writer.writeLine(`): ${returnType} {`,0);
    writer.writeLine(`return this.mopidy.send("${funcDef.key}"${paramsObject}) as ${returnType.replaceAll(" ", "")};`, indent+4);
    writer.writeLine("}", indent);
}

function snakeToCamel(name: string) {
    return name.replace(/(_[a-z])/g, (match) =>
        match.toUpperCase().replace("_", "")
    );
}

function writeParams(writer: Writer, funcDef: FuncDef, indent: number) {
    let paramList = funcDef.params
        .map((param) => {
            let paramString = "";
            let optional = "";
            let defaultValue = "";
            let type = guessParamType(funcDef, param);
            if(type != "Object") {
                if (param.default == null) {
                    //optional = "?"; //todo: this makes way too many params optional.
                } else {
                    defaultValue = ` = ${param.default}`;
                }
            }
            if(parseSphinxFields(param.name, funcDef.description).optional)
                optional = "?";
            paramString += ``;
            if(type)
                type = `: ${type}`;
            return `${param.name}${optional}${type}${defaultValue}`;
        })
        .join(", ");
    writer.write(paramList);
}

type Result<T, E> = { success: true, value: T } | { success: false, error: E };
function Success<T>(value: T): Result<T, never> { return { success: true, value }; }
function Failure<E>(error: E): Result<never, E> { return { success: false, error }; }

function stripOrNoneAndModuleName(type: string) {
    type = type.replace(" or :class:`None`", "");
    return type.replace("mopidy.models.", "");
}

function findParamTypeInDescription(funcDef: FuncDef, param: Param): Result<string, undefined> {
    let result = findTypeExceptions(funcDef, param);
    if(result.success)
        return result;

    // e.g.  //:type query: dict
    let descLines = funcDef.description.split("\n");
    let paramLine = descLines.find(line => line.includes(`:type ${param.name}:`));
    let type = "";
    if (paramLine) {
        type = paramLine.replace(`:type ${param.name}: `, "");
        type = stripOrNoneAndModuleName(type);
        let rxClass = new RegExp(":class:`(.*?)`", "gm");
        type = rxClass.exec(type)?.[1] ?? type;
    } else {
        //2d try for pattern: ":param dict query:..."
        descLines.find(line => {
            let rxParamLine = new RegExp(`:param (\\S+) ${param.name}:`, "gm");
            let res = rxParamLine.exec(line);
            type = res?.[1] ?? type;
            return type != "";
        });
        if (type == "")
            return Failure(undefined);
    }
    switch (type) {
        case "dict": return Success("Object");
        case "list of string": return Success("string[]"); //todo: make generic
        case "bool":
        case "True":
        case "False":
            return Success("boolean"); //todo: make generic
        case "int": return Success("number"); //todo: make generic
        default: return Success(type);
    }
}

function guessParamType(funcDef: FuncDef, param: Param) {
    if(funcDef.name == "play" && param.name == "tl_track")
        return "null";
    if(funcDef.name == "browse")
        return "string | null ";
    let result = findParamTypeInDescription(funcDef, param);
    if(result.success) {
        let type = result.value;
        switch (param.name) {
            case "tracks":
                return "undefined";
        }
        return type;
    }

    switch (param.name) {
        case "uri":
            return "string";
        case "mute":
        case "exact":
        case "value":
            return "boolean"
        case "volume":
            return "number";
        case "new_state":
            return "PlaybackState";
        case "playlist":
            return "Playlist";
        default:
            return "TODO";
    }

}

function findTypeExceptions(funcDef: FuncDef, param: Param): Result<string, undefined> {
    switch (funcDef.key) {
        case "core.tracklist.remove":
            return Success("string /*TODO: or list */");
        case "core.tracklist.filter":
            return Success("any /*TODO: a dict*/");
        default:
            return Failure(undefined);
    }
}

interface SphinxParamDef {
    optional: boolean,
    //type: string,,  //we currently don't care about other Sphinx definitions.
}
function parseSphinxFields(paramName: string, commentLines: string): SphinxParamDef {
    let rxTypeFollowedByNone = new RegExp(`.*:type.* ${paramName}:.+:class:\`None\``, "gm");
    return {
        optional: rxTypeFollowedByNone.test(commentLines)
    };
}