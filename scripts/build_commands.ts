import * as fs from "node:fs";

//ARGUMENTS
let inputFile = "P:\\mopidy\\mopidy-eboplayer2\\scripts\\commands.json";
let outputFileName = "P:\\mopidy\\mopidy-eboplayer2\\mopidy_eboplayer2\\www\\typescript\\commands.ts";
let outFile: fs.WriteStream;
let includeComments: boolean = true;

main();

interface Param {
    name: string,
    default?: string | null
}

interface FuncDef {
    module: string;
    name: string;
    key: string;
    description: string;
    params: Param[] 
}

function main() {
    process.argv.forEach(function (val, index, array) {
        // console.log(index + ': ' + val);
    });

    let obj = JSON.parse(fs.readFileSync(inputFile, 'utf8'));

    // console.log(obj);

    let modules = new Map<string, Set<FuncDef>>();

    for(let key in obj.result) {
        let funcDefJson = obj.result[key];
        let parts = key.split(".");
        parts.shift(); //first item is always core.
        let moduleName = "";
        if(parts.length == 2)
            moduleName = parts.shift();

        let moduleSet = modules.get(moduleName);
        if(!moduleSet) {
            moduleSet = new Set<FuncDef>;
            modules.set(moduleName, moduleSet);
        }

        let functionName = parts.shift();
        functionName = snakeToCamel(functionName);

        let funcDef = {
            module: moduleName,
            name: functionName,
            key,
            description: funcDefJson.description,
            params: funcDefJson.params
        };

        moduleSet.add(funcDef);
    }

    outFile = fs.createWriteStream(outputFileName);

    writeLine(`//GENERATED by build_commands.ts (although probably customized, so do a diff when regenerating).
import {core, models, Mopidy} from "../js/mopidy";
import TlTrack = models.TlTrack;
import PlaybackState = core.PlaybackState;
import Playlist = models.Playlist;

export class Commands {
    protected mopidy: Mopidy;
    
    constructor(mopidy: Mopidy) {
        this.mopidy = mopidy;
        this.core.commands = this;`, 0);

    modules.forEach((module,key) => {
        if(key)
            writeLine(`this.core.${key}.commands = this;`,8);
    });

    writeLine(`
    }
    
    send(method: string, params: Object) {
        if(params)
            return this.mopidy.send({method, params});
        else
            return this.mopidy.send({method});
    }
    core = {
        commands: undefined as Commands,
`, 0);

    modules.forEach((funcDefs, modName) => {
        writeModule(modName, funcDefs, 8);
    });

    writeLine("    }", 0);
    writeLine("}", 0);
    outFile.close();
}

function writeModule(modName: string, funcDefs: Set<FuncDef>, indent: number) {
    if (modName) {
        writeLine(`${modName}: {`, indent);
        writeLine(`commands: undefined as Commands,`, indent+4);
    }

    funcDefs.forEach(funcDef => {
        writeFunction(funcDef, indent+(modName? 4: 0));
    });

    if (modName)
        writeLine(`},`, indent);
}

function writeComments(funcDef: FuncDef, indent: number) {
    let dscrLines = funcDef.description.split("\n");
    dscrLines.forEach((line) => {
        writeLine(`//${line}`, indent+4);
    });
}

function writeFunction(funcDef: FuncDef, indent: number) {
    if(includeComments)
        writeComments(funcDef, indent);
    write(`${funcDef.name}(`, indent);
    
    writeParams(funcDef, indent);

    let paramsObject = "";
    if(funcDef.params.length) {
        paramsObject = `, {${funcDef.params.map(p => p.name).join(", ")}}`;
    }
    
    writeLine(`) {`,0);
    writeLine(`return this.commands.send("${funcDef.key}"${paramsObject});`, indent+4);
    writeLine("},", indent);
}

function snakeToCamel(name: string) {
    return name.replace(/(_[a-z])/g, (match) =>
        match.toUpperCase().replace("_", "")
    );
}

function write(text: string, indent?: number) {
    let indentString = indent ? ' '.repeat(indent) : '';
    outFile.write(`${indentString}${text}`);
}

function writeLine(line: string, indent: number) {
    write(`${line}\n`, indent);
}

function writeParams(funcDef: FuncDef, indent: number) {
    let paramList = funcDef.params
        .map((param) => {
            let paramString = "";
            let optional = "";
            let defaultValue = "";
            if(param.default == null) {
                optional = "?";
            } else {
                defaultValue = ` = ${param.default}`;
            }
            if(parseSphinxFields(param.name, funcDef.description).optional)
                optional = "?";
            paramString += ``;
            let type = guessParamType(funcDef, param);
            if(type)
                type = `: ${type}`;
            return `${param.name}${optional}${type}${defaultValue}`;
        })
        .join(", ");
    write(paramList);
}

type Result<T, E> = { success: true, value: T } | { success: false, error: E };
function Success<T>(value: T): Result<T, never> { return { success: true, value }; }
function Failure<E>(error: E): Result<never, E> { return { success: false, error }; }

function findParamTypeInDescription(funcDef: FuncDef, param: Param): Result<string, undefined> {
    let result = findTypeExceptions(funcDef, param);
    if(result.success)
        return result;

    // e.g.  //:type query: dict
    let descLines = funcDef.description.split("\n");
    let paramLine = descLines.find(line => line.includes(`:type ${param.name}:`));
    if(!paramLine)
        return Failure(undefined);
    let type = paramLine.replace(`:type ${param.name}: `, "");
    type = type.replace(" or :class:`None`", "");
    type = type.replace("mopidy.models.", "");
    let rxClass = new RegExp(":class:`(.*?)`", "gm");
    type = rxClass.exec(type)?.[1] ?? type;

    switch (type) {
        case "dict": return Success("Object");
        case "list of string": return Success("string[]"); //todo: make generic
        case "bool": return Success("boolean"); //todo: make generic
        case "int": return Success("number"); //todo: make generic
        default: return Success(type);
    }
}

function guessParamType(funcDef: FuncDef, param: Param) {
    let result = findParamTypeInDescription(funcDef, param);
    if(result.success) {
        let type = result.value;
        switch (param.name) {
            case "tracks":
                return "undefined";
        }
        return type;
    }

    switch (param.name) {
        case "query":
            return "Object";
        case "uri":
        case "uri_scheme":
        case "field":
        case "name":
            return "string";
        case "mute":
        case "exact":
        case "value":
            return "boolean"
        case "volume":
        case "tlid":
        case "start":
        case "end":
        case "to_position":
        case "time_position":
        case "at_position":
            return "number";
        case "uris":
            return "string[]";
        case "tl_track":
            return "TlTrack";
        case "new_state":
            return "PlaybackState";
        case "playlist":
            return "Playlist";
        default:
            return "TODO";
    }

}

function findTypeExceptions(funcDef: FuncDef, param: Param): Result<string, undefined> {
    switch (funcDef.key) {
        case "core.tracklist.remove":
            return Success("string /*TODO: or list */");
        case "core.tracklist.filter":
            return Success("any /*TODO: a dict*/");
        default:
            return Failure(undefined);
    }
}

interface SphinxParamDef {
    optional: boolean,
    //type: string,,  //we currently don't care about other Sphinx definitions.
}
function parseSphinxFields(paramName: string, commentLines: string): SphinxParamDef {
    let rxTypeFollowedByNone = new RegExp(`.*:type.* ${paramName}:.+:class:\`None\``, "gm");
    return {
        optional: rxTypeFollowedByNone.test(commentLines)
    };
}